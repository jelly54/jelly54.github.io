<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱吃jelly的Jelly</title>
  
  <subtitle>就揪啾  就是 Jelly</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jelly54.github.io/"/>
  <updated>2020-08-28T05:56:07.835Z</updated>
  <id>https://jelly54.github.io/</id>
  
  <author>
    <name>Big Jelly</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>synchronized的锁升级、锁膨胀</title>
    <link href="https://jelly54.github.io/java-lock-upgrade/"/>
    <id>https://jelly54.github.io/java-lock-upgrade/</id>
    <published>2020-08-25T12:55:37.000Z</published>
    <updated>2020-08-28T05:56:07.835Z</updated>
    
    <content type="html"><![CDATA[<p>本文将将讲解java中synchronized从偏向锁逐步走到轻量级锁、自旋锁再到重量级锁的过程，以及java8中的锁降级优化。</p><a id="more"></a><ul><li><a href="#%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a></li><li><a href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81">轻量级锁</a></li><li><a href="#%E8%87%AA%E6%97%8B%E9%94%81">自旋锁</a></li><li><a href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81">重量级锁</a></li><li><a href="#%E9%94%81%E9%99%8D%E7%BA%A7">锁降级</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%94%81%E4%BF%A1%E6%81%AF%E5%AD%98%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E5%A4%B4%E9%87%8C">为什么锁信息存放在对象头里</a></li></ul><h1 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h1><p>偏向<strong>第一个</strong>拿到锁的线程。</p><p>即第一个拿到锁的线程，锁会在对象头Mark Word中通过CAS<strong>记录线程ID</strong>，该线程以后每次拿锁时都<strong>不需要进行CAS</strong>（指轻量级锁）。</p><p>如果该线程正在执行同步代码块时有其他线程在<strong>竞争</strong>（指其他线程尝试CAS让Mark Work设置自己的线程ID），会<strong>被升级</strong>为轻量级锁。</p><p>如果其他线程发现Mark Word里记的不是自己，且发现原持有偏向锁的线程已经执行完同步代码块，会尝试CAS把Mark Word中的改为自己的线程ID。</p><h1 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h1><p>轻量级锁就是通过<strong>CAS</strong>进行加锁的。</p><p>JVM会给线程的<strong>栈帧</strong>中创建一个叫<strong>锁记录Lock Record</strong>的空间，把对象头Mark Word复制到该空间里（Displaced Mark Word），并通过<strong>CAS</strong>尝试把原对象头Mark Word中锁记录指针指向该锁记录。如果成功，表示线程拿到了锁。如果失败，则进行自选（<strong>自旋锁</strong>），自旋超过一定次数时升级为重量级锁，这时该线程会被内核挂起。</p><h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><p>轻量级锁膨胀为重量级锁前，线程在执行monitorenter指令进入<strong>等待队列</strong>时，会通过<strong>自旋</strong>去尝试获得锁。</p><p>如果自旋超过一定次数时还未拿到锁，就会进入<strong>阻塞</strong>状态，等待内核来调度。此时会发生内核态与用户态之间的上下文切换，所以会影响性能（引入自旋锁就是为了减少这个开销）。</p><p>因为后面的线程也进行自选尝试获取锁，所以这对于已被阻塞的那些线程来说，会<strong>不公平</strong>。</p><h1 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h1><p>重量级锁就是通过内核来操作线程。因为频繁出现内核态与用户态的切换，会严重影响性能。</p><p>升级为重量级锁时会在堆中创建monitor对象，并将Mark Work指向该monitor对象。monitor中有cxq（ContentionList），EntryList，WaitSet，owner</p><p><img src="https://s1.ax1x.com/2020/08/27/d4HTbR.png" alt="d4HTbR.png"></p><h1 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h1><p>Hotspot在1.8开始有了锁降级。在STW期间JVM进入安全点时如果发现有闲置的monitor（重量级锁对象），就会进行锁降级。</p><p><img src="https://s1.ax1x.com/2020/08/27/d4Hor9.jpg" alt="d4Hor9.jpg"></p><h1 id="为什么锁信息存放在对象头里"><a href="#为什么锁信息存放在对象头里" class="headerlink" title="为什么锁信息存放在对象头里"></a>为什么锁信息存放在对象头里</h1><p>死磕Sunchronized底层实现–概论中：</p><p>因为在Java中任意对象都可以用作锁，因此必定要有一个映射关系，存储该对象以及其对应的锁信息（比如当前哪个线程持有锁，哪些线程在等待）。一种很直观的方法是，用一个全局map，来存储这个映射关系，但这样会有一些问题：需要对map做线程安全保障，不同的<em>sunchronized</em>之间会互相影响，性能差；另外当同步对象较多时，该map可能会占用比较多的内存。</p><p>所以最好的办法是将这个映射关系存储在对象头中，因为对象头本身也有一些hashcode、GC相关的数据，所以如果能将锁信息与这些信息<strong>共存</strong>在对象头中就好了。</p><p>也就是说，如果用一个全局map来存对象的锁信息，还需要对该map做线程安全处理，不同的锁之间会有影响，所以直接存到对象头。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将将讲解java中synchronized从偏向锁逐步走到轻量级锁、自旋锁再到重量级锁的过程，以及java8中的锁降级优化。&lt;/p&gt;
    
    </summary>
    
      <category term="Java锁" scheme="https://jelly54.github.io/categories/Java%E9%94%81/"/>
    
    
      <category term="锁" scheme="https://jelly54.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>断点续传小解</title>
    <link href="https://jelly54.github.io/net-break-transport/"/>
    <id>https://jelly54.github.io/net-break-transport/</id>
    <published>2020-08-23T13:05:05.000Z</published>
    <updated>2020-08-28T06:00:32.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="断点续传的原理"><a href="#断点续传的原理" class="headerlink" title="断点续传的原理"></a>断点续传的原理</h1><p>HTTP 协议是互联网上应用最广泛网络传输协议之一，它基于 TCP/IP 通信协议来传递数据。断点续传的奥秘就隐藏在这 HTTP 协议中了。</p><p>我们知道HTTP请求会有一个Request header 和 Response header，在请求头里边有个和Range相关的参数</p><a id="more"></a><p>当下载文件的时候，response header会有如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 65804256  // 请求的文件的大小，单位 byte</span><br><span class="line">Accept-Ranges: bytes      // 是否允许指定传输范围，bytes：范围请求的单位是 bytes （字节），none：不支持任何范围请求单位，</span><br><span class="line">Last-Modified: Tue, 07 Jul 2020 13:19:46 GMT  // 服务端文件最后修改时间，可以用于校验文件是否更改过</span><br><span class="line">x-bs-meta-crc32: 3545941535 // crc32，可以用于校验文件是否更改过</span><br><span class="line">ETag: dcd0bfef7d90dbb3de50a26b875143fc //Etag 标签，可以用于校验文件是否更改过</span><br></pre></td></tr></table></figure><p>可见<font color="red">并不是所有的下载都支持断点续传，只有在response header中有 Accpet-Ranges: bytes字段时，才可以断点续传。</font></p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>利用content-range字段，就可以实现断点续传了。只需要在response header中指定Content-Range值就可以了。</p><p>使用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Content-Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;/&lt;size&gt; // size 为文件总大小,如果不知道可以用 *</span><br><span class="line">Content-Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;/*  </span><br><span class="line">Content-Range: &lt;unit&gt;=&lt;range-start&gt;-</span><br><span class="line">Content-Range: &lt;unit&gt;=*/&lt;size&gt;</span><br></pre></td></tr></table></figure><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>单位 bytes，从第 10 个 bytes 开始下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Range: bytes=10-</span><br></pre></td></tr></table></figure><p>单位 bytes，从第 10 个 bytes 开始下载，下载到第100个 bytes</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Range: bytes=10-100</span><br></pre></td></tr></table></figure><h1 id="重启续传文件时保证文件一致性"><a href="#重启续传文件时保证文件一致性" class="headerlink" title="重启续传文件时保证文件一致性"></a>重启续传文件时保证文件一致性</h1><h2 id="下载中，如何保证文件的完整性？"><a href="#下载中，如何保证文件的完整性？" class="headerlink" title="下载中，如何保证文件的完整性？"></a>下载中，如何保证文件的完整性？</h2><p>我们要写的下载器是支持断点续传的，那么在进行续传时，怎么确定文件从我们上次下载时没有进行更新呢？这里通过response header中的几个属性值进行判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Tue, 07 Jul 2020 13:19:46 GMT  // 服务端文件最后修改时间，可以用于校验文件是否更改过</span><br><span class="line">ETag: dcd0bfef7d90dbb3de50a26b875143fc //Etag 标签，可以用于校验文件是否更改过</span><br><span class="line">x-bs-meta-crc32: 3545941535 // crc32，可以用于校验文件是否更改过</span><br></pre></td></tr></table></figure><ul><li>ETag: 根据 HTTP 协议的规定，当文件更新时，是会生成新的 ETag 值的，它类似于文件的指纹信息</li><li>Last-Modified: 只是上次修改时间，有时候可能并不能够证明文件内容被修改过</li></ul><h2 id="写入阶段，如何保证文件顺序"><a href="#写入阶段，如何保证文件顺序" class="headerlink" title="写入阶段，如何保证文件顺序?"></a>写入阶段，如何保证文件顺序?</h2><p>不管单线程还是多线程，由于要断点续传，在写入时都要在指定位置进行字符追加。</p><p>在Java中使用RandomAccessFile类，它可以在使用时指定读写模式，使用 seek 方法可以随意移动要操作的文件指针位置。很适合断点续传的写入场景。使用它你可以快速定位到已知的位置，进行快速检索；也可以在同一个文件的不同位置进行并发读写。</p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>在 aaa.text 文件中的位置 0 开始写入字符 abcdef，在位置 100 的位置开始写入字符 ddeeff。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// rw 为读写模式</span><br><span class="line">try (RandomAccessFile rw = new RandomAccessFile(&quot;test.txt&quot;, &quot;rw&quot;))&#123; </span><br><span class="line">    // 移动文件内容指针位置 </span><br><span class="line">    rw.seek(0);</span><br><span class="line">    rw.writeChars(&quot;abc&quot;);</span><br><span class="line">    rw.seek(100);</span><br><span class="line">    rw.writeChars(&quot;ddd&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="网速贷宽固定，为什么多线程下载可以提速"><a href="#网速贷宽固定，为什么多线程下载可以提速" class="headerlink" title="网速贷宽固定，为什么多线程下载可以提速"></a>网速贷宽固定，为什么多线程下载可以提速</h1><p>最大网速是固定的，运营商给你 100Mbs的网速，不管你怎么使用，速度最大也就是100/8=12.5MB/s。那么为什么多线程下载可以提高下载速度呢?</p><p>理论上来说，单线程下载就可以达到最大的理想网速，但是事实是，网络经常不那么通畅，很难达到理想的最大速度，也就是说只有在网路不那么通畅的时候，多线程下载才能提速。</p><h2 id="多线程下载提速原因"><a href="#多线程下载提速原因" class="headerlink" title="多线程下载提速原因"></a>多线程下载提速原因</h2><p>HTTP 协议在传输时候是基于 TCP 协议传输数据的，TCP 协具有拥塞控制机制。拥塞控制 是TCP 的一个避免网络拥塞的算法，它是基于和性增长/乘性降低这样的控制方法来控制拥塞的。</p><p><img src="https://s1.ax1x.com/2020/08/01/a8Gc0s.png" alt="a8Gc0s.png"></p><p>简单来说就是在 TCP 开始传输数据时，服务端会不断的探测可用带宽。在一个传输内容段被成功接收后，会加倍传输两倍段内容，如果再次被成功接收，就继续加倍，直到发生了丢包，这是这也被叫做慢启动。当达到<strong>慢启动阀值（ssthresh）</strong>时，慢启动算法就会转换为线性增长的阶段，每次只增加一个分段，放缓增加速度。我觉得其实慢启动的加倍增速过程并不慢，只是一种叫法。</p><p>但是当发生了丢包，也就是检测到拥塞时，发送方就会将发送段大小降低一个乘数，比如二分之一，慢启动阈值降为超时前拥塞窗口的一半大小、拥塞窗口会降为1个MSS，并且重新回到慢启动阶段。这时多线程的优势就体现出来了，因为你的多线程会让这个速度减速没有那么猛烈，毕竟这时可能有另一个线程正处在慢启动的在最终加速阶段，这样总体的下载速度就优于单线程了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;断点续传的原理&quot;&gt;&lt;a href=&quot;#断点续传的原理&quot; class=&quot;headerlink&quot; title=&quot;断点续传的原理&quot;&gt;&lt;/a&gt;断点续传的原理&lt;/h1&gt;&lt;p&gt;HTTP 协议是互联网上应用最广泛网络传输协议之一，它基于 TCP/IP 通信协议来传递数据。断点续传的奥秘就隐藏在这 HTTP 协议中了。&lt;/p&gt;
&lt;p&gt;我们知道HTTP请求会有一个Request header 和 Response header，在请求头里边有个和Range相关的参数&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://jelly54.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="原理" scheme="https://jelly54.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="TCP/IP" scheme="https://jelly54.github.io/tags/TCP-IP/"/>
    
      <category term="网络" scheme="https://jelly54.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>基于深度学习的车型APP-毕设</title>
    <link href="https://jelly54.github.io/graduation-project/"/>
    <id>https://jelly54.github.io/graduation-project/</id>
    <published>2020-07-13T02:01:42.000Z</published>
    <updated>2020-08-28T02:39:14.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>通过深度学习技术搭建残差网络，<a href="http://mmlab.ie.cuhk.edu.hk/datasets/comp_cars/index.html" target="_blank" rel="noopener">使用CompsCars数据集</a> 进行车型识别模型的训练，并将训练好的模型移植到了Android端，实现了通过手机扫一扫的方式进行汽车车型识别的功能。</p><p>项目涉及到的技术点较多，需要开发者有一定的技术功底。如：python语言的使用、深度学习框架pytorch的使用、爬虫脚本的理解、Java语言的使用、Android平台架构的理解等等。</p><p>虽然属于跨语言开发，但是要求并不高，只要达到入门级别即可看懂本项目，并可以尝试一些定制化的改造。毕竟框架已经搭建好了，只需要修改数据源、重新训练出模型，就可以实现一款新的应用啦。</p><a id="more"></a><hr><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p>以下视频将展示所有功能完成后的APP的使用情况。</p><p><a href="https://www.bilibili.com/video/BV1Pk4y1B7qK" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Pk4y1B7qK</a></p><h2 id="模型训练精度"><a href="#模型训练精度" class="headerlink" title="模型训练精度"></a>模型训练精度</h2><p>以下是使用Resnet-34进行400次车型识别训练的 train-validation图表。</p><p><img src="https://s1.ax1x.com/2020/07/14/Utg8HO.png" alt="Utg8HO.png"></p><p>以下是使用Resnet-34进行400次车型识别训练 Top-1的错误率。</p><p><img src="https://s1.ax1x.com/2020/07/14/Utg3DK.png" alt="Utg3DK.png"></p><p>以下是使用Resnet-34进行400次车型识别训练 Top-5的错误率。</p><p><img src="https://s1.ax1x.com/2020/07/14/UtgJED.png" alt="UtgJED.png"></p><h2 id="扫一扫识别功能"><a href="#扫一扫识别功能" class="headerlink" title="扫一扫识别功能"></a>扫一扫识别功能</h2><p>以下是移植到android平台后进行识别的结果展示图。<br><img src="https://s1.ax1x.com/2020/07/14/UtcItH.png" alt="UtcItH.png"></p><hr><h1 id="使用的技术-amp-框架"><a href="#使用的技术-amp-框架" class="headerlink" title="使用的技术&amp;框架"></a>使用的技术&amp;框架</h1><ul><li>开发语言：Python、Java</li><li>技术框架：pytorch、resnet-34、Android平台</li><li>可选借助平台：百度AI平台</li><li>项目构成：模型训练项目、爬虫项目、APP开发项目</li></ul><h2 id="软-硬件需求"><a href="#软-硬件需求" class="headerlink" title="软/硬件需求"></a>软/硬件需求</h2><h3 id="机器要求"><a href="#机器要求" class="headerlink" title="机器要求"></a>机器要求</h3><blockquote><p>因为涉及到机器学习模型训练，所以你应该拥有一台用来训练模型的机器，<strong>且需要搭载支持CUDA的GPU</strong>（如：GeForce、GTX、Tesla等），显存大小，自然是越大越好。</p></blockquote><p>本人项目环境：</p><ul><li>windows10 专业版；GeForce MAX150；独显 2G；1T硬盘</li></ul><p>也就是说这是最低配了，你至少要和我同一配置。</p><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><ul><li>Pycharm：用来训练模型、pyhton爬虫、模型移植脚本</li><li>Android Studio：用来开发安卓APP</li></ul><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p><strong>数据集是项目最重要的一部分，有了数据集才能开始训练</strong></p><p>本项目使用的是 <a href="http://mmlab.ie.cuhk.edu.hk/datasets/comp_cars/index.html" target="_blank" rel="noopener">香港中文大学的CompCars细粒度汽车数据集</a>。</p><p><img src="http://mmlab.ie.cuhk.edu.hk/datasets/comp_cars/illustration.png" alt="CompCars数据集"></p><p>需要的同学可以私聊找我要网盘链接。</p><hr><h1 id="各模块介绍"><a href="#各模块介绍" class="headerlink" title="各模块介绍"></a>各模块介绍</h1><h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><p>Github 地址：<a href="https://github.com/jelly54/pytorch_train" target="_blank" rel="noopener">pytorch_train</a></p><p><img src="https://s1.ax1x.com/2020/07/14/UtyvKf.png" alt="UtyvKf.png"></p><p>训练模型主要分为五个模块：启动器、自定义数据加载器、网络模型、学习率/损失率调整以及训练可视化。</p><p>启动器是项目的入口，通过对启动器参数的设置，可以进行很多灵活的启动方式，下图为部分启动器参数设置。</p><p><img src="https://s1.ax1x.com/2020/07/14/UtciwD.png" alt="UtciwD.png"></p><p>任何一个深度学习的模型训练都是离不开数据集的，根据多种多样的数据集，我们应该使用一个方式将数据集用一种通用的结构返回，方便网络模型的加载处理。</p><p><img src="https://s1.ax1x.com/2020/07/14/Utc9OK.png" alt="Utc9OK.png"></p><p>这里使用了残差网络Resnet-34，代码中还提供了Resnet-18、Resnet-50、Resnet-101以及Resnet-152。残差结构是通过一个快捷连接，极大的减少了参数数量，降低了内存使用。</p><p>以下为残差网络的基本结构和Resnet-34 部分网络结构图。</p><p><img src="https://s1.ax1x.com/2020/07/14/UtcPeO.png" alt="UtcPeO.png"></p><p><img src="https://s1.ax1x.com/2020/07/14/Utcn6P.png" alt="Utcn6P.png"></p><p>除了最开始看到的train-val图表、Top-、Top-5的error记录表以外，在训练过程中，使用进度条打印当前训练的进度、训练精度等信息。打印时机可以通过上边提到的 启动器 优雅地配置。</p><p><img src="https://s1.ax1x.com/2020/07/14/Utc3kQ.png" alt="Utc3kQ.png"></p><p>以下为最终的项目包架构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pytorch_train</span><br><span class="line">  |-- data                -- 存放读取训练、校验、测试数据路径的txt</span><br><span class="line">  |   |-- train.txt       </span><br><span class="line">  |   |-- val.txt</span><br><span class="line">  |   |-- test.txt</span><br><span class="line">  |-- result              -- 存放最终生成训练结果的目录</span><br><span class="line">  |-- util                -- 模型移植工具</span><br><span class="line">  |-- clr.py              -- 学习率</span><br><span class="line">  |-- dataset.py          -- 自定义数据集</span><br><span class="line">  |-- flops_benchmark.py  -- 统计每秒浮点运算次数</span><br><span class="line">  |-- logger.py           -- 日志可视化</span><br><span class="line">  |-- mobile_net.py       -- 网络模型之一 mobile_net2</span><br><span class="line">  |-- resnet.py           -- 网络模型之一 Resnet系列</span><br><span class="line">  |-- run.py              -- 具体执行训练、测试方法</span><br><span class="line">  |-- start.py            -- 启动器</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/07/14/UtgkuV.png" alt="UtgkuV.png"></p><h2 id="数据抓取"><a href="#数据抓取" class="headerlink" title="数据抓取"></a>数据抓取</h2><p>Github 地址：<a href="https://github.com/jelly54/crawler/tree/master/dongchedi" target="_blank" rel="noopener">crawer/dongchedi</a></p><p><img src="https://s1.ax1x.com/2020/07/14/UtyXxP.png" alt="UtyXxP.png"></p><p>最终获取的数据如下图：</p><p><img src="https://s1.ax1x.com/2020/07/14/Utc8Yj.png" alt="Utc8Yj.png"></p><h2 id="模型移植"><a href="#模型移植" class="headerlink" title="模型移植"></a>模型移植</h2><p>Github 地址：<a href="https://github.com/jelly54/pytorch_train/blob/master/util/transfor.py" target="_blank" rel="noopener">pytorch_train/transfor</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line">model_pth = os.path.join(<span class="string">"results"</span>, <span class="string">"2020-04-27_10-27-17"</span>, <span class="string">'checkpoint.pth.tar'</span>)</span><br><span class="line"><span class="comment"># 将resnet34模型保存为Android可以调用的文件</span></span><br><span class="line">mobile_pt = os.path.join(<span class="string">"results"</span>, <span class="string">"2020-04-27_10-27-17"</span>, <span class="string">'resnet34.pt'</span>)</span><br><span class="line">num_class = <span class="number">13</span></span><br><span class="line">device = <span class="string">'cpu'</span>  <span class="comment"># 'cuda:0'  # cpu</span></span><br><span class="line"></span><br><span class="line">model = torchvision.models.resnet34(num_classes=num_class)</span><br><span class="line">model = torch.nn.DataParallel(model, [<span class="number">0</span>])</span><br><span class="line">model.to(device=device)</span><br><span class="line"></span><br><span class="line">checkpoint = torch.load(model_pth, map_location=device)</span><br><span class="line">model.load_state_dict(checkpoint[<span class="string">'state_dict'</span>])</span><br><span class="line"></span><br><span class="line">model.eval()  <span class="comment"># 模型设为评估模式</span></span><br><span class="line"><span class="comment"># 1张3通道224*224的图片</span></span><br><span class="line">input_tensor = torch.rand(<span class="number">1</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>)  <span class="comment"># 设定输入数据格式</span></span><br><span class="line">traced_script_module = torch.jit.trace(model.module, input_tensor)  <span class="comment"># 模型转化</span></span><br><span class="line">traced_script_module.save(mobile_pt)  <span class="comment"># 保存文件</span></span><br></pre></td></tr></table></figure><h2 id="安卓界面-amp-数据走向"><a href="#安卓界面-amp-数据走向" class="headerlink" title="安卓界面&amp;数据走向"></a>安卓界面&amp;数据走向</h2><p>Github 地址：<a href="https://github.com/jelly54/carIdentify" target="_blank" rel="noopener">carIdentify</a></p><p><img src="https://s1.ax1x.com/2020/07/14/UtyO2t.png" alt="UtyO2t.png"></p><p>实现了以下功能：</p><ul><li>调用摄像头权限自动申请</li><li>摄像头预览</li><li>读取pytorch训练模型</li><li>调用第三方接口，精准预测</li></ul><p>最终界面展示：</p><p><img src="https://s1.ax1x.com/2020/07/14/UtgABT.png" alt="UtgABT.png"></p><p>安卓项目结构如图：</p><p><img src="https://s1.ax1x.com/2020/07/14/UtgEHU.png" alt="UtgEHU.png"></p><hr><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="启动模型训练"><a href="#启动模型训练" class="headerlink" title="启动模型训练"></a>启动模型训练</h2><p><font color="red">启动前需要确保你已经有了本项目使用的数据集 CompCars</font></p><h3 id="重新开始新的训练"><a href="#重新开始新的训练" class="headerlink" title="重新开始新的训练"></a>重新开始新的训练</h3><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python start.py --data_root "./data" --gpus 0,1,2 -w 2 -b 120 --num_class 13</span><br></pre></td></tr></table></figure><ul><li>–data_root 数据集路径位置</li><li>–gups 使用gpu训练的块数</li><li>-w 为gpu加载自定义数据集的工作线程</li><li>-b 用来gpu训练的 batch size是多少</li><li>–num_class 分类类别数量</li></ul><h3 id="使用上次训练结果继续训练"><a href="#使用上次训练结果继续训练" class="headerlink" title="使用上次训练结果继续训练"></a>使用上次训练结果继续训练</h3><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python start.py --data_root "./data" --gpus 0,1,2 -w 2 -b 120 --num_class 13 --resume "results/2020-04-14_12-36-16"</span><br></pre></td></tr></table></figure><ul><li>–data_root 数据集路径位置</li><li>–gups 使用gpu训练的块数</li><li>-w 为gpu加载自定义数据集的工作线程</li><li>-b 用来gpu训练的 batch size是多少</li><li>–num_class 分类类别数量</li><li>–resume 上次训练结果文件夹，可继续上次的训练</li></ul><h3 id="模型移植-1"><a href="#模型移植-1" class="headerlink" title="模型移植"></a>模型移植</h3><p>将训练好的模型转换为Android可以执行的模型</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python transfor.py</span><br></pre></td></tr></table></figure><h3 id="项目定制化"><a href="#项目定制化" class="headerlink" title="项目定制化"></a>项目定制化</h3><ul><li>找寻自己的数据集</li><li>需要修改启动脚本中 <strong>–num_class</strong>，模型类别</li></ul><p>目前项目中具备很多备注记录，稍加review代码就可以理解，如有不清楚，可以私信询问。</p><h2 id="启动APP"><a href="#启动APP" class="headerlink" title="启动APP"></a>启动APP</h2><p>APP下载链接：<a href="https://pan.baidu.com/s/1X7tobj4R302WmGu116-2mg" target="_blank" rel="noopener">https://pan.baidu.com/s/1X7tobj4R302WmGu116-2mg</a> 提取码: 1606</p><ul><li>安装完成后</li><li>同意调用系统相机权限</li><li>使用扫一扫对准汽车</li><li>稍后将会展示识别后的结果和识别的图片</li></ul><p>具体使用方式，可参见：<a href="https://www.bilibili.com/video/BV1Pk4y1B7qK" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Pk4y1B7qK</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;通过深度学习技术搭建残差网络，&lt;a href=&quot;http://mmlab.ie.cuhk.edu.hk/datasets/comp_cars/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;使用CompsCars数据集&lt;/a&gt; 进行车型识别模型的训练，并将训练好的模型移植到了Android端，实现了通过手机扫一扫的方式进行汽车车型识别的功能。&lt;/p&gt;
&lt;p&gt;项目涉及到的技术点较多，需要开发者有一定的技术功底。如：python语言的使用、深度学习框架pytorch的使用、爬虫脚本的理解、Java语言的使用、Android平台架构的理解等等。&lt;/p&gt;
&lt;p&gt;虽然属于跨语言开发，但是要求并不高，只要达到入门级别即可看懂本项目，并可以尝试一些定制化的改造。毕竟框架已经搭建好了，只需要修改数据源、重新训练出模型，就可以实现一款新的应用啦。&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="https://jelly54.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://jelly54.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="残差网络" scheme="https://jelly54.github.io/tags/%E6%AE%8B%E5%B7%AE%E7%BD%91%E7%BB%9C/"/>
    
      <category term="车型识别" scheme="https://jelly54.github.io/tags/%E8%BD%A6%E5%9E%8B%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>缓存数据库双写不一致问题</title>
    <link href="https://jelly54.github.io/cache-database-cons/"/>
    <id>https://jelly54.github.io/cache-database-cons/</id>
    <published>2020-02-01T12:13:54.000Z</published>
    <updated>2020-08-28T05:58:47.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h1><ol><li>读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应。</li><li>更新的时候先删除缓存，然后再更新数据库</li></ol><a id="more"></a><h2 id="为什么删除而不是更新缓存"><a href="#为什么删除而不是更新缓存" class="headerlink" title="为什么删除而不是更新缓存"></a>为什么删除而不是更新缓存</h2><p>原因很简单，很多时候，复杂点的缓存的场景，因为缓存有的时候，不简单是数据库中直接取出来的值。</p><p>如：商品详情页的系统，修改库存，只是修改了某个表的某些字段，但是要得到最终的库存，可能还需要从其他表查询一些数据，然后进行一些复杂的运算，才能最终计算出现在最新的库存是多少，然后才能将库存更新到缓存中去。</p><p>有很多数据并不是热数据，可能更新之后很久不会被访问，修改时更新缓存，反而增加了系统负荷。修改数据的时候，只删除缓存，不用每次都重新做复杂的计算，再下次使用它的时候再进行计算并缓存。</p><hr><h1 id="缓存数据库双写不一致？"><a href="#缓存数据库双写不一致？" class="headerlink" title="缓存数据库双写不一致？"></a>缓存数据库双写不一致？</h1><h2 id="初级的缓存不一致问题"><a href="#初级的缓存不一致问题" class="headerlink" title="初级的缓存不一致问题"></a>初级的缓存不一致问题</h2><p>先修改数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据出现不一致。</p><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p><strong>先删除缓存，再修改数据库</strong>。如果删除缓存成功了，如果修改数据库失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。</p><p>因为读的时候缓存没有，则读数据库中旧数据，然后更新到缓存中。</p><h2 id="较复杂的数据不一致问题"><a href="#较复杂的数据不一致问题" class="headerlink" title="较复杂的数据不一致问题"></a>较复杂的数据不一致问题</h2><p>数据发生变更，先删除了缓存，然后要去修改数据库，此时还没修改。</p><p>一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中，</p><p>数据变更的程序完成了数据库的修改</p><p>完了，数据库和缓存中的数据不一样了。。。。</p><h3 id="数据库与缓存更新与读取操作进行异步串行化"><a href="#数据库与缓存更新与读取操作进行异步串行化" class="headerlink" title="数据库与缓存更新与读取操作进行异步串行化"></a>数据库与缓存更新与读取操作进行异步串行化</h3><ul><li><p><strong>更新数据的时候</strong>，根据数据的唯一标识，将操作路由之后，<strong>发送到一个jvm内部的队列中</strong>。</p></li><li><p><strong>读取数据的时候</strong>，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，<strong>也发送同一个jvm内部的队列中</strong>。</p></li></ul><p><strong>一个队列对应一个工作线程</strong>，每个工作线程<strong>串行</strong>拿到对应的操作，然后一条一条的执行。</p><p>一个数据变更的操作，先执行，删除缓存，然后再去更新数据库，但是还没完成更新，此时如果一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。</p><p><strong>优化点</strong>：一个队列中，其实多个更新缓存请求串在一起是没意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。</p><p>待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。</p><p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回; <strong>如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值</strong>。</p><hr><h1 id="高并发的场景下，该解决方案要注意的问题"><a href="#高并发的场景下，该解决方案要注意的问题" class="headerlink" title="高并发的场景下，该解决方案要注意的问题"></a>高并发的场景下，该解决方案要注意的问题</h1><h2 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h2><p>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况</p><p>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p><h2 id="读请求长时阻塞"><a href="#读请求长时阻塞" class="headerlink" title="读请求长时阻塞"></a>读请求长时阻塞</h2><p>由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回</p><p>该解决方案，最大的风险点在于说，可能数据更新很频繁，导致队列中积压了大量更新操作在里面，然后读请求会发生大量的超时，最后导致大量的请求直接走数据库</p><p><strong>务必通过一些模拟真实的测试，看看更新数据的频繁是怎样的</strong></p><p>另外一点，因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，可能需要部署多个服务，每个服务分摊一些数据的更新操作</p><p>如果一个内存队列里居然会挤压100个商品的库存修改操作，每隔库存修改操作要耗费10ms区完成，那么最后一个商品的读请求，可能等待10 * 100 = 1000ms = 1s后，才能得到数据，这个时候就导致读请求的长时阻塞</p><p><strong>一定要做根据实际业务系统的运行情况，去进行一些压力测试，和模拟线上环境</strong>，去看看最繁忙的时候，内存队列可能会挤压多少更新操作，可能会导致最后一个更新操作对应的读请求，会hang多少时间，如果读请求在200ms返回，如果你计算过后，哪怕是最繁忙的时候，积压10个更新操作，最多等待200ms，那还可以的</p><p>如果一个内存队列可能积压的更新操作特别多，那么你就要加机器，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少</p><p>其实根据之前的项目经验，一般来说数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的</p><p>针对读高并发，读缓存架构的项目，一般写请求相对读来说，是非常非常少的，每秒的QPS能到几百就不错了</p><p>一秒，500的写操作，5份，每200ms，就有100个写操作</p><p>单机器，20个内存队列，每个内存队列，可能就积压5个写操作，每个写操作性能测试后，一般在20ms左右就完成</p><p>那么针对每个内存队列中的数据的读请求，也就最多hang一会儿，200ms以内肯定能返回了</p><p>写QPS扩大10倍，但是经过刚才的测算，就知道，单机支撑写QPS几百没问题，那么就扩容机器，扩容10倍的机器，10台机器，每个机器20个队列，200个队列</p><p>大部分的情况下，应该是这样的，大量的读请求过来，都是直接走缓存取到数据的</p><p>少量情况下，可能遇到读跟数据更新冲突的情况，如上所述，那么此时更新操作如果先入队列，之后可能会瞬间来了对这个数据大量的读请求，但是因为做了去重的优化，所以也就一个更新缓存的操作跟在它后面</p><p>等数据更新完了，读请求触发的缓存更新操作也完成，然后临时等待的读请求全部可以读到缓存中的数据</p><h2 id="读请求并发量过高"><a href="#读请求并发量过高" class="headerlink" title="读请求并发量过高"></a>读请求并发量过高</h2><p>这里还必须做好压力测试，确保恰巧碰上上述情况的时候，还有一个风险，就是突然间大量读请求会在几十毫秒的延时hang在服务上，看服务能不能抗的住，需要多少机器才能抗住最大的极限情况的峰值</p><p>但是因为并不是所有的数据都在同一时间更新，缓存也不会同一时间失效，所以每次可能也就是少数数据的缓存失效了，然后那些数据对应的读请求过来，并发量应该也不会特别大</p><p>按1:99的比例计算读和写的请求，每秒5万的读QPS，可能只有500次更新操作</p><p>如果一秒有500的写QPS，那么要测算好，可能写操作影响的数据有500条，这500条<strong>数据在缓存中失效后，可能导致多少读请求，发送读请求到库存服务来，要求更新缓存</strong></p><p>一般来说，1:1，1:2，1:3，每秒钟有1000个读请求，会hang在库存服务上，每个读请求最多hang多少时间，200ms就会返回</p><p>在同一时间最多hang住的可能也就是单机200个读请求，同时hang住</p><p>单机hang200个读请求，还是ok的</p><p>1:20，每秒更新500条数据，这500秒数据对应的读请求，会有20 * 500 = 1万</p><p>1万个读请求全部hang在库存服务上，就死定了</p><h2 id="多服务实例部署的请求路由"><a href="#多服务实例部署的请求路由" class="headerlink" title="多服务实例部署的请求路由"></a>多服务实例部署的请求路由</h2><p>可能这个服务部署了多个实例，那么必须保证说，执行数据更新操作，以及执行缓存更新操作的请求，<strong>都通过nginx服务器路由到相同的服务实例上</strong>(服务间按照某个请求参数的hash路由)</p><h2 id="热点商品的路由问题，导致请求的倾斜"><a href="#热点商品的路由问题，导致请求的倾斜" class="headerlink" title="热点商品的路由问题，导致请求的倾斜"></a>热点商品的路由问题，导致请求的倾斜</h2><p>万一某个商品的读写请求特别高，全部打到相同的机器的相同的队列里面去了，可能造成某台机器的压力过大</p><p>就是说，因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以更新频率不是太高的话，这个问题的影响并不是特别大</p><p>但是的确可能某些机器的负载会高一些</p><hr><h1 id="缓存雪崩发生的现象"><a href="#缓存雪崩发生的现象" class="headerlink" title="缓存雪崩发生的现象"></a>缓存雪崩发生的现象</h1><p><img src="https://s2.ax1x.com/2020/01/04/lwrA29.png" alt="lwrA29.png"></p><h2 id="缓存雪崩的事前事中事后的解决方案"><a href="#缓存雪崩的事前事中事后的解决方案" class="headerlink" title="缓存雪崩的事前事中事后的解决方案"></a>缓存雪崩的事前事中事后的解决方案</h2><ul><li>事前：redis高可用，主从+哨兵，redis cluster，避免全盘崩溃</li><li>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL被打死</li><li>事后：redis持久化，快速恢复缓存数据</li></ul><p><img src="https://s2.ax1x.com/2020/01/04/lwrEvR.png" alt="lwrEvR.png"></p><hr><h1 id="缓存穿透的现象"><a href="#缓存穿透的现象" class="headerlink" title="缓存穿透的现象"></a>缓存穿透的现象</h1><p><img src="https://s2.ax1x.com/2020/01/04/lwrmb6.png" alt="lwrmb6.png"></p><h2 id="缓存穿透的解决方法"><a href="#缓存穿透的解决方法" class="headerlink" title="缓存穿透的解决方法"></a>缓存穿透的解决方法</h2><p>每次系统a从数据库没有查到信息，就在缓存中存一个空值，这样下次就会走缓存而不是穿透到数据库。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Cache-Aside-Pattern&quot;&gt;&lt;a href=&quot;#Cache-Aside-Pattern&quot; class=&quot;headerlink&quot; title=&quot;Cache Aside Pattern&quot;&gt;&lt;/a&gt;Cache Aside Pattern&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应。&lt;/li&gt;
&lt;li&gt;更新的时候先删除缓存，然后再更新数据库&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Cache" scheme="https://jelly54.github.io/categories/Cache/"/>
    
    
      <category term="缓存" scheme="https://jelly54.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="一致性问题" scheme="https://jelly54.github.io/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    
      <category term="缓存穿透" scheme="https://jelly54.github.io/tags/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/"/>
    
      <category term="缓存雪崩" scheme="https://jelly54.github.io/tags/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/"/>
    
  </entry>
  
  <entry>
    <title>为什么要使用缓存</title>
    <link href="https://jelly54.github.io/cache-why-use/"/>
    <id>https://jelly54.github.io/cache-why-use/</id>
    <published>2020-02-01T10:13:17.000Z</published>
    <updated>2020-08-28T02:38:29.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要用缓存"><a href="#为什么要用缓存" class="headerlink" title="为什么要用缓存"></a>为什么要用缓存</h1><p>结合以下两点说自己的项目。</p><a id="more"></a><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><p><img src="https://s2.ax1x.com/2019/12/28/lmpSAS.png" alt="lmpSAS.png"></p><p>假设这么个场景，你有个操作，一个请求过来，吭哧吭哧你各种乱七八糟操作mysql，半天查出来一个结果，耗时600ms。但是这个结果可能接下来几个小时都不会变了，或者变了也可以不用立即反馈给用户。那么此时咋办？</p><p>缓存啊，折腾600ms查出来的结果，扔缓存里，一个key对应一个value，下次再有人查，别走mysql折腾600ms了。直接从缓存里，通过一个key查出来一个value，2ms搞定。性能提升300倍。</p><p>这就是所谓的高性能。</p><p>就是把你一些复杂操作耗时查出来的结果，如果确定后面不咋变了，然后但是马上还有很多读请求，那么直接结果放缓存，后面直接读缓存就好了。</p><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p><img src="https://s2.ax1x.com/2019/12/28/lmSx78.png" alt="lmSx78.png"></p><p>mysql这么重的数据库，压根儿设计不是让你玩儿高并发的，虽然也可以玩儿，但是天然支持不好。mysql单机支撑到2000qps也开始容易报警了。</p><p>所以要是你有个系统，高峰期一秒钟过来的请求有1万，那一个mysql单机绝对会死掉。你这个时候就只能上缓存，把很多数据放缓存，别放mysql。缓存功能简单，说白了就是key-value式操作，单机支撑的并发量轻松一秒几万十几万，支撑高并发so easy。单机承载并发量是mysql单机的几十倍。</p><hr><h1 id="缓存常见问题"><a href="#缓存常见问题" class="headerlink" title="缓存常见问题"></a>缓存常见问题</h1><p>1）缓存与数据库双写不一致<br>2）缓存雪崩<br>3）缓存穿透<br>4）缓存并发竞争</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么要用缓存&quot;&gt;&lt;a href=&quot;#为什么要用缓存&quot; class=&quot;headerlink&quot; title=&quot;为什么要用缓存&quot;&gt;&lt;/a&gt;为什么要用缓存&lt;/h1&gt;&lt;p&gt;结合以下两点说自己的项目。&lt;/p&gt;
    
    </summary>
    
      <category term="Cache" scheme="https://jelly54.github.io/categories/Cache/"/>
    
    
      <category term="缓存" scheme="https://jelly54.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>mysql主从复制</title>
    <link href="https://jelly54.github.io/mysql-master-slave/"/>
    <id>https://jelly54.github.io/mysql-master-slave/</id>
    <published>2020-01-29T07:16:21.000Z</published>
    <updated>2020-08-27T11:05:52.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>slave会从master读取binlog来进行数据同步</p><h2 id="三步骤"><a href="#三步骤" class="headerlink" title="三步骤"></a>三步骤</h2><p><img src="https://s2.ax1x.com/2019/12/22/QxgIlq.png" alt="QxgIlq.png"></p><ol><li>master将改变记录到二进制日志(binary log)。这些记录过程叫做二进制日志事件，binary log events;</li><li>slave将master的binary log events拷贝到它的中继日志(relay log);</li><li>slave重做中继日志中的事件，将改变应用到自己的数据库中。Mysql复制是异步的且串行化的</li></ol><a id="more"></a><h1 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h1><ol><li>每个slave只有一个master</li><li>每个slave只能有唯一的服务器ID</li><li>每个master可以有多个salve</li></ol><h1 id="最大问题"><a href="#最大问题" class="headerlink" title="最大问题"></a>最大问题</h1><p>延时</p><h1 id="一主已从常见配置"><a href="#一主已从常见配置" class="headerlink" title="一主已从常见配置"></a>一主已从常见配置</h1><p>mysql版本一致且后台以服务运行；<br>主从都配置在[mysqld]节点下，都是小写。</p><h2 id="主机配置文件"><a href="#主机配置文件" class="headerlink" title="主机配置文件"></a>主机配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 必须 服务器唯一ID</span><br><span class="line">server-id=1</span><br><span class="line"></span><br><span class="line"># 必须 启用二进制日志</span><br><span class="line"># 如：log-bin=D:/Mysql5.5/data/mysqlbin</span><br><span class="line">log-bin=自己的本地路径/mysqlbin</span><br><span class="line"></span><br><span class="line"># 可选 启用错误日志</span><br><span class="line"># 如：log-bin=D:/Mysql5.5/data/mysqlerr</span><br><span class="line">log-err=自己的本地路径/mysqlerr</span><br><span class="line"></span><br><span class="line"># 可选 根目录</span><br><span class="line">basedir=&quot;D:/Mysql5.5/&quot;</span><br><span class="line"></span><br><span class="line"># 可选 临时目录</span><br><span class="line">tmpdir=&quot;D:/Mysql5.5/&quot;</span><br><span class="line"></span><br><span class="line"># 可选 数据目录</span><br><span class="line">datadir=&quot;D:/Mysql5.5/data/&quot;</span><br><span class="line"></span><br><span class="line"># 设置读写权限(主机应是读写都可)</span><br><span class="line">read-only=0</span><br><span class="line"></span><br><span class="line"># 可选 设置不要复制的数据库</span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line"></span><br><span class="line"># 可选 设置需要复制的数据库</span><br><span class="line">binlog-do-db=需要复制的主数据库名字</span><br></pre></td></tr></table></figure><h2 id="从机配置文件"><a href="#从机配置文件" class="headerlink" title="从机配置文件"></a>从机配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 必须 从服务器唯一ID</span><br><span class="line"></span><br><span class="line"># 可选 启用二进制日志</span><br></pre></td></tr></table></figure><h2 id="主机授权从机访问"><a href="#主机授权从机访问" class="headerlink" title="主机授权从机访问"></a>主机授权从机访问</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 授权</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span> <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">TO</span> <span class="string">'username'</span>@<span class="string">'从库IP'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'password'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新权限</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询主机状态, 记录下File和Position的值</span></span><br><span class="line"><span class="comment"># 每次配置都需要记录新的File和Position的值。</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure><h2 id="从机设置访问账户"><a href="#从机设置访问账户" class="headerlink" title="从机设置访问账户"></a>从机设置访问账户</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置访问主机的账户、数据起始位置等</span></span><br><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> MASTER_HOST=<span class="string">'主机IP'</span>, MASTER_USER=<span class="string">'username'</span>, MASTER_PASSWORD=<span class="string">'password'</span>, MASTER_LOG_FILE=<span class="string">'mysqlbin.具体数字'</span>, MASTER_LOG_POS=具体数值;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启服务器复制功能</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询从机状态。以下两个参数都是Yes说明配置成功</span></span><br><span class="line"><span class="comment"># Slave_IO_Running:Yes</span></span><br><span class="line"><span class="comment"># Slave_SQL_Running:Yes</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span>\G</span><br></pre></td></tr></table></figure><h2 id="停止从机复制服务"><a href="#停止从机复制服务" class="headerlink" title="停止从机复制服务"></a>停止从机复制服务</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h1&gt;&lt;p&gt;slave会从master读取binlog来进行数据同步&lt;/p&gt;
&lt;h2 id=&quot;三步骤&quot;&gt;&lt;a href=&quot;#三步骤&quot; class=&quot;headerlink&quot; title=&quot;三步骤&quot;&gt;&lt;/a&gt;三步骤&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/12/22/QxgIlq.png&quot; alt=&quot;QxgIlq.png&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;master将改变记录到二进制日志(binary log)。这些记录过程叫做二进制日志事件，binary log events;&lt;/li&gt;
&lt;li&gt;slave将master的binary log events拷贝到它的中继日志(relay log);&lt;/li&gt;
&lt;li&gt;slave重做中继日志中的事件，将改变应用到自己的数据库中。Mysql复制是异步的且串行化的&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://jelly54.github.io/categories/Mysql/"/>
    
    
      <category term="mysql" scheme="https://jelly54.github.io/tags/mysql/"/>
    
      <category term="主从架构" scheme="https://jelly54.github.io/tags/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>mysql锁</title>
    <link href="https://jelly54.github.io/mysql-lock/"/>
    <id>https://jelly54.github.io/mysql-lock/</id>
    <published>2020-01-29T02:25:52.000Z</published>
    <updated>2020-08-27T11:05:52.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>锁是计算机协调多个进程或县城并发访问某一资源的机制。</p><p>在数据库中，除传统的计算资源(如CPU、RAM、I/O等)的争用之外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据并发访问性能的一个重要因素。从这个角度来说，锁对数据库显得尤为重要，也更复杂。</p><a id="more"></a><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="从数据的操作的类型-读-写-分"><a href="#从数据的操作的类型-读-写-分" class="headerlink" title="从数据的操作的类型(读/写)分"></a>从数据的操作的类型(读/写)分</h3><p>读锁(共享锁)：<br>针对同一份数据，多个读操作是可以同时进行而互相不影响。</p><p>写锁(排它锁)：<br>当前写操作没有完成前，它会阻断其他写锁和读锁。</p><h3 id="从数据的操作粒度分"><a href="#从数据的操作粒度分" class="headerlink" title="从数据的操作粒度分"></a>从数据的操作粒度分</h3><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁力度大，发生锁冲突的概率最高，并发度最低。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动加锁  </span></span><br><span class="line"><span class="keyword">lock</span> <span class="keyword">table</span> 表名字 <span class="keyword">read</span>(write), 表名字<span class="number">2</span>; read(write)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看表上加过的锁</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> <span class="keyword">tables</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放表锁</span></span><br><span class="line"><span class="keyword">unlock</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><p>session1 对A表加读锁。</p><p>session1 可以读A表，<strong>不能读别的表，不能写当前表。</strong></p><p>session2 可以读A表，可以读或写别的表。但是对A进行写时会一直阻塞，等待获取锁。</p><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。</p><p>InnoDB与MyISAM最大的不同点：  </p><ol><li>支持事务(TRANSACTION)  </li><li>采用了行级锁</li></ol><hr><h1 id="事务及其ACID属性"><a href="#事务及其ACID属性" class="headerlink" title="事务及其ACID属性"></a>事务及其ACID属性</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是由一组SQL语句组成的逻辑处理单元，事务具有以下四个属性，通常简称为事务的ACID属性。</p><p><strong>Atomicity(原子性)：</strong> 事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</p><p><strong>Consistent(一致性)：</strong> 在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完善性；事务结束时所有的内部数据结构(如B数索引或双向链表)也都必须是正确得。</p><p><strong>Isolation(隔离性)：</strong> 数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部都是不可见的，反之亦然。</p><p><strong>Durable(持久性)：</strong> 事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</p><h2 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h2><p><strong>更新丢失(Lost Update)</strong><br>当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会出现丢失问题–最后的更新覆盖了由其他事务所做的更新。</p><p><strong>脏读(Dirty Reads)</strong><br>一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取这条记录，如果不加控制，第二个事务读取了这些“脏数据”，并据此做进一步的处理，就会产生未提交的数据依赖关系。</p><p>事务A读取到事务B<strong>已经修改但尚未提交的数据</strong>，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。</p><p><strong>不可重复读(Non-Repeatable Reads)</strong><br>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变，或某些记录已经被删除。</p><p>事务A读取到了事务B已经提交的修改数据，不符合隔离性。</p><p><strong>幻读(Phantom Reads)</strong><br>一个事务按照相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据。</p><p>事务A读取到了事务B提交的新增的数据，不符合隔离性。</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><table><thead><tr><th>读数据一致性及允许的并发副作用隔离级别</th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读(Read uncommitted)</td><td>最低级别，只能保证不读取物理上被损坏的数据</td><td>是</td><td>是</td><td>是</td></tr><tr><td>已提交读(Read committed)</td><td>语句级</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读(Repeatable read)</td><td>事务级</td><td>否</td><td>否</td><td>是</td></tr><tr><td>可序列化(Serializable)</td><td>最高级别，事务级</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前数据库的事务隔离级别</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'tx_isolation;'</span></span><br></pre></td></tr></table></figure><p><strong>数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大</strong>。因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然于“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的。比如，许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。</p><hr><h1 id="索引失效行锁变表锁"><a href="#索引失效行锁变表锁" class="headerlink" title="索引失效行锁变表锁"></a>索引失效行锁变表锁</h1><h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但不存在的记录，叫做“间隙(GAP)”, InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁(Next-Key锁)。</p><p><strong>危害：</strong><br>因为Query执行过程中通过范围查找的话，他会索订整个范围内所有的索引键值，即使这个键值并不存在。间隙锁有一个比较致命的弱点，就是 <strong>当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入索订键值范围内的任何数据。</strong></p><h2 id="如何锁定一行"><a href="#如何锁定一行" class="headerlink" title="如何锁定一行"></a>如何锁定一行</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line"></span><br><span class="line"><span class="comment"># for update 锁定某一行之后，其他操作会被阻塞，直到锁定行的会话提交commit</span></span><br><span class="line">mysql&gt; select * from xx_table where a=8 for update;</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br></pre></td></tr></table></figure><h2 id="锁状态量分析"><a href="#锁状态量分析" class="headerlink" title="锁状态量分析"></a>锁状态量分析</h2><p>可通过检查INNODB_ROW+LOCK状态量来分析系统上的行锁的情况。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; show status like 'innodb_row_lock%;'</span><br><span class="line"></span><br><span class="line"><span class="comment"># 状态量说明</span></span><br><span class="line">innodb_row_lock_current_waits: 当前正在等待锁的数量</span><br><span class="line"></span><br><span class="line">innodb_row_lock_time:从系统启动到现在锁定 总时间长度。</span><br><span class="line"></span><br><span class="line">innodb_row_lock_time_avg: 每次等待所花平均时间，</span><br><span class="line"></span><br><span class="line">innodb_row_lock_time_max:从系统启动到现在等待这段时间</span><br><span class="line"></span><br><span class="line">innodb_row_lock_waits:系统启动后到现在总共等待的次数。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尤其是当等待次数很高，而且每次等待时间也不小的时候</span></span><br><span class="line"><span class="comment"># 我们就需要 **分析系统之中为什么会有如此多的等待，然后根据分析结果着手指定优化计划**。</span></span><br></pre></td></tr></table></figure><h2 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h2><ol><li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。</li><li>合理设计索引，尽量缩小锁的范围</li><li>尽可能较少检索条件，避免间隙锁。</li><li>尽量控制事务大小，减少锁定资源量和时间长度。</li><li>尽可能低级别事务隔离。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;锁是计算机协调多个进程或县城并发访问某一资源的机制。&lt;/p&gt;
&lt;p&gt;在数据库中，除传统的计算资源(如CPU、RAM、I/O等)的争用之外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据并发访问性能的一个重要因素。从这个角度来说，锁对数据库显得尤为重要，也更复杂。&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://jelly54.github.io/categories/Mysql/"/>
    
    
      <category term="锁" scheme="https://jelly54.github.io/tags/%E9%94%81/"/>
    
      <category term="mysql" scheme="https://jelly54.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql全局日志</title>
    <link href="https://jelly54.github.io/mysql-global-log/"/>
    <id>https://jelly54.github.io/mysql-global-log/</id>
    <published>2020-01-18T09:24:05.000Z</published>
    <updated>2020-08-27T11:05:52.288Z</updated>
    
    <content type="html"><![CDATA[<p><strong>永远不要再生产环境开启这个功能</strong></p><a id="more"></a><p>配置启用 my.cnf</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启</span></span><br><span class="line">general_log=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录日志文件的路径</span></span><br><span class="line">general_log_file=/path/logfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出格式</span></span><br><span class="line">log_output=FILE</span><br></pre></td></tr></table></figure><p>编码启用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启</span></span><br><span class="line">mysql&gt; set global general_log=1</span><br><span class="line"></span><br><span class="line">mysql&gt; set global log_output='TABLE';</span><br><span class="line"></span><br><span class="line"><span class="comment"># 之后所编写的sql语句，将会记录到mysql库里的general_log表，可以用以下命令查看</span></span><br><span class="line">mysql&gt; select * from mysql.general_log;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;永远不要再生产环境开启这个功能&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://jelly54.github.io/categories/Mysql/"/>
    
    
      <category term="mysql" scheme="https://jelly54.github.io/tags/mysql/"/>
    
      <category term="日志" scheme="https://jelly54.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>mysql show profile用法</title>
    <link href="https://jelly54.github.io/mysql-show-profile/"/>
    <id>https://jelly54.github.io/mysql-show-profile/</id>
    <published>2020-01-18T09:04:35.000Z</published>
    <updated>2020-08-28T02:43:07.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>show profile是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于sql调优的测量。</p><p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p><a id="more"></a><h1 id="分析步骤"><a href="#分析步骤" class="headerlink" title="分析步骤"></a>分析步骤</h1><h2 id="是否支持"><a href="#是否支持" class="headerlink" title="是否支持"></a>是否支持</h2><p>查看当前mysql版本是否支持</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'profiling'</span>;</span><br></pre></td></tr></table></figure><h2 id="开启功能"><a href="#开启功能" class="headerlink" title="开启功能"></a>开启功能</h2><p>默认是关闭的，使用前需要开启</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling = <span class="keyword">on</span>;</span><br></pre></td></tr></table></figure><h2 id="运行sql"><a href="#运行sql" class="headerlink" title="运行sql"></a>运行sql</h2><p>指生产环境或者测试的sql查询、更新等</p><h2 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;</span><br></pre></td></tr></table></figure><h2 id="诊断sql"><a href="#诊断sql" class="headerlink" title="诊断sql"></a>诊断sql</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x 为上一步中查询的id。</span></span><br><span class="line"><span class="keyword">show</span> profile cpu, <span class="keyword">block</span> io <span class="keyword">for</span> <span class="keyword">query</span> x; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选参数：</span></span><br><span class="line">all     <span class="comment">-- 显示所有的开销</span></span><br><span class="line">block io <span class="comment">-- 显示块IO相关开销</span></span><br><span class="line">context switches  <span class="comment">-- 上下文切换相关开销</span></span><br><span class="line">cpu     <span class="comment">-- 显示cpu相关开销信息</span></span><br><span class="line">ipc     <span class="comment">-- 显示发送和接受相关开销信息</span></span><br><span class="line">memory  <span class="comment">-- 显示内存相关开销信息</span></span><br><span class="line">page faults  <span class="comment">-- 显示页面错误相关开销信息</span></span><br><span class="line">source  <span class="comment">-- 显示和source_function, source_file, source_line相关的开销信息</span></span><br><span class="line">swaps   <span class="comment">-- 显示交换次数相关开销信息</span></span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查询结果太大，内存都不够用了，转向磁盘</span><br><span class="line">converting HEAP to MyISAM </span><br><span class="line"># 创建临时表(拷贝数据到临时表，用完再删除)</span><br><span class="line">creating tmp table </span><br><span class="line"></span><br><span class="line"># 把内存中临时表复制到磁盘，危险！</span><br><span class="line">copying to tmp table on disk</span><br><span class="line"></span><br><span class="line"># </span><br><span class="line">lock</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h1&gt;&lt;p&gt;show profile是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于sql调优的测量。&lt;/p&gt;
&lt;p&gt;默认情况下，参数处于关闭状态，并保存最近15次的运行结果&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://jelly54.github.io/categories/Mysql/"/>
    
    
      <category term="mysql" scheme="https://jelly54.github.io/tags/mysql/"/>
    
      <category term="mysql profile" scheme="https://jelly54.github.io/tags/mysql-profile/"/>
    
  </entry>
  
  <entry>
    <title>mysql-bulk</title>
    <link href="https://jelly54.github.io/mysql-bulk/"/>
    <id>https://jelly54.github.io/mysql-bulk/</id>
    <published>2020-01-18T08:24:35.000Z</published>
    <updated>2020-08-27T11:05:52.288Z</updated>
    
    <content type="html"><![CDATA[<p>函数：有返回值<br>存储过程：无返回值</p><p>sql: create table、create index、create function、create view</p><a id="more"></a><h2 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h2><blockquote><p>创建函数，如果报错: This<br> function has none of DETERMINISTIC…<br>由于开启过 慢查询日志，因为我们开启了bin-log，我们必须为我们的function指定一个参数</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'log_bin_trust_function_creators'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这样添加了参数以后，如果mysql重启，上述参数会消失，写入配置文件<strong>my.cnf</strong>，可以永久有效。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log_bin_trust_function_creators=1</span><br></pre></td></tr></table></figure><h2 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h2><p>创建一个产生随机字符串的函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> chars_str <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> return_str <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    WHILE i &lt; n DO</span><br><span class="line">    <span class="keyword">SET</span> return_str = <span class="keyword">CONCAT</span>(return_str, <span class="keyword">SUBSTRING</span>(chars_str, <span class="keyword">FLOOR</span>(<span class="number">1</span>+<span class="keyword">rand</span>()*<span class="number">52</span>),<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">SET</span> i = i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line">    RETURN return_str</span><br><span class="line"><span class="keyword">END</span> $$</span><br></pre></td></tr></table></figure><p>创建一个产生随机数的函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">CAEATE FUNCTION rand_num()</span><br><span class="line">RETURNS INT(5)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> i = <span class="keyword">FLOOR</span>(<span class="number">100</span>+<span class="keyword">RAND</span>()*<span class="number">10</span>);</span><br><span class="line">    RETURN i;</span><br><span class="line"><span class="keyword">END</span> $$</span><br></pre></td></tr></table></figure><p>删除函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> function_name;</span><br></pre></td></tr></table></figure><h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存储过程可以调用函数，如下面的INSERT 语句中调用 rand_string()、rand_num()函数。</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_emp (<span class="keyword">IN</span> strat <span class="built_in">INT</span>(<span class="number">10</span>), <span class="keyword">IN</span> max_num <span class="built_in">INT</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit = <span class="number">0</span>;</span><br><span class="line">    REPEAT</span><br><span class="line">    <span class="keyword">SET</span> i = i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> XXX (<span class="keyword">name</span>,age,<span class="keyword">no</span>) <span class="keyword">VALUES</span> (rand_string(<span class="number">6</span>),X,rand_num())</span><br><span class="line">    <span class="keyword">UNTIL</span> i = max_num</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> $$</span><br></pre></td></tr></table></figure><p>删除存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> procedure_name;</span><br></pre></td></tr></table></figure><h2 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h2><pre><code class="sql">DELIMITER ;<span class="keyword">CALL</span> insert_emp(<span class="number">100</span>, <span class="number">10</span>);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数：有返回值&lt;br&gt;存储过程：无返回值&lt;/p&gt;
&lt;p&gt;sql: create table、create index、create function、create view&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://jelly54.github.io/categories/Mysql/"/>
    
    
      <category term="mysql" scheme="https://jelly54.github.io/tags/mysql/"/>
    
      <category term="批量数据" scheme="https://jelly54.github.io/tags/%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>mysql慢查询</title>
    <link href="https://jelly54.github.io/mysql-slow-query/"/>
    <id>https://jelly54.github.io/mysql-slow-query/</id>
    <published>2020-01-18T06:08:33.000Z</published>
    <updated>2020-08-27T11:05:52.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="慢查询是什么"><a href="#慢查询是什么" class="headerlink" title="慢查询是什么"></a>慢查询是什么</h1><p>Mysql的慢查询日志是Mysql提供的一种日志记录，它用来记录在Mysql中响应时间超过阀值的语句。</p><p>具体指运行时间超过long_query_time值的sql，则会被记录到慢查询日志中。long_query_time默认是10s。</p><a id="more"></a><h1 id="如何玩"><a href="#如何玩" class="headerlink" title="如何玩"></a>如何玩</h1><p>默认情况下，Mysql数据库没有开启慢查询日志，需要我们手动来设置这个参数。</p><p>当然，如果不是调优需要的话，一般不建议启动该参数，因为慢查询日志会或多或少代来一些性能影响。慢查询日志支持将日志记录写入文件。</p><h2 id="查看当前是否开启"><a href="#查看当前是否开启" class="headerlink" title="查看当前是否开启"></a>查看当前是否开启</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE '%slow_query_log%';</span><br><span class="line"></span><br><span class="line">Variables_name      | Value</span><br><span class="line">slow_query_log      | OFF</span><br><span class="line">slow_query_log_file | /var/lib/mysql/slow.log</span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用以下语句只对当前数据库生效，mysql重启后则失效</span></span><br><span class="line"><span class="keyword">set</span> global_slow_query_log=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 永久生效，修改配置文件my.cnf(增加或修改以下两个字段)</span></span><br><span class="line"><span class="comment"># 如果没有指定 slow_query_log_file，系统默认host_name-slow.log</span></span><br><span class="line"><span class="comment"># 重启mysql服务。</span></span><br><span class="line">[mysqld]</span><br><span class="line">slow_query_log=1</span><br><span class="line">slow_query_log_file=/var/lib/mysql/slow.log</span><br></pre></td></tr></table></figure><h2 id="参数修改"><a href="#参数修改" class="headerlink" title="参数修改"></a>参数修改</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认查询时间超过这个参数的时间，就会被记录到慢查询日志中。默认为10s</span></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE 'long_query_time%';</span><br><span class="line"></span><br><span class="line">long_query_time | 10.000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过set 在当前数据库生效，mysql重启后失效。也可以在my.cnf中修改。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">注： 此时需要重新开一个会话才能看到修改的值。</span><br></pre></td></tr></table></figure><h2 id="模拟慢查询"><a href="#模拟慢查询" class="headerlink" title="模拟慢查询"></a>模拟慢查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模拟一个4s的查询sql</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sleep</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><hr><h1 id="日志分析工具"><a href="#日志分析工具" class="headerlink" title="日志分析工具"></a>日志分析工具</h1><h2 id="mysqldumpslow"><a href="#mysqldumpslow" class="headerlink" title="mysqldumpslow"></a>mysqldumpslow</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow --help</span><br><span class="line"></span><br><span class="line">-s: 是表示访问按照何种方式排序</span><br><span class="line">    c: 访问次数</span><br><span class="line">    l: 锁定时间</span><br><span class="line">    r: 返回记录数</span><br><span class="line">    t: 查询时间</span><br><span class="line"></span><br><span class="line">al: 平均锁定时间</span><br><span class="line">ar: 平均返回记录数</span><br><span class="line">at: 平均查询时间</span><br><span class="line"></span><br><span class="line">-t: 即为返回前边多少条的数据</span><br><span class="line">-g: 后边搭配一个正则匹配模式，大小写不敏感</span><br></pre></td></tr></table></figure><h2 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 得到返回记录集最多的10个SQL</span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/host_name-slow.log</span><br><span class="line"></span><br><span class="line"># 得到访问次数最多的10个SQL</span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/host_name-slow.log</span><br><span class="line"></span><br><span class="line"># 得到按照时间排序的前10条里边含有做链接的查询语句</span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/host_name-slow.log</span><br><span class="line"></span><br><span class="line"># 建议在使用这些命令时结合| 和 more 使用，否则可能出现爆屏</span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/host_name-slow.log | more</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;慢查询是什么&quot;&gt;&lt;a href=&quot;#慢查询是什么&quot; class=&quot;headerlink&quot; title=&quot;慢查询是什么&quot;&gt;&lt;/a&gt;慢查询是什么&lt;/h1&gt;&lt;p&gt;Mysql的慢查询日志是Mysql提供的一种日志记录，它用来记录在Mysql中响应时间超过阀值的语句。&lt;/p&gt;
&lt;p&gt;具体指运行时间超过long_query_time值的sql，则会被记录到慢查询日志中。long_query_time默认是10s。&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://jelly54.github.io/categories/Mysql/"/>
    
    
      <category term="mysql" scheme="https://jelly54.github.io/tags/mysql/"/>
    
      <category term="慢查询" scheme="https://jelly54.github.io/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title>mysql查询优化</title>
    <link href="https://jelly54.github.io/mysql-query-optimization/"/>
    <id>https://jelly54.github.io/mysql-query-optimization/</id>
    <published>2020-01-18T04:55:48.000Z</published>
    <updated>2020-08-28T05:56:45.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优化一般性流程"><a href="#优化一般性流程" class="headerlink" title="优化一般性流程"></a>优化一般性流程</h1><ol><li>观察。至少跑一天，看看生产的慢sql</li><li>开启慢查询日志，设置阙值，比如超过5s的就是慢sql，将它竹取出来</li><li>explain + 慢sql分析</li><li>show profile</li><li>运维经理 or DBA，进行数据库服务器的参数调优</li></ol><a id="more"></a><p>=== 总结</p><ol><li>慢查询的开启并捕获</li><li>expain + 慢SQL分析</li><li>show profile查询SQL在MySQL服务器里的执行细节和生命周期情况</li><li>SQL数据库服务器的参数调优</li></ol><hr><h1 id="小表驱动大表"><a href="#小表驱动大表" class="headerlink" title="小表驱动大表"></a>小表驱动大表</h1><h2 id="小的数据集驱动大的数据集"><a href="#小的数据集驱动大的数据集" class="headerlink" title="小的数据集驱动大的数据集"></a>小的数据集驱动大的数据集</h2><p>当B表的数据集小于A表的数据集时，用in 优于 exists。如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * FRON A <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> B);</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line">for <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> A.id = B.id</span><br></pre></td></tr></table></figure><p>当A表的数据集小于B表数据集时，用exist 优于 in。如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> B <span class="keyword">WHERE</span> B.id = A.id)</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">select</span> * <span class="keyword">from</span> A</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">select</span> * <span class="keyword">from</span> B <span class="keyword">where</span> B.id = A.id</span><br></pre></td></tr></table></figure><p>注：A表，B表ID字段应建立索引</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ol><li>EXISTS(subquery)只返回True 或 False，因此子查询中的SELECT * 也可以是SELECT 1 或 SELECT ‘x’, 官方说实际执行时会忽略select 清单，因此没有区别。</li><li>EXISTS 子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，如果担忧效率问题，可进行实际检验以确定是否有效率问题。</li><li>EXISTS子查询往往也可以用条件表达式、其他子查询或者JOIN来替代，何种最优需要具体问题具体分析</li></ol><hr><h1 id="Order-by-优化"><a href="#Order-by-优化" class="headerlink" title="Order by 优化"></a>Order by 优化</h1><h2 id="尽量使用index方式排序，避免使用FileSort方式排序"><a href="#尽量使用index方式排序，避免使用FileSort方式排序" class="headerlink" title="尽量使用index方式排序，避免使用FileSort方式排序"></a>尽量使用index方式排序，避免使用FileSort方式排序</h2><p>order by子句，尽量使用index方式排序，避免使用FileSort方式排序</p><p>Mysql支持两种方式的排序，FileSort和Index，Index效率高，它指Mysql扫描索引本身完成排序。FileSort方式效率低。</p><p>order by满足两种情况，会使用Index方式排序：<br>①order by 语句使用索引最左前列<br>②使用where子句与order by子句条件列组合满足索引最左前列。</p><h2 id="遵照索引建的最佳左前缀"><a href="#遵照索引建的最佳左前缀" class="headerlink" title="遵照索引建的最佳左前缀"></a>遵照索引建的最佳左前缀</h2><p>尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀</p><h2 id="filesort有两种算法"><a href="#filesort有两种算法" class="headerlink" title="filesort有两种算法"></a>filesort有两种算法</h2><p>如果不在索引列上，filesort有两种算法:mysql启动双路排序和单路排序。</p><h3 id="双路排序"><a href="#双路排序" class="headerlink" title="双路排序"></a>双路排序</h3><p>Mysql4.1 之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据。读取行指针和orderby列，对他们进行排序，然后扫描已经排好序的列表，按照列表中的值重新从列表中读取对应的数据输出。</p><p>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。</p><h3 id="单路排序"><a href="#单路排序" class="headerlink" title="单路排序"></a>单路排序</h3><p>从磁盘读取查询需要的<strong>所有列</strong>，按照orderby列<strong>在buffer对他们进行排序</strong>，然后扫描排序后的列表进行输出。他的效率更快一点，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间，因为他把每一行都保存在内存中了。</p><h3 id="结论及引申出的问题"><a href="#结论及引申出的问题" class="headerlink" title="结论及引申出的问题"></a>结论及引申出的问题</h3><ol><li>单路算法总体而言好过双路算法</li><li>单路算法中的问题。在sort_buffer中，方法B比方法A要占用更多空间，因为方法B是把所有字段都取出，所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序(创建tmp文件，多路合并)，排完再取sort_buffer容量大小，再排···从而所赐I/O。</li></ol><p>本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</p><h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h3><ul><li><p>增大sort_buffer_size参数的设置</p></li><li><p>增大max_length_for_sort_data参数的设置</p></li><li><p>why?  </p><ul><li><p>order by时select * 是一个大忌，应只查需要的字段，这点非常重要。这里会影响：  </p><ul><li>当query的字段大小总和小于max_length_for_sort_data而且排序字段不是TEXT||BLOB类型时，会用改进后的算法–单路排序，否则使用老算法-多路排序。  </li><li>两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次I/O，但是用单路排序算法的风险会更大一些，所以要提高sort_buffer_size。</li></ul></li><li><p>尝试提高sort_buffer_size<br>不管使用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的。</p></li><li><p>尝试提高 max_length_for_sort_data<br>提高这个参数，会增加使用改进算法的概率。但是吐过设的太高，数据总量超出sort_buffer_size的概率就增大，明显症状是 高的磁盘I/O活动 和 低的处理器使用率。</p></li></ul></li></ul><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>为排序使用索引<br>Mysql两种排序方式：文件排序或扫描优需索引排序<br>Mysql能为排序与查询使用相同的索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">KEY a_b_c (a, b, c)</span><br><span class="line"></span><br><span class="line"># order by 能使用索引 最左前缀</span><br><span class="line">- ORDER BY a</span><br><span class="line">- ORDER BY a, b</span><br><span class="line">- ORDER BY a, b, c</span><br><span class="line">- ORDER BY a DESC, b DESC, c DESC (a,b,c排序都一致可以用索引)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 如果where使用索引的最左前缀定义为常量，则order by能使用索引</span><br><span class="line">- WHERE a = const ORDER BY b, c</span><br><span class="line">- WHERE a = const AND b=const ORDER BY c</span><br><span class="line">- WHERE a = const ORDER BY b, c</span><br><span class="line">- WHERE a = const AND b &gt; const ORDER BY b, c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 不能使用索引进行排序</span><br><span class="line">- ORDER BY a ASC, b DESC , c DESC /*排序不一致*/</span><br><span class="line">- WHERE g = const ORDER BY b, c /*丢失a索引*/</span><br><span class="line">- WHERE a = const ORDER BY c /*丢失b索引*/</span><br><span class="line">- WHERE a = const ORDER BY a,d /*d不是索引的一部分*/</span><br><span class="line">- WHERE a in (···) ORDER BY b, c /*对于排序来说，多个相等条件也是范围查询*/</span><br></pre></td></tr></table></figure><hr><h1 id="Group-by-优化"><a href="#Group-by-优化" class="headerlink" title="Group by 优化"></a>Group by 优化</h1><p>group by 实质是先排序后进行分组，遵照索引建的最佳左前缀</p><p>当无法使用索引列，增大max_length_for_sort_data参数的设置 + 增大 sort_buffer_size参数的设置</p><p>where高于having，能写在where限定的条件就不要去having限定了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;优化一般性流程&quot;&gt;&lt;a href=&quot;#优化一般性流程&quot; class=&quot;headerlink&quot; title=&quot;优化一般性流程&quot;&gt;&lt;/a&gt;优化一般性流程&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;观察。至少跑一天，看看生产的慢sql&lt;/li&gt;
&lt;li&gt;开启慢查询日志，设置阙值，比如超过5s的就是慢sql，将它竹取出来&lt;/li&gt;
&lt;li&gt;explain + 慢sql分析&lt;/li&gt;
&lt;li&gt;show profile&lt;/li&gt;
&lt;li&gt;运维经理 or DBA，进行数据库服务器的参数调优&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://jelly54.github.io/categories/Mysql/"/>
    
    
      <category term="mysql" scheme="https://jelly54.github.io/tags/mysql/"/>
    
      <category term="SQL优化" scheme="https://jelly54.github.io/tags/SQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>mysql索引</title>
    <link href="https://jelly54.github.io/mysql-index/"/>
    <id>https://jelly54.github.io/mysql-index/</id>
    <published>2020-01-18T03:54:59.000Z</published>
    <updated>2020-08-27T11:05:52.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>索引是 <strong>一种特殊的文件</strong> (InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里 <strong>所有记录的引用指针。</strong> 更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。</p><a id="more"></a><p>索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。<strong>如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的</strong> 。除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，<strong>通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。</strong></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>在数据量和访问量不大的情况下，mysql访问是非常快的，是否加索引对访问影响不大。但是<strong>当数据量和访问量剧增的时候，</strong> 就会发现mysql变慢，甚至down掉，这就必须要考虑优化sql了，给数据库建立正确合理的索引，是mysql优化的一个重要手段。  </p><p>在创建索引时，需要考虑哪些列会用于 SQL 查询，然后为这些列创建一个或多个索引。事实上，<strong>索引也是一种表，保存着主键或索引字段，以及一个能将每个记录指向实际表的指针。数据库用户是看不到索引的，它们只是用来加速查询的。数据库搜索引擎使用索引来快速定位记录。</strong></p><p>INSERT 与 UPDATE 语句在拥有索引的表中执行会花费更多的时间，而SELECT 语句却会执行得更快。这是因为，<strong>在进行插入或更新时，数据库也需要插入或更新索引值。</strong></p><h2 id="Mysql索引结构"><a href="#Mysql索引结构" class="headerlink" title="Mysql索引结构"></a>Mysql索引结构</h2><ol><li>B-tree索引：</li><li>Hash索引：</li><li>Full-text全文索引：</li><li>R-Tree索引：</li></ol><hr><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="INDEX-单值索引"><a href="#INDEX-单值索引" class="headerlink" title="INDEX(单值索引)"></a>INDEX(单值索引)</h3><p>允许出现相同的索引内容，一个索引只包含单个列，一个表可以有多个单列索引。</p><h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p>实质上是将多个字段建到一个索引里，列值的组合必须唯一。</p><h3 id="UNIQUE-唯一索引"><a href="#UNIQUE-唯一索引" class="headerlink" title="UNIQUE(唯一索引)"></a>UNIQUE(唯一索引)</h3><p>索引列的值必须唯一，可以有NULL值，NULL可以出现多次。</p><h3 id="PRIMARY-KEY-主键索引"><a href="#PRIMARY-KEY-主键索引" class="headerlink" title="PRIMARY  KEY(主键索引)"></a>PRIMARY  KEY(主键索引)</h3><p>不允许出现相同的值，不为NULL。</p><h3 id="FULLTEXT-INDEX-全文索引"><a href="#FULLTEXT-INDEX-全文索引" class="headerlink" title="FULLTEXT INDEX(全文索引)"></a>FULLTEXT INDEX(全文索引)</h3><p>可以针对值中的某个单词，但效率不高。</p><h2 id="创建-删除-查看"><a href="#创建-删除-查看" class="headerlink" title="创建-删除-查看"></a>创建-删除-查看</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 </span></span><br><span class="line"><span class="keyword">CREATE</span>  [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> indexName <span class="keyword">ON</span> mytable(columnname(<span class="keyword">length</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> mytable <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> [indexName] <span class="keyword">ON</span> (columnname(<span class="keyword">length</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除 </span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> [indexName] <span class="keyword">ON</span> mytable;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看 </span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="使用ALTER-TABLE语句创建索性"><a href="#使用ALTER-TABLE语句创建索性" class="headerlink" title="使用ALTER TABLE语句创建索性"></a>使用ALTER TABLE语句创建索性</h3><p>应用于表创建完毕之后再添加。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 索引类型 （<span class="keyword">unique</span>,primary <span class="keyword">key</span>,fulltext,<span class="keyword">index</span>）[索引名]（字段名）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name (column_list) ;</span><br><span class="line"><span class="comment"># 复合索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name_name (column_list1,column_list2); </span><br><span class="line"><span class="comment"># 唯一索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (column_list) ;</span><br><span class="line"><span class="comment"># 主键索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span> (column_list) ;</span><br><span class="line"><span class="comment"># 全文索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> FULLTEXT index_name(column_list):</span><br></pre></td></tr></table></figure><p>ALTER TABLE可用于索引，<strong>table_name</strong> 是要增加索引的表名，<strong>column_list</strong> 指出对哪些列进行索引，多列时各列之间用 <strong>逗号分隔</strong>。索引名index_name可选，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以同时创建多个索引。</p><h3 id="使用CREATE-INDEX语句对表增加索引"><a href="#使用CREATE-INDEX语句对表增加索引" class="headerlink" title="使用CREATE INDEX语句对表增加索引"></a>使用CREATE INDEX语句对表增加索引</h3><p>CREATE INDEX可用于对表增加普通索引或UNIQUE索引，可用于建表时创建索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name(username(<span class="keyword">length</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment"># 单值索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name (column_list)</span><br><span class="line"><span class="comment"># 唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name (column_list)</span><br></pre></td></tr></table></figure><p><strong>table_name、index_name</strong> 和 <strong>column_list</strong> 具有与ALTER TABLE语句中相同的含义，索引名不可选。另外，<strong>不能用CREATE INDEX语句创建PRIMARY KEY索引。</strong> 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB(binary large object) 和TEXT类型，必须指定 length。</p><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>删除索引可以使用<strong>ALTER TABLE</strong> 或 <strong>DROP INDEX</strong>语句来实现。DROP INDEX可以在ALTER TABLE内部作为一条语句处理，其格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span> ;</span><br></pre></td></tr></table></figure><p>其中，在前面的两条语句中，都删除了table_name中的索引index_name。而在最后一条语句中，只在删除PRIMARY KEY索引中使用，因为一个表只可能有一个PRIMARY KEY索引，因此不需要指定索引名。如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。</p><p><strong>如果从表中删除某列，则索引会受影响。</strong> 对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。</p><p>–</p><h1 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h1><h2 id="组合索引-amp-左前缀原则"><a href="#组合索引-amp-左前缀原则" class="headerlink" title="组合索引&amp;左前缀原则"></a>组合索引&amp;左前缀原则</h2><p>组合索引和前缀索引是对建立索引技巧的一种称呼，并不是索引的类型</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> user_demo <span class="keyword">ADD</span> <span class="keyword">INDEX</span> name_city_age (login_name(<span class="number">16</span>),city,age);</span><br></pre></td></tr></table></figure><p>建表时，login_name 长度为100，这里用16(前16位有很好的区分度)，<strong>这样会加快索引查询速度，还会减少索引文件的大小，提高INSERT，UPDATE的更新速度。</strong></p><p>建立这样的组合索引，就相当于分别建立如下三种组合索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">login_name,city,age</span><br><span class="line">login_name,city</span><br><span class="line">login_name</span><br></pre></td></tr></table></figure><p>为什么没有city, age等这样的组合索引呢？这是因为 <strong>mysql组合索引“最左前缀”</strong> 的结果。简单的理解就是只从最左边的开始组合，并不是只要包含这三列的查询都会用到该组合索引。也就是说name_city_age(LOGIN_NAME(16),CITY,AGE) <strong>从左到右进行索引，如果没有左前索引，mysql不会执行索引查询。</strong></p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>如果索引列长度过长,这种列索引时将会产生很大的索引文件,不便于操作,可以使用前缀索引方式进行索引，<strong>前缀索引应该控制在一个合适的点,控制在0.31黄金值即可(大于这个值就可以创建)。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个值大于0.31就可以创建前缀索引,Distinct去重复</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span>(<span class="keyword">LEFT</span>(<span class="string">`title`</span>,<span class="number">10</span>))) / <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> pages; <span class="comment">--</span></span><br></pre></td></tr></table></figure><h2 id="索引分析"><a href="#索引分析" class="headerlink" title="索引分析"></a>索引分析</h2><h3 id="单表索引"><a href="#单表索引" class="headerlink" title="单表索引"></a>单表索引</h3><ol><li>索引index1:(a,b,c)，只会走a、a,b、a,b,c 三种类型的查询。</li><li>其实 a,c也走，但是只走a字段索引，不会走c字段。</li><li>同时，<strong><em>SELECT * FROM table WHERE a = ‘1’ AND b &gt; ‘2’ AND c=’3’;</em></strong>  这种类型的也只会有a与b走索引，<strong>c不会走。</strong></li><li>尽量使用等值查询，减少范围查询，能最大程度避免索引失效。</li></ol><p><strong>原因如下：</strong></p><p>索引是有序的，index1索引在索引文件中的排列是有序的，首先根据a来排序，然后才是根据b来排序，最后是根据c来排序，</p><p>像 <em>select * from table where a = ‘1’ and b &gt; ‘2’ and c=’3’;</em> 这种类型的sql语句，在a走完索引后，b使用索引进行范围查找，<strong>c肯定是无序了</strong>，所以c就没法走索引，数据库会觉得还不如全表扫描c字段来的快。</p><blockquote><p>如果分别给login_name, city, age 建立单列索引，<strong>让该表有3个单列索引，查询时和组合索引的效率是大不一样的，甚至远远低于组合索引。</strong> 虽然此时有三个索引，但mysql只能用到其中的那个它认为似乎是最有效率的单列索引，另外两个是用不到的，也就是说还是一个全表扫描的过程。  </p></blockquote><h3 id="两表索引"><a href="#两表索引" class="headerlink" title="两表索引"></a>两表索引</h3><p>LEFT JOIN 索引加右表。<br>RIGHT JOIN 索引加在左表。</p><blockquote><p>做链接用于确定如何从右表进行搜索，左边数据一定都会有，所以右表是检索的关键，要加索引。若左表加索引，右表没有则会出现两次全表扫描。</p></blockquote><h3 id="三表索引"><a href="#三表索引" class="headerlink" title="三表索引"></a>三表索引</h3><p>JOIN 语句优化</p><ol><li>尽可能减少join语句中的NestedLoop的循环总次数：永远使用小结果集驱动大结果集。</li><li>优先优化NestedLoop的内层循环。</li><li>保证join语句中被驱动表上join条件字段已经被索引。</li><li>当无法保证被驱动表的join条件字段被索引且内存资源充足的前提下，不要太吝啬JoinBuffer的设置。</li></ol><h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><ol><li><p>全值匹配</p></li><li><p>最佳左前缀法则</p></li><li><p>不在索引列上做任何操作<br>计算、函数、(自动或手动)类型转换，会导致索引失效，进而导致全表扫描</p></li><li><p>索引在 范围查询后会失效。</p></li><li><p>尽量使用覆盖索引</p></li><li><p>mysql在使用(!=, &lt;&gt;)的时候无法使用索引，会导致全表扫描。</p></li><li><p>is null，is not null 无法使用索引。<br>is null 会从另外的记录中读取，is not null将会进行全表扫描。</p></li><li><p>like 以通配符开头(%abc) mysql 索引将会变成全表扫描。</p></li></ol><p><strong>两边都是%的like查询，应使用覆盖索引。即在查询的字段列表中(select xxx from···)只是用索引中的字段。将会使用index 索引。</strong></p><ol start="9"><li><p>字符串不加单引号索引失效。会导致自动的类型转换。</p></li><li><p>少用 or，用它来连接时会索引失效。 </p></li></ol><h2 id="BAD-SQL"><a href="#BAD-SQL" class="headerlink" title="BAD SQL"></a>BAD SQL</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -- 正则表达式不使用索引,这应该很好理解</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不会使用索引,因为所有索引列参与了计算</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">`sname`</span> <span class="keyword">FROM</span> <span class="string">`stu`</span> <span class="keyword">WHERE</span> <span class="string">`age`</span>+<span class="number">10</span>=<span class="number">30</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 不会使用索引,因为使用了函数运算,原理与上面相同</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">`sname`</span> <span class="keyword">FROM</span> <span class="string">`stu`</span> <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(<span class="string">`date`</span>,<span class="number">4</span>) &lt;<span class="number">1990</span>;   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 走索引</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`houdunwang`</span> <span class="keyword">WHERE</span> <span class="string">`uname`</span> <span class="keyword">LIKE</span><span class="string">'后盾%'</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 不走索引</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`houdunwang`</span> <span class="keyword">WHERE</span> <span class="string">`uname`</span> <span class="keyword">LIKE</span> <span class="string">"%后盾%"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- 字符串与数字比较不使用索引;</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`a`</span> (<span class="string">`a`</span> <span class="built_in">char</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment"># 走索引</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`a`</span> <span class="keyword">WHERE</span> <span class="string">`a`</span>=<span class="string">"1"</span>;</span><br><span class="line"><span class="comment"># 不走索引</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`a`</span> <span class="keyword">WHERE</span> <span class="string">`a`</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- 如果条件中有or,即使其中有条件带索引也不会使用。</span></span><br><span class="line"><span class="comment"># 换言之,就是要求使用的所有字段,都必须建立索引, 我们建议大家尽量避免使用or 关键字</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> dname=<span class="string">'xxx'</span> <span class="keyword">or</span> loc=<span class="string">'xx'</span> <span class="keyword">or</span> deptno=<span class="number">45</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- 如果mysql估计使用全表扫描要比使用索引快,则不使用索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># index(a1, a2, a3, a4)</span></span><br><span class="line"><span class="comment"># 使用了索引，a3作用在排序而不是查找</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_table <span class="keyword">where</span> a1=<span class="string">'a1'</span> <span class="keyword">and</span> a2=<span class="string">'a2'</span> <span class="keyword">and</span> a4=<span class="string">'a4'</span> <span class="keyword">order</span> <span class="keyword">by</span> a3;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用到索引，但是由于a3没有出现，出现了a4，将出现filesort。</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_table <span class="keyword">where</span> a1=<span class="string">'a1'</span> <span class="keyword">and</span> a2=<span class="string">'a2'</span> <span class="keyword">order</span> <span class="keyword">by</span> a4;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只使用了a1一个字段索引，但是a2, a3用于排序，无filesort。</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_table <span class="keyword">where</span> a1=<span class="string">'a1'</span> <span class="keyword">and</span> a5=<span class="string">'a5'</span> <span class="keyword">order</span> <span class="keyword">by</span> a2, a3;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出现filesort，索引为1，2，3，4 但是order by 没有按顺序。</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_table <span class="keyword">where</span> a1=<span class="string">'a1'</span> <span class="keyword">and</span> a5=<span class="string">'a5'</span> <span class="keyword">order</span> <span class="keyword">by</span> a3, a2;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然order by顺序错误，但是前边已经定义a2，即a2已经是常量了，排序不关心，不会产生filesort。</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_table <span class="keyword">where</span> a1=<span class="string">'a1'</span> <span class="keyword">and</span> a2=<span class="string">'a2'</span> <span class="keyword">order</span> <span class="keyword">by</span> a3, a2;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出现filesort，temporary，where 很惨。</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_table <span class="keyword">where</span> a1=<span class="string">'a1'</span> <span class="keyword">and</span> a4=<span class="string">'a4'</span> <span class="keyword">group</span> <span class="keyword">by</span> a3,a2;</span><br></pre></td></tr></table></figure><p>定值、范围还是排序，一般order by是给个范围</p><p>group by基本上都是需要进行排序，会有临时表产生</p><hr><h1 id="一般性建议"><a href="#一般性建议" class="headerlink" title="一般性建议"></a>一般性建议</h1><h2 id="什么时候需要建立索引"><a href="#什么时候需要建立索引" class="headerlink" title="什么时候需要建立索引"></a>什么时候需要建立索引</h2><ol><li>主键自动建立唯一索引。</li><li>频繁作为查询条件的字段应该创建索引。</li><li>查询中与其他表关联的字段，外键关系建立索引。</li><li>单键/组合索引的选择。选择组合索引。（高并发倾向于组合索引）</li><li>Where条件里用不到的字段不创建索引</li><li>查询中统计或者分组的字段要创建索引</li><li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。</li></ol><h2 id="什么时候不建议建立索引"><a href="#什么时候不建议建立索引" class="headerlink" title="什么时候不建议建立索引"></a>什么时候不建议建立索引</h2><ol><li>表记录太少。（三百万以下）</li><li>经常增删改的表。提高了查询速度，但是会降低更新表的速度，更新表的时候，不仅要保存数据，还要保存索引。</li><li>数据重复且分布平均的表字段。</li></ol><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ol><li>索引不会包含有NULL的列</li></ol><p><strong>只要列中包含有NULL值，都将不会被包含在索引中</strong>，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的。</p><ol start="2"><li>索引列排序</li></ol><p><strong>mysql查询只使用一个索引</strong>，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引。</p><ol start="3"><li>like语句操作</li></ol><p>一般情况下不鼓励使用like操作，如果非使用不可，注意正确的使用方式。like ‘%aaa%’不会使用索引，而like ‘aaa%’可以使用索引。</p><ol start="4"><li><p>不要在列上进行运算</p></li><li><p>不使用NOT IN 、&lt;&gt;、！=操作，但 <strong>&lt;,&lt;=，=，&gt;,&gt;=,BETWEEN,IN是可以用到索引的.</strong></p></li><li><p>在where和join中出现的列需要建立索引。</p></li><li><p>如果where字句的查询条件里使用了函数(如：where DAY(column)=…),mysql将无法使用索引。</p></li><li><p>在join操作中(需要从多个数据表提取数据时)，mysql只有在 <strong>主键和外键的数据类型相同时</strong> 才能使用索引，否则及时建立了索引也不会使用。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;索引是 &lt;strong&gt;一种特殊的文件&lt;/strong&gt; (InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里 &lt;strong&gt;所有记录的引用指针。&lt;/strong&gt; 更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://jelly54.github.io/categories/Mysql/"/>
    
    
      <category term="mysql" scheme="https://jelly54.github.io/tags/mysql/"/>
    
      <category term="索引" scheme="https://jelly54.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql为什么使用B+树</title>
    <link href="https://jelly54.github.io/mysql-b-tree/"/>
    <id>https://jelly54.github.io/mysql-b-tree/</id>
    <published>2020-01-11T11:16:21.000Z</published>
    <updated>2020-08-28T02:47:58.675Z</updated>
    
    <content type="html"><![CDATA[<p>探讨一下mysql底层的数据结构，是b+树，还是b树。</p><a id="more"></a><h1 id="两种树形结构"><a href="#两种树形结构" class="headerlink" title="两种树形结构"></a>两种树形结构</h1><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为null<br><a href="https://imgchr.com/i/VyqBZ9" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/10/VyqBZ9.png" alt="VyqBZ9.png"></a></p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>只有叶子节点存储data，叶子节点包含了这棵树的所有键值，叶子节点不存储指针。</p><p><a href="https://imgchr.com/i/VyqwqJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/10/VyqwqJ.png" alt="VyqwqJ.png"></a></p><p>后来，在<strong>B+树上增加了顺序访问指针，也就是每个叶子节点增加一个指向相邻叶子节点的指针</strong> ，这样一棵树成了数据库系统实现索引的首选数据结构。</p><p>原因有很多，<strong>最主要的是这棵树矮胖</strong> ，呵呵。一般来说，索引很大，往往以索引文件的形式存储的磁盘上，索引查找时产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的时间复杂度。树高度越小，I/O次数越少。</p><p>那为什么是B+树而不是B树呢，因为它内节点不存储data，这样一个节点就可以存储更多的key。</p><p>在MySQL中，最常用的两个存储引擎是<strong>MyISAM</strong> 和<strong>InnoDB</strong> ，它们对索引的实现方式是不同的。</p><hr><h1 id="Mysql存储引擎"><a href="#Mysql存储引擎" class="headerlink" title="Mysql存储引擎"></a>Mysql存储引擎</h1><h2 id="MyISA"><a href="#MyISA" class="headerlink" title="MyISA"></a>MyISA</h2><p>data存的是数据地址。索引是索引，数据是数据。索引放在XX.MYI文件中，数据放在XX.MYD文件中，所以也叫非聚集索引。<br><a href="https://imgchr.com/i/Vyqdr4" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/10/Vyqdr4.png" alt="Vyqdr4.png"></a></p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>data存的是数据本身。索引也是数据。数据和索引存在一个XX.IDB文件中，所以也叫聚集索引。<br><a href="https://imgchr.com/i/VyqaMF" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/10/VyqaMF.png" alt="VyqaMF.png"></a></p><h2 id="两种引擎区别"><a href="#两种引擎区别" class="headerlink" title="两种引擎区别"></a>两种引擎区别</h2><p>了解了数据结构再看索引，一切都不费解了，只是顺着逻辑推而已。另加两种存储引擎的区别：</p><ol><li><p>MyISAM是非事务安全的，而InnoDB是事务安全的</p></li><li><p>MyISAM锁的粒度是表级的，而InnoDB支持行级锁</p></li><li><p>MyISAM支持全文类型索引，而InnoDB不支持全文索引</p></li><li><p>MyISAM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyISAM</p></li><li><p>MyISAM表保存成文件形式，跨平台使用更加方便</p></li><li><p>MyISAM管理非事务表，提供高速存储和检索以及全文搜索能力，如果在应用中执行大量select操作可选择</p></li><li><p>InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，可选择。</p></li></ol><hr><h1 id="为什么mysql用B-树做索引而不用B-树或红黑树"><a href="#为什么mysql用B-树做索引而不用B-树或红黑树" class="headerlink" title="为什么mysql用B+树做索引而不用B-树或红黑树"></a>为什么mysql用B+树做索引而不用B-树或红黑树</h1><p>B-树、B+树、红黑树，都是平衡查找树，那么查询效率上讲，平均都是O(logn)。使用什么哪种数据结构，肯定是出于提高数据库的查询效率的考虑。</p><h2 id="B-树做索引而不用B-树"><a href="#B-树做索引而不用B-树" class="headerlink" title="B+树做索引而不用B-树"></a>B+树做索引而不用B-树</h2><p>Mysql如何衡量查询效率呢？<br><strong>磁盘IO次数。</strong></p><p>一般来说索引非常大，尤其是关系性数据库这种数据量大的索引能达到亿级别，所以为了减少内存的占用，索引也会被存储在磁盘上。</p><ul><li><p>B-树/B+树 的特点就是<strong>每层节点数目非常多，层数很少</strong>，目的就是为了减少磁盘IO次数，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（<strong>磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时</strong>），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。</p></li><li><p>B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。</p></li><li><p>B+树所有的Data域在叶子节点，并且所有叶子节点之间都有一个链指针。 这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。在数据库中基于范围的查询是非常频繁的，而B树不支持这样的遍历操作。</p></li></ul><h2 id="B-树做索引而不用红黑树"><a href="#B-树做索引而不用红黑树" class="headerlink" title="B+树做索引而不用红黑树"></a>B+树做索引而不用红黑树</h2><ul><li><p>AVL 树（平衡二叉树）和红黑树（二叉查找树）基本都是存储在内存中才会使用的数据结构。</p></li><li><p>在大规模数据存储的时候，红黑树往往出现<strong>由于树的深度过大而造成磁盘IO读写过于频繁</strong>，进而导致效率低下的情况。</p></li></ul><p>为什么会出现这样的情况，我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。</p><p><strong>根据磁盘查找存取的次数往往由树的高度所决定</strong>，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树可以有多个子女，从几十到上千，可以降低树的高度。</p><p>数据库系统的设计者<strong>巧妙利用了磁盘预读原理</strong>，将<strong>一个节点的大小设为等于一个页</strong>，这样每个节点只需要一次I/O就可以完全载入。</p><p>为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：<strong>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里</strong>，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;探讨一下mysql底层的数据结构，是b+树，还是b树。&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://jelly54.github.io/categories/Mysql/"/>
    
    
      <category term="mysql" scheme="https://jelly54.github.io/tags/mysql/"/>
    
      <category term="数据结构" scheme="https://jelly54.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>mysql使用手册</title>
    <link href="https://jelly54.github.io/mysql-handbook/"/>
    <id>https://jelly54.github.io/mysql-handbook/</id>
    <published>2020-01-11T10:53:14.000Z</published>
    <updated>2020-08-27T11:05:52.288Z</updated>
    
    <content type="html"><![CDATA[<p>手把手叫会零基础的你使用mysql。</p><a id="more"></a><h1 id="登录MySql"><a href="#登录MySql" class="headerlink" title="登录MySql"></a>登录MySql</h1><p>windows环境进入cmd后，输入: <em>mysql –h localhost –u username –p</em> 再输入密码就可以启动mysql</p><p>linux 进入terminal后直接输入: <em>mysql  –h localhost -u username -p</em><br>随后根据提示输入密码。</p><p>其中<strong>localhost</strong>是mysql服务器所在的ip，如果是本机可以省略<em>-h localhost</em> 或用localhost； <strong>username</strong>是登录mysql的用户名。 </p><hr><h1 id="数据库-DATABASE-相关操作"><a href="#数据库-DATABASE-相关操作" class="headerlink" title="数据库(DATABASE)相关操作"></a>数据库(DATABASE)相关操作</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建名为db_name的数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db_name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看已经存在的数据库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">DATABASES</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除名为db_name的数据库</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> db_name; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 操作名为db_name的数据库</span></span><br><span class="line"><span class="keyword">USE</span> db_name; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示数据库中的表</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看表名为table_name的表的结构</span></span><br><span class="line">DESC table_name;</span><br></pre></td></tr></table></figure><hr><h1 id="数据库中表-TABLE-的操作"><a href="#数据库中表-TABLE-的操作" class="headerlink" title="数据库中表(TABLE)的操作"></a>数据库中表(TABLE)的操作</h1><h2 id="查看表的详细结构语句"><a href="#查看表的详细结构语句" class="headerlink" title="查看表的详细结构语句"></a>查看表的详细结构语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure><h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表且设置了ID为主键 </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line"> <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>),</span><br><span class="line"> age <span class="built_in">int</span> ,</span><br><span class="line"> sex <span class="built_in">varchar</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置了表中stu_id和course_id两个都为主键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">(stu_id <span class="built_in">int</span>, </span><br><span class="line"> course_id <span class="built_in">int</span>,</span><br><span class="line"> <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line"> grade <span class="built_in">float</span>,</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span>(stu_id,course_id));</span><br></pre></td></tr></table></figure><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>如果表A的某一个属性值依赖于表B的主键，则称B为父表，A为子表，A中的这个字段为A的外键，如果父表中的信息改变，则对应子表的数据也会改变 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- table_name02是父表，table_name01是子表，给子表设置了两个外键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name01</span><br><span class="line">(<span class="keyword">id</span> <span class="built_in">int</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line"> stu_id <span class="built_in">int</span>,</span><br><span class="line"> course_id <span class="built_in">int</span> ,</span><br><span class="line"> score <span class="built_in">float</span>,</span><br><span class="line"> grade <span class="built_in">int</span>,</span><br><span class="line"> <span class="keyword">CONSTRAINT</span> c_fk(外键别名) <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(stu_id,course_id)</span><br><span class="line"> <span class="keyword">REFERENCES</span> table_name02(stu_id,course_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><h4 id="表字段的非空约束"><a href="#表字段的非空约束" class="headerlink" title="表字段的非空约束"></a>表字段的非空约束</h4><p>指字段中值不能为null</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置not null表示字段不能为空，也就是非空</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"> <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"> stu_id <span class="built_in">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h4><p>指字段中值不能重复</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 其中设置了主键id，且自动增加，且unique设置了stu_id的值必须唯一性，不能有相同的值存在</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line"> stu_id <span class="built_in">int</span> <span class="keyword">unique</span>,</span><br><span class="line"> <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- default 为表设置默认值，即在没有插入数据的时候会用默认值代替; </span></span><br><span class="line"><span class="comment">-- 即为Englist字段设置了默认值为zero;</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line"> stu_id <span class="built_in">int</span> <span class="keyword">unique</span>,</span><br><span class="line"> <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"> english <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="string">'zero'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h1 id="表的修改操作"><a href="#表的修改操作" class="headerlink" title="表的修改操作"></a>表的修改操作</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改表名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> old_table_name <span class="keyword">RENAME</span> [<span class="keyword">to</span>] new_table_name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改字段属性</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">MODIFY</span> 属性名 数据类型(修改后的类型);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改字段</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">CHANGE</span> 旧字段名 新字段名 新数据类型;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增加字段</span></span><br><span class="line"><span class="comment">-- 在字段2后面增加字段1;如果把字段2改成 FIRST即加在最前面</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> 数据类型 <span class="keyword">AFTER</span> 字段<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除字段</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">drop</span> 字段名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改字段的位置</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">MODIFY</span> 字段名 <span class="keyword">FIRST</span>(第一个位置，<span class="keyword">AFTER</span> 字段，指定字段的后面);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更改表的引擎名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">engine</span>=Mylsam; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表的外键约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>  外键别名; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表 --</span></span><br><span class="line">　　</span><br><span class="line"><span class="comment">--普通的没有关联的表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table_name; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除有关联的表</span></span><br><span class="line"><span class="comment">-- 先查看表的详情，看到外键的另名,</span></span><br><span class="line"><span class="comment">-- 先删除外键，再删除表格就可以了。 </span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure><hr><h1 id="数据库的增删改查操作"><a href="#数据库的增删改查操作" class="headerlink" title="数据库的增删改查操作"></a>数据库的增删改查操作</h1><p>数据库的增(insert into)删(delete)改(update)查(select)操作： 　　</p><h2 id="添加数据-INSERT-INTO"><a href="#添加数据-INSERT-INTO" class="headerlink" title="添加数据(INSERT INTO)"></a>添加数据(INSERT INTO)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- A增加数据分两种：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不指定具体字段名如</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name </span><br><span class="line"><span class="keyword">VALUES</span>(值<span class="number">1</span>，值<span class="number">2</span>…); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定字段名</span></span><br><span class="line"><span class="comment">-- 如果是为指定的字段加数据，只需要写出需要加数据的字段即可</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name</span><br><span class="line">(字段<span class="number">1</span>，字段<span class="number">2</span>….)</span><br><span class="line"><span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>….);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 同时插入多条数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name </span><br><span class="line">[字段列表]</span><br><span class="line"><span class="keyword">VALUES</span>(取舍列表<span class="number">1</span>)，(取值列表<span class="number">2</span>)…;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将一个表的数据插入到别个一张表中</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name1</span><br><span class="line">(字段列表)</span><br><span class="line"><span class="keyword">SELECT</span> (表<span class="number">2</span>字段) <span class="keyword">FROM</span> table_name2 <span class="keyword">WHERE</span> 条件表达式;</span><br></pre></td></tr></table></figure><h2 id="更新数据-改-操作-UPDATE"><a href="#更新数据-改-操作-UPDATE" class="headerlink" title="更新数据(改)操作(UPDATE)"></a>更新数据(改)操作(UPDATE)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 可以对一定范围中的数据更改，主要是从where后面的条件来判断</span></span><br><span class="line"><span class="keyword">UPDATE</span> table_name </span><br><span class="line"><span class="keyword">SET</span> 字段<span class="number">1</span>=值<span class="number">1</span>，字段<span class="number">2</span>=值<span class="number">2</span>…</span><br><span class="line"><span class="keyword">WHERE</span> 条件表达式;</span><br></pre></td></tr></table></figure><p>　　</p><h2 id="删除数据操作-DELETE"><a href="#删除数据操作-DELETE" class="headerlink" title="删除数据操作(DELETE)"></a>删除数据操作(DELETE)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 依据条件表达式筛选需要删除的数据。</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> 条件表达式;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将会删除所有数据。</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><h2 id="查询数据-QUERY"><a href="#查询数据-QUERY" class="headerlink" title="查询数据(QUERY)"></a>查询数据(QUERY)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段名列表 </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line">[<span class="keyword">WHERE</span> 条件表达式<span class="number">1</span>] </span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> 字段名</span><br><span class="line">    [<span class="keyword">HAVING</span> 条件表达式<span class="number">2</span>]</span><br><span class="line">]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段名</span><br><span class="line">    [<span class="keyword">ASC</span>(升序)/<span class="keyword">DESC</span>(降序)]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 单表查询</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> 条件;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 带in关键字查询</span></span><br><span class="line"><span class="comment">-- 判断某个字段的值是否在指定的集合中，是的话就查出来</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段名 table_name <span class="keyword">WHERE</span> 字段名 <span class="keyword">IN</span> (值<span class="number">1</span>，值<span class="number">2</span>…..) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 带between and 关键字的查询</span></span><br><span class="line"><span class="comment">-- 查找的是范围在值1与值2之间对应的数据;结果是包含两端的值的。</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> 字段名 </span><br><span class="line"><span class="keyword">BETWEEN</span> 值<span class="number">1</span> <span class="keyword">AND</span> 值<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 带like的匹配查询一个完整字符串，可以加%;</span></span><br><span class="line"><span class="comment">-- %表示任意长度的字符串如b%k表示以b开头，以k对事的任意字符串，而只表示单个字符，如b_k表示以b开始k结束的3个字符的字符串 。not表示不匹配时.</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> 字段名 [<span class="keyword">not</span>] <span class="keyword">LIKE</span> 条件;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 空值查询</span></span><br><span class="line"><span class="comment">-- 即查询[不]为空的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">WHERE</span> 字段名 <span class="keyword">IS</span> [<span class="keyword">not</span>]<span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- and与or的多条件查询</span></span><br><span class="line"><span class="comment">-- and表示所以条件都必须成立，而or表示只需要其中任何一个条件成立就可以。</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">WHERE</span> 条件<span class="number">1</span> <span class="keyword">AND</span> 条件<span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果不重复</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 字段名 <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 单独用 group by 分组，结果只会显示一个分组的一条记录</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 字段名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- group by 和group_concat()函数使用</span></span><br><span class="line"><span class="comment">-- 功能：将group by产生的同一个分组中的值连接起来，返回一个字符串结果。</span></span><br><span class="line"><span class="comment">-- 语法：group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator '分隔符'] )</span></span><br><span class="line"><span class="comment">-- 说明：通过使用distinct可以排除重复值；如果希望对结果中的值进行排序，可以使用order by子句；separator是一个字符串值，缺省为一个逗号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 每个分组的所有字段都可以显示。</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段名, GROUP_COUCAT(字段名) <span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 字段名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- group by与集合函数使用</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段名, <span class="keyword">COUNT</span>(字段名) <span class="keyword">FROM</span>  table_name </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 字段名 <span class="keyword">HAVING</span> <span class="keyword">COUNT</span> (字段名) 条件;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多字段分组</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">GROUP</span> <span class="keyword">BY</span> 字段<span class="number">1</span>，字段<span class="number">2</span>…;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- group by与with rollup一起用</span></span><br><span class="line"><span class="comment">-- ROLLUP 运算符生成的结果集类似于 CUBE 运算符生成的结果集。</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段名, <span class="keyword">COUNT</span>(字段名) <span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 字段名 <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure><h2 id="用limit限制查询数据"><a href="#用limit限制查询数据" class="headerlink" title="用limit限制查询数据"></a>用limit限制查询数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 前者是显示从第一条到a条数据</span></span><br><span class="line"><span class="comment">-- 后者是显示从a条到b条间的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span>  table_name </span><br><span class="line"><span class="keyword">LIMIT</span> a 或(<span class="keyword">LIMIT</span> a,b);</span><br></pre></td></tr></table></figure><h2 id="使用集合函数查询数据"><a href="#使用集合函数查询数据" class="headerlink" title="使用集合函数查询数据"></a>使用集合函数查询数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- count()统计数据条数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> table_name </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- sum()求和</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段名, <span class="keyword">SUM</span>(字段名) <span class="keyword">FROM</span>  table_name </span><br><span class="line"><span class="keyword">WHERE</span> 条件; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- avg()求平均数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(字段名) <span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 字段名; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- max与min最大与最小值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(字段名)/<span class="keyword">MIN</span>(字段名) <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><h2 id="多表连接查询"><a href="#多表连接查询" class="headerlink" title="多表连接查询"></a>多表连接查询</h2><h3 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h3><p>两个以上表中存在意义相同的字段时，可以用该字段来连接表进行查询.如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>，字段<span class="number">2</span>，字段<span class="number">3</span>…</span><br><span class="line"><span class="keyword">FROM</span> table_name1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table_name2 </span><br><span class="line"><span class="keyword">ON</span> table_name1.字段a=table_name2.字段b;</span><br></pre></td></tr></table></figure><h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Letf表示左链接，right表示右链接。</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> table_name01 </span><br><span class="line"><span class="keyword">LEFT</span>/<span class="keyword">RIGHT</span>  <span class="keyword">JOIN</span> table_name02 <span class="keyword">ON</span> table_name01.字段名=talbe_name02.字段名;</span><br></pre></td></tr></table></figure><p>　　</p><h2 id="用正则表达式查询"><a href="#用正则表达式查询" class="headerlink" title="用正则表达式查询"></a>用正则表达式查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询以特定字符开头的记录。以a头。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> 字段名 REGEXP <span class="string">'^a'</span>;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询以特定字符结束的记录。以xx结尾。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> REGEXP <span class="string">'xx$'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用符号"."来代替字符串中任意一个字符。以1开头y结尾，且中间两个字符。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">name</span> REGEXP <span class="string">'^1..y$'</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="表或字段取别名"><a href="#表或字段取别名" class="headerlink" title="表或字段取别名"></a>表或字段取别名</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表的别名。t就是表的别名。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name t <span class="keyword">WHERE</span>  t.字段=值;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字段的别名。用as关键字。</span></span><br><span class="line"><span class="keyword">SELECT</span> t_id <span class="keyword">as</span> <span class="keyword">id</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> t_id=值 ;</span><br></pre></td></tr></table></figure><hr><h1 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> mysqldump命令备份.</span><br><span class="line"><span class="meta">#</span> 其中db_name是数据库的名称, table1..是表名, backupname.sql表示备份文件的名称，前面可以加个绝对路径</span><br><span class="line"><span class="meta">#</span> 如果没有表名将备份 整个数据库</span><br><span class="line">mysqldump –u username –p db_name table1,table2….&gt;backupname.sql;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 备份多个数据库</span><br><span class="line">mysqldump -u username –p –databases db_name1 db_name2… &gt; backupname.sql </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 备份所有数据库</span><br><span class="line">mysqldump –u root –p –all-databases &gt; C:\all.sql </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 用Mysqlhotcopy工具快速备份 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 数据库还原</span><br><span class="line"><span class="meta">#</span> 其中backup.sql是保存的数据库文件</span><br><span class="line">mysql –u root –p &lt; backup.sql</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手把手叫会零基础的你使用mysql。&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://jelly54.github.io/categories/Mysql/"/>
    
    
      <category term="mysql" scheme="https://jelly54.github.io/tags/mysql/"/>
    
      <category term="使用手册" scheme="https://jelly54.github.io/tags/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>mysql5.7 安装教程</title>
    <link href="https://jelly54.github.io/mysql-install/"/>
    <id>https://jelly54.github.io/mysql-install/</id>
    <published>2020-01-11T07:53:14.000Z</published>
    <updated>2020-08-27T11:05:52.289Z</updated>
    
    <content type="html"><![CDATA[<p>手把手教你安装mysql5.7</p><h1 id="官方最新下载地址"><a href="#官方最新下载地址" class="headerlink" title="官方最新下载地址"></a>官方最新下载地址</h1><p><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/</a></p><a id="more"></a><h1 id="解压压缩包"><a href="#解压压缩包" class="headerlink" title="解压压缩包"></a>解压压缩包</h1><p>自5.7.16版本以后，解压后，根目录就不带 my-default.ini 或 my.ini 配置文件和data文件夹。<br>首先在根目录创建一个 my.ini 配置文件，my.ini 配置内容如下，注意安装目录和数据库存放目录为实际安装的目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[mysql]</span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line">default-character-set=utf8 </span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">#设置3306端口</span><br><span class="line">port = 3306 </span><br><span class="line"></span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line">basedir=E:\MySQL\mysql-5.7.21-winx64</span><br><span class="line"></span><br><span class="line"># 设置mysql数据库的数据的存放目录</span><br><span class="line">datadir=E:\MySQL\mysql-5.7.21-winx64\data</span><br><span class="line"></span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=200</span><br><span class="line"></span><br><span class="line"># 服务端使用的字符集默认为8比特编码的latin1字符集</span><br><span class="line">character-set-server=utf8</span><br><span class="line"></span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine=INNODB</span><br></pre></td></tr></table></figure><h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><p>新增 <strong>系统变量</strong>： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">变量名：MYSQL_HOME </span><br><span class="line">变量值：E:\MySQL\mysql-5.7.21-winx64 </span><br><span class="line"> </span><br><span class="line">在环境变量Path中添加：%MYSQL_HOME%\bin</span><br></pre></td></tr></table></figure><h1 id="安装-MySQL服务"><a href="#安装-MySQL服务" class="headerlink" title="安装 MySQL服务"></a>安装 MySQL服务</h1><p>以管理员身份运行命令提示符；<br>运行 mysqld install ，执行后提示 Service successfully installed；</p><h1 id="初始化mysql数据"><a href="#初始化mysql数据" class="headerlink" title="初始化mysql数据"></a>初始化mysql数据</h1><p>打开cmd执行如下命令，创建了一个具有空密码的root用户（ 可能需要进入bin目录下输入此命令）： </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initialize-insecure --user=mysql</span><br></pre></td></tr></table></figure><p>最后的参数 –user=mysql 在 windows 也可以不用添加，但在 unix 等系统下好像很重要。</p><p>执行命令后，系统会自动生成相应的 data 目录，并自动创建好空密码的 root 用户。此时表示初始化成功。</p><h1 id="运行MySQL服务"><a href="#运行MySQL服务" class="headerlink" title="运行MySQL服务"></a>运行MySQL服务</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动MySQL</span></span><br><span class="line">net start mysql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止MySQL</span></span><br><span class="line">net stop mysql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录</span></span><br><span class="line">mysql -u root –p</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 首次修改密码</span></span><br><span class="line">mysqladmin -u root password "newpass" </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果root已经设置过密码，采用如下方法修改 </span></span><br><span class="line">mysqladmin -u root -p password "newpass"</span><br></pre></td></tr></table></figure><h1 id="time-to-show"><a href="#time-to-show" class="headerlink" title="time to show"></a>time to show</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本语句</span></span><br><span class="line">mysql&gt; show databases;   // 显示所有数据库</span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">mysql&gt;  ····</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手把手教你安装mysql5.7&lt;/p&gt;
&lt;h1 id=&quot;官方最新下载地址&quot;&gt;&lt;a href=&quot;#官方最新下载地址&quot; class=&quot;headerlink&quot; title=&quot;官方最新下载地址&quot;&gt;&lt;/a&gt;官方最新下载地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/downloads/mysql/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/downloads/mysql/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://jelly54.github.io/categories/Mysql/"/>
    
    
      <category term="mysql" scheme="https://jelly54.github.io/tags/mysql/"/>
    
      <category term="安装教程" scheme="https://jelly54.github.io/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础、原理全覆盖</title>
    <link href="https://jelly54.github.io/redis-learn/"/>
    <id>https://jelly54.github.io/redis-learn/</id>
    <published>2019-12-22T09:32:14.000Z</published>
    <updated>2020-08-28T02:45:07.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-是什么"><a href="#Redis-是什么" class="headerlink" title="Redis 是什么"></a>Redis 是什么</h1><p>Redis: REmote DIctionary Server(远程字典服务器)<br>完全开源免费，C语言编写遵守BSD协议，一个高性能的（key/value)分布式内存数据库。基于内存运行并支持持久化的NOSQL数据库被称为数据结构服务器。</p><a id="more"></a><h2 id="与其他key-value缓存产品区别？"><a href="#与其他key-value缓存产品区别？" class="headerlink" title="与其他key-value缓存产品区别？"></a>与其他key-value缓存产品区别？</h2><ul><li>性能优秀，数据在内存中，读写速度非常快，支持并发- 10W QPS；</li><li>单进程单线程，是线程安全的，采用IO多路复用机制；</li><li>丰富的数据类型，支持字符串（strings）、散列（has- hes）、列表（lists）、集合（sets）、有序集合（so- rted sets）等；</li><li>支持数据持久化。可以将内存中数据保存在磁盘中，重- 启时加载；</li><li>主从复制，哨兵，高可用；</li><li>可以用作分布式锁；</li><li>可以作为消息中间件使用，支持发布订阅</li></ul><hr><h1 id="五种数据类型"><a href="#五种数据类型" class="headerlink" title="五种数据类型"></a>五种数据类型</h1><h2 id="Redis如何管理"><a href="#Redis如何管理" class="headerlink" title="Redis如何管理"></a>Redis如何管理</h2><p>先来了解下Redis内部内存管理是如何描述这5种数据类型。</p><p><img src="https://s2.ax1x.com/2019/12/27/lEOZA1.jpg" alt="lEOZA1.jpg"></p><p>首先redis内部使用一个redisObject对象来表示所有的key和value，redisObject最主要的信息如上图所示：<strong>type表示一个value对象具体是何种数据类型;<br>encoding是不同数据类型在redis内部的存储方式。</strong></p><p>比如：type=string表示value存储的是一个普通字符串，那么encoding可以是raw或者int。</p><h2 id="5种数据类型"><a href="#5种数据类型" class="headerlink" title="5种数据类型"></a>5种数据类型</h2><ol><li><p><strong>string是redis最基本的类型，可以理解成与memcached一模一样的类型，一个key对应一个value。</strong> value不仅是string，也可以是数字。string类型是二进制安全的，意思是redis的string类型可以包含任何数据，比如jpg图片或者序列化的对象。string类型的值最大能存储512M。</p></li><li><p><strong>Hash是一个键值（key-value）的集合。</strong> redis的hash是一个string的key和value的映射表，Hash特别适合存储对象。常用命令：hget,hset,hgetall等。</p></li><li><p><strong>list列表是简单的字符串列表，按照插入顺序排序。</strong> 可以添加一个元素到列表的头部（左边）或者尾部（右边） 常用命令：lpush、rpush、lpop、rpop、lrange(获取列表片段)等。</p><p> 应用场景：list应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表都可以用list结构来实现。</p><p> 数据结构：list就是链表，可以用来当消息队列用。redis提供了List的push和pop操作，还提供了操作某一段的api，可以直接查询或者删除某一段的元素。</p><p> 实现方式：redis <strong>list的是实现是一个双向链表，</strong> 既可以支持反向查找和遍历，更方便操作，不过带来了额外的内存开销。</p></li><li><p><strong>set是string类型的无序集合。</strong> 集合是通过hashtable实现的。set中的元素是没有顺序的，而且是没有重复的。</p><p> 常用命令：sdd、spop、smembers、sunion等。</p><p> 应用场景：redis set对外提供的功能和list一样是一个列表，特殊之处在于set是自动去重的，而且set提供了判断某个成员是否在一个set集合中。</p></li><li><p><strong>zset和set一样是string类型元素的集合，且不允许重复的元素。</strong> 常用命令：zadd、zrange、zrem、zcard等。</p><p> 使用场景：sorted set可以通过用户额外提供一个优先级（score）的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set结构。和set相比，sorted set关联了一个double类型权重的参数score，使得集合中的元素能够按照score进行有序排列，redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p> 实现方式：Redis <strong>sorted set的内部使用HashMap和跳跃表(skipList)来保证数据的存储和有序，</strong> HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</p></li></ol><h2 id="数据类型应用场景总结"><a href="#数据类型应用场景总结" class="headerlink" title="数据类型应用场景总结"></a>数据类型应用场景总结</h2><p><img src="https://s2.ax1x.com/2019/12/27/lEXuan.jpg" alt="lEXuan.jpg"></p><hr><h1 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h1><p>结合spring boot使用的。一般有两种方式，一种是直接通过RedisTemplate来使用，另一种是使用spring cache集成Redis（也就是注解的方式）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol><li>spring-boot-starter-data-redis: <strong>在spring boot 2.x以后底层不再使用Jedis，而是换成了Lettuce。</strong></li><li>commons-pool2：<strong>用作redis连接池，如不引入启动会报错</strong></li><li>spring-session-data-redis：spring session引入，用作共享session。</li></ol><p>配置文件application.yml的配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">  servlet:</span></span><br><span class="line"><span class="attr">    session:</span></span><br><span class="line"><span class="attr">      timeout:</span> <span class="number">30</span><span class="string">ms</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cache:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">    password:</span></span><br><span class="line">    <span class="comment"># redis默认情况下有16个分片，这里配置具体使用的分片，默认为0</span></span><br><span class="line"><span class="attr">    database:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    lettuce:</span></span><br><span class="line"><span class="attr">      pool:</span></span><br><span class="line">        <span class="comment"># 连接池最大连接数(使用负数表示没有限制),默认8</span></span><br><span class="line"><span class="attr">        max-active:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="RedisTemplate使用方式"><a href="#RedisTemplate使用方式" class="headerlink" title="RedisTemplate使用方式"></a>RedisTemplate使用方式</h2><p>默认情况下的模板只能支持RedisTemplate&lt;String, String&gt;，也就是只能存入字符串，所以自定义模板很有必要。</p><p>添加配置类RedisCacheConfig.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(RedisAutoConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Serializable&gt; <span class="title">redisCacheTemplate</span><span class="params">(LettuceConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;String, Serializable&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        template.setValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Logger logger = LogManager.getLogger(UserController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Serializable&gt; redisCacheTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisCacheTemplate.opsForValue().set(<span class="string">"userkey"</span>, <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"张三"</span>, <span class="number">25</span>));</span><br><span class="line">        User user = (User) redisCacheTemplate.opsForValue().get(<span class="string">"userkey"</span>);</span><br><span class="line">        logger.info(<span class="string">"当前获取对象：&#123;&#125;"</span>, user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用spring-cache集成redis"><a href="#使用spring-cache集成redis" class="headerlink" title="使用spring cache集成redis"></a>使用spring cache集成redis</h2><p>spring cache具备很好的灵活性，不仅能够使用<strong>SPEL(spring expression language)</strong> 来定义缓存的key和各种condition，还提供了开箱即用的缓存临时存储方案，也支持和主流的专业缓存如EhCache、Redis、Guava的集成。</p><p>定义接口UserService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">get</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口实现类UserServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Logger logger = LogManager.getLogger(UserServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, User&gt; userMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        userMap.put(<span class="number">1</span>, <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"肖战"</span>, <span class="number">25</span>));</span><br><span class="line">        userMap.put(<span class="number">2</span>, <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">"王一博"</span>, <span class="number">26</span>));</span><br><span class="line">        userMap.put(<span class="number">3</span>, <span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">"杨紫"</span>, <span class="number">24</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@CachePut</span>(value =<span class="string">"user"</span>, key = <span class="string">"#user.id"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userMap.put(user.getId(), user);</span><br><span class="line">        logger.info(<span class="string">"进入save方法，当前存储对象：&#123;&#125;"</span>, user.toString());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict</span>(value=<span class="string">"user"</span>, key = <span class="string">"#id"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        userMap.remove(id);</span><br><span class="line">        logger.info(<span class="string">"进入delete方法，删除成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable</span>(value = <span class="string">"user"</span>, key = <span class="string">"#id"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"进入get方法，当前获取对象：&#123;&#125;"</span>, userMap.get(id)==<span class="keyword">null</span>?<span class="keyword">null</span>:userMap.get(id).toString());</span><br><span class="line">        <span class="keyword">return</span> userMap.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便演示数据库的操作，这里直接定义了一个Map&lt;Integer,User&gt; userMap，这里的核心是三个注解 <strong>@Cachable、@CachePut和@CacheEvict</strong></p><p>用缓存要注意，启动类要加上一个注解开启缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(exclude=DataSourceAutoConfiguration.class)</span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存注解"><a href="#缓存注解" class="headerlink" title="缓存注解"></a>缓存注解</h2><h3 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h3><p>根据方法的请求参数对其结果进行缓存</p><ul><li>key：缓存的key，可以为空，如果指定要按照SPEL表达式编写，如果不指定，则按照方法的所有参数进行组合。</li><li>value：缓存的名称，必须指定至少一个（如 @Cacheable (value=’user’)或者@Cacheable(value={‘user1’,’user2’})）</li><li>condition：缓存的条件，可以为空，使用SPEL编写，返回true或者false，只有为true才进行缓存。</li></ul><h3 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h3><p>根据方法的请求参数对其结果进行缓存，和@Cacheable不同的是，它每次都会触发真实方法的调用。参数描述见上。</p><h3 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h3><p>根据条件对缓存进行清空</p><ul><li>key：同上</li><li>value：同上</li><li>condition：同上</li><li>allEntries：是否清空所有缓存内容，缺省为false，如果指定为true，则方法调用后将立即清空所有缓存</li><li>beforeInvocation：是否在方法执行前就清空，缺省为false，如果指定为true，则在方法还没有执行的时候就清空缓存。缺省情况下，如果方法执行抛出异常，则不会清空缓存。</li></ul><hr><h1 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h1><h2 id="缓存和数据库数据一致性问题"><a href="#缓存和数据库数据一致性问题" class="headerlink" title="缓存和数据库数据一致性问题"></a>缓存和数据库数据一致性问题</h2><p>分布式环境下非常容易出现缓存和数据库间数据一致性问题，针对这一点，<strong>如果项目对缓存的要求是强一致性的，那么就不要使用缓存</strong>。我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。<strong>合适的策略包括合适的缓存更新策略，更新数据库后及时更新缓存、缓存失败时增加重试机制。</strong></p><h2 id="缓存雪崩？"><a href="#缓存雪崩？" class="headerlink" title="缓存雪崩？"></a>缓存雪崩？</h2><p>目前电商首页以及热点数据都会去做缓存，一般缓存都是定时任务去刷新，或者查不到之后去更新缓存的，定时任务刷新就有一个问题。</p><p>举个栗子：如果首页所有Key的失效时间都是12小时，中午12点刷新的，我零点有个大促活动大量用户涌入，假设每秒6000个请求，本来缓存可以抗住每秒5000个请求，但是<strong>缓存中所有Key都失效了。此时6000个/秒的请求全部落在了数据库上</strong>，数据库必然扛不住，真实情况可能DBA都没反应过来直接挂了，此时，如果没什么特别的方案来处理，DBA很着急，重启数据库，但是数据库立马又被新流量给打死了。这就是我理解的缓存雪崩。</p><p><strong>同一时间大面积失效，瞬间Redis跟没有一样，那这个数量级别的请求直接打到数据库几乎是灾难性的</strong>，你想想如果挂的是一个用户服务的库，那其他依赖他的库所有接口几乎都会报错，如果没做熔断等策略基本上就是瞬间挂一片的节奏，你怎么重启用户都会把你打挂，等你重启好的时候，用户早睡觉去了，临睡之前，骂骂咧咧“什么垃圾产品”。</p><h3 id="怎么应对？"><a href="#怎么应对？" class="headerlink" title="怎么应对？"></a>怎么应对？</h3><p>处理缓存雪崩简单，在批量往Redis存数据的时候，把每个Key的失效时间都加个随机值就好了，这样可以保证数据不会再同一时间大面积失效。</p><p>setRedis（key, value, time+Math.random()*10000）;<br>如果Redis是集群部署，将热点数据均匀分布在不同的Redis库中也能避免全部失效。或者设置热点数据永不过期，有更新操作就更新缓存就好了（比如运维更新了首页商品，那你刷下缓存就好了，不要设置过期时间），电商首页的数据也可以用这个操作，保险。</p><h2 id="缓存穿透和击穿？"><a href="#缓存穿透和击穿？" class="headerlink" title="缓存穿透和击穿？"></a>缓存穿透和击穿？</h2><p>先说下缓存穿透吧，<strong>缓存穿透是指缓存和数据库中都没有的数据，而用户（黑客）不断发起请求</strong>，举个栗子：我们数据库的id都是从1自增的，如果发起id=-1的数据或者id特别大不存在的数据，这样的不断攻击导致数据库压力很大，严重会击垮数据库。</p><p>至于缓存击穿嘛，这个跟缓存雪崩有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿不同的是<strong>缓存击穿是指一个Key非常热点，在不停地扛着大量的请求</strong>，大并发集中对这一个点进行访问，<strong>当这个Key在失效的瞬间，持续的大并发直接落到了数据库上</strong>，就在这个Key的点上击穿了缓存。</p><h3 id="怎么解决？"><a href="#怎么解决？" class="headerlink" title="怎么解决？"></a>怎么解决？</h3><ol><li><p>缓存穿透我会在接口层增加校验，比如用户鉴权，参数做校验，不合法的校验直接return，比如id做基础校验，id&lt;=0直接拦截。</p></li><li><p>我记得Redis里还有一个高级用法布隆过滤器（Bloom Filter）这个也能很好的预防缓存穿透的发生，他的原理也很简单，就是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查DB刷新KV再return。缓存击穿的话，设置热点数据永不过期，或者加上互斥锁就搞定了。作为暖男，代码给你准备好了，拿走不谢。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getData</span><span class="params">(String key)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//从Redis查询数据</span></span><br><span class="line">        String result = getDataByKV(key);</span><br><span class="line">        <span class="comment">//参数校验</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(result)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获得锁</span></span><br><span class="line">                <span class="keyword">if</span> (reenLock.tryLock()) &#123;</span><br><span class="line">                    <span class="comment">//去数据库查询</span></span><br><span class="line">                    result = getDataByDB(key);</span><br><span class="line">                    <span class="comment">//校验</span></span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotBlank(result)) &#123;</span><br><span class="line">                        <span class="comment">//插进缓存</span></span><br><span class="line">                        setDataToKV(key, result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//睡一会再拿</span></span><br><span class="line">                    Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">                    result = getData(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                reenLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Redis为何这么快"><a href="#Redis为何这么快" class="headerlink" title="Redis为何这么快"></a>Redis为何这么快</h1><h2 id="redis作为缓存大家都在用，那redis一定很快咯？"><a href="#redis作为缓存大家都在用，那redis一定很快咯？" class="headerlink" title="redis作为缓存大家都在用，那redis一定很快咯？"></a>redis作为缓存大家都在用，那redis一定很快咯？</h2><p>当然了，官方提供的数据可以达到100000+的QPS（每秒内的查询次数），这个数据不比Memcached差！</p><h2 id="redis这么快，它的“多线程模型”你了解吗？（露出邪魅一笑）"><a href="#redis这么快，它的“多线程模型”你了解吗？（露出邪魅一笑）" class="headerlink" title="redis这么快，它的“多线程模型”你了解吗？（露出邪魅一笑）"></a>redis这么快，它的“多线程模型”你了解吗？（露出邪魅一笑）</h2><p>这是想问Redis这么快，为什么还是单线程的吧。Redis确实是单进程单线程的模型，因为Redis完全是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章的采用单线程的方案了（毕竟采用多线程会有很多麻烦）。</p><h2 id="Redis是单线程的，为什么还能这么快吗？"><a href="#Redis是单线程的，为什么还能这么快吗？" class="headerlink" title="Redis是单线程的，为什么还能这么快吗？"></a>Redis是单线程的，为什么还能这么快吗？</h2><ol><li>Redis完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度是O(1)。</li><li>数据结构简单，对数据操作也简单。</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的CPU切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。</li><li>使用多路复用IO模型，非阻塞IO。</li></ol><h2 id="Redis和Memcached的区别"><a href="#Redis和Memcached的区别" class="headerlink" title="Redis和Memcached的区别"></a>Redis和Memcached的区别</h2><ol><li>存储方式上：memcache会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。redis有部分数据存在硬盘上，这样能保证数据的持久性。</li><li>数据支持类型上：memcache对数据类型的支持简单，只支持简单的key-value，，而redis支持五种数据类型。</li><li>性能对比，redis只使用单核而memcached使用多核，所以平均每一个核上Rdis在存储小数据时比Memcached性能更高。100k以上的数据中，memcached性能更高。</li><li>集群模式:memcached没有原生的集群模式，需要依靠客户端来实现向集群中分片写入数据；但是redis目前是原生支持cluster模式的，redis官方就是支持redis cluster集群模式的，比memcached来说要更好。</li><li>value的大小：redis可以达到1GB，而memcache只有1MB</li></ol><hr><h1 id="Redis单线程模型"><a href="#Redis单线程模型" class="headerlink" title="Redis单线程模型"></a>Redis单线程模型</h1><h2 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h2><p>redis基于reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器，file event handler。这个文件事件处理器，是单线程的，redis才叫做单线程的模型，采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器来处理这个事件。</p><blockquote><p>Reactor模式首先是事件驱动的，有一个或多个并发输入源，有一个Service Handler，有多个Request Handlers；这个Service Handler会同步的将输入的请求（Event）多路复用的分发给相应的Request Handler。<br><img src="https://s2.ax1x.com/2019/12/28/lezWdS.png" alt="lezWdS.png"></p></blockquote><p>如果被监听的socket准备好执行accept、read、write、close等操作的时候，跟操作对应的文件事件就会产生，这个时候文件事件处理器就会调用之前关联好的事件处理器来处理这个事件。</p><p>文件事件处理器是单线程模式运行的，但是通过IO多路复用机制监听多个socket，可以实现高性能的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了redis内部的线程模型的简单性。</p><p>文件事件处理器的结构包含4个部分：<strong>多个socket，IO多路复用程序，文件事件分派器，事件处理器（命令请求处理器、命令回复处理器、连接应答处理器，等等）。</strong></p><p>多个socket可能并发的产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个socket，但是会将socket放入一个队列中排队，每次从队列中取出一个socket给事件分派器，事件分派器把socket给对应的事件处理器。</p><p>然后一个socket的事件处理完之后，IO多路复用程序才会将队列中的下一个socket给事件分派器。文件事件分派器会根据每个socket当前产生的事件，来选择对应的事件处理器来处理。</p><h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>当socket变得可读时（比如客户端对redis执行write操作，或者close操作），或者有新的可以应答的socket出现时（客户端对redis执行connect操作），socket就会产生一个<strong>AE_READABLE</strong>事件。</p><p>当socket变得可写的时候（客户端对redis执行read操作），socket会产生一个<strong>AE_WRITABLE</strong>事件。</p><p>IO多路复用程序可以同时监听 <strong>AE_REABLE和AE_WRITABLE</strong> 两种事件，要是一个socket同时产生<strong>AE_REABLE和AE_WRITABLE</strong> 两种事件，那么文件事件分派器<strong>优先处理AE_REABLE事件</strong>，然后才是AE_WRITABLE事件。</p><h2 id="文件事件处理器-1"><a href="#文件事件处理器-1" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h2><ul><li>如果是客户端要连接redis，那么会为socket关联<strong>连接应答处理器</strong> </li><li>如果是客户端要写数据到redis，那么会为socket关联<strong>命令请求处理器</strong> </li><li>如果是客户端要从redis读数据，那么会为socket关<strong>联命令回复处理器</strong>  </li></ul><h2 id="客户端与redis通信的一次流程"><a href="#客户端与redis通信的一次流程" class="headerlink" title="客户端与redis通信的一次流程"></a>客户端与redis通信的一次流程</h2><p><img src="https://s2.ax1x.com/2019/12/28/lmS6fJ.png" alt="lmS6fJ.png"></p><p>在redis启动初始化的时候，redis会将连接应答处理器跟AE_READABLE事件关联起来，接着如果一个客户端跟redis发起连接，此时会产生一个AE_READABLE事件，然后由连接应答处理器来处理跟客户端建立连接，创建客户端对应的socket，同时将这个socket的AE_READABLE事件跟命令请求处理器关联起来。</p><p>当客户端向redis发起请求的时候（不管是读请求还是写请求，都一样），首先就会在socket产生一个AE_READABLE事件，然后由对应的命令请求处理器来处理。这个命令请求处理器就会从socket中读取请求相关数据，然后进行执行和处理。</p><p>接着redis这边准备好了给客户端的响应数据之后，就会将socket的AE_WRITABLE事件跟命令回复处理器关联起来，当客户端这边准备好读取响应数据时，就会在socket上产生一个AE_WRITABLE事件，会由对应的命令回复处理器来处理，就是将准备好的响应数据写入socket，供客户端来读取。</p><p>命令回复处理器写完之后，就会删除这个socket的AE_WRITABLE事件和命令回复处理器的关联关系。</p><hr><h1 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h1><p><strong>定期删除+惰性删除</strong> </p><p><strong>定期删除</strong>，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。</p><p>假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。</p><p>但是问题是，定期删除可能会导致很多过期key到了时间并没有被删除掉，那咋整呢？所以就是<strong>惰性删除了</strong>。这就是说，在你获取某个key的时候，redis会检查一下 ，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。</p><p>并不是key到时间就被删除掉，而是你查询这个key的时候，redis再懒惰的检查一下</p><p>通过上述两种手段结合起来，保证过期的key一定会被干掉。</p><hr><h1 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h1><p>实际上，如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了，咋整？</p><p>答案是：走内存淘汰机制</p><p><img src="https://s2.ax1x.com/2019/12/27/lVCzqK.jpg" alt="lVCzqK.jpg"></p><p><strong>补充一下：</strong><br>Redis4.0加入了LFU(least frequency use)淘汰策略，包括volatile-lfu和allkeys-lfu，通过统计访问频率，将访问频率最少，即最不经常使用的KV淘汰。</p><ul><li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）</li><li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除</li><li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li><li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的key给干掉啊</li><li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了</li></ul><h2 id="手写lru算法"><a href="#手写lru算法" class="headerlink" title="手写lru算法"></a>手写lru算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里就是传递进来最多能缓存多少数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> cacheSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这块就是设置一个hashmap的初始大小</span></span><br><span class="line">        <span class="comment">// 同时最后一个true指的是让linkedhashmap按照访问顺序来进行排序</span></span><br><span class="line">        <span class="comment">// 最近访问的放在头，最老访问的就在尾</span></span><br><span class="line">        <span class="keyword">super</span>((<span class="keyword">int</span>) Math.ceil(cacheSize / <span class="number">0.75</span>) + <span class="number">1</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>); </span><br><span class="line">        CACHE_SIZE = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这个意思就是说当map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据</span></span><br><span class="line">        <span class="keyword">return</span> size() &gt; CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="redis的持久化机制？"><a href="#redis的持久化机制？" class="headerlink" title="redis的持久化机制？"></a>redis的持久化机制？</h2><p>redis为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。Redis的持久化策略有两种：</p><ul><li><p>RDB：快照形式是直接把内存中的数据保存到一个dump的文件中，定时保存，保存策略。</p></li><li><p>AOF：把所有的对Redis的服务器进行修改的命令都存到一个文件里，命令的集合。Redis默认是快照RDB的持久化方式。</p></li></ul><p>当Redis重启的时候，它会优先使用AOF文件来还原数据集，因为AOF文件保存的数据集通常比RDB文件所保存的数据集更完整。你甚至可以关闭持久化功能，让数据只在服务器运行时存。</p><h2 id="RDB是怎么工作的？"><a href="#RDB是怎么工作的？" class="headerlink" title="RDB是怎么工作的？"></a>RDB是怎么工作的？</h2><p>默认Redis是会以快照”RDB”的形式将数据持久化到磁盘的一个二进制文件dump.rdb。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>当Redis需要做持久化时，Redis会fork一个子进程，子进程将数据写到磁盘上一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉，这样的好处是可以copy-on-write。</p><h3 id="RDB的优"><a href="#RDB的优" class="headerlink" title="RDB的优"></a>RDB的优</h3><p>这种文件非常适合用于备份：比如，你可以在最近的24小时内，每小时备份一次，并且在每个月的每一天也备份一个RDB文件。这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB非常适合灾难恢复。RDB的缺点是：如果你需要尽量避免在服务器故障时丢失数据，那么RDB不合适你。</p><h2 id="AOF是怎么工作的？"><a href="#AOF是怎么工作的？" class="headerlink" title="AOF是怎么工作的？"></a>AOF是怎么工作的？</h2><p>使用AOF做持久化，每一个写命令都通过write函数追加到appendonly.aof中，配置方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appendfsync yes   </span><br><span class="line">appendfsync always    </span><br><span class="line">#每次有数据修改发生时都会写入AOF文件。</span><br><span class="line">#每秒钟同步一次，该策略为AOF的缺省策略。</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><p>AOF可以做到全程持久化，只需要在配置中开启 appendonly yes。这样redis每执行一个修改数据的命令，都会把它添加到AOF文件中，当redis重启时，将会读取AOF文件进行重放，恢复到redis关闭前的最后时刻。</p><h3 id="使用AOF的优点"><a href="#使用AOF的优点" class="headerlink" title="使用AOF的优点"></a>使用AOF的优点</h3><p>让redis变得非常耐久。可以设置不同的fsync策略，aof的默认策略是每秒钟fsync一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。缺点是对于相同的数据集来说，AOF的文件体积通常要大于RDB文件的体积。根据所使用的fsync策略，AOF的速度可能会慢于RDB。</p><h2 id="该用哪一个呢？"><a href="#该用哪一个呢？" class="headerlink" title="该用哪一个呢？"></a>该用哪一个呢？</h2><p>如果你非常关心你的数据，但仍然可以承受数分钟内的数据丢失，那么可以额只使用RDB持久。</p><p>AOF将Redis执行的每一条命令追加到磁盘中，处理巨大的写入会降低Redis的性能，不知道你是否可以接受。</p><p>数据库备份和灾难恢复：定时生成RDB快照非常便于进行数据库备份，并且RDB恢复数据集的速度也要比AOF恢复的速度快。当然了，redis支持同时开启RDB和AOF，系统重启后，redis会优先使用AOF来恢复数据，这样丢失的数据会最少。</p><hr><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>redis单节点存在单点故障问题，为了解决单点问题，一般都需要对redis配置从节点，然后使用哨兵来监听主节点的存活状态，如果主节点挂掉，从节点能继续提供缓存功能。</p><p>主从配置结合哨兵模式能解决单点故障问题，提高redis可用性。从节点仅提供读操作，主节点提供写操作。对于读多写少的状况，可给主节点配置多个从节点，从而提高响应效率。</p><h2 id="redis-replication核心机制"><a href="#redis-replication核心机制" class="headerlink" title="redis replication核心机制"></a>redis replication核心机制</h2><ol><li>redis <strong>采用异步方式</strong> 复制数据到slave节点，不过redis 2.8开始，slave node会周期性的确认自己每次复制的数据量。</li><li>一个master node是<strong>可以配置多个slave node</strong>的。</li><li>slave node也可以连接其他的slave node。</li><li>slave node做复制的时候，是不会block master node的正常工作的。</li><li>slave node在做复制的时候，也不会对自己的查询操作有影响，它会用旧的数据集来提供服务；但是，<strong>复制完成的时候，需要删除旧的数据集，加载新的数据集</strong>，这个时候就会暂停对外服务了。</li><li>slave node主要<strong>用来横向扩容，做读写分离，扩容的slave node可以提高读的吞吐量</strong>。</li></ol><h2 id="master持久化对主从架构的意义"><a href="#master持久化对主从架构的意义" class="headerlink" title="master持久化对主从架构的意义"></a>master持久化对主从架构的意义</h2><p>如果采用了主从架构，那么<strong>建议必须开启master node持久化!!</strong></p><p>不建议使用slave node作为master node的数据热备，因为那样的话，如果关掉master的持久化，可能在master宕机重启的时候数据是空的，然后经过复制，slave节点也丢失了。</p><blockquote><p>master：RDB和AOF都关闭了，数据都存在内存中  </p><p>master宕机，重启，是没有本地数据可以恢复的，然后就会认为自己的IDE数据是空的，然后将空的数据集同步到slave上去，所有slave的数据集全部清空。</p><p>造成100%数据丢失。</p><p>即使采用了高可用机制，slave node自动接管master node，但是也可能sentinal还没有检测到master failure，master node自动重启了，还是可能会造成slave node数据清空。</p></blockquote><h2 id="复制的过程"><a href="#复制的过程" class="headerlink" title="复制的过程"></a>复制的过程</h2><p>关于复制过程，是这样的：</p><ol><li>从节点启动，执行slaveof [masterIP] [masterPort] <em>(redis.cnf里边的slaveof配置的)</em>， 保存主节点信息</li><li>从节点中的定时任务 <em>(每秒检查是否有新的master node要来连接和复制)</em> 发现主节点信息，建立和主节点的socket连接</li><li>从节点发送Ping信号，主节点返回Pong，两边能互相通信</li><li>口令认证，如果master设置了requirepass，那么slave node必须发送masterauth的口令过去认证</li><li>连接建立后，主节点第一次会进行全量复制(将所有数据发送给从节点)</li><li>主节点把当前的数据同步给从节点后，便完成了复制的建立过程。接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。</li></ol><h2 id="数据同步的过程"><a href="#数据同步的过程" class="headerlink" title="数据同步的过程"></a>数据同步的过程</h2><p>redis2.8之前使用sync [runId] [offset] 同步命令，redis2.8之后使用psync [runId] [offset] 命令。</p><p>两者不同在于，sync命令仅支持全量复制过程，psync支持全量和部分复制。介绍同步之前，先介绍几个概念：</p><ul><li><p>runId：每个redis节点启动都会生成唯一的uuid，每次redis重启后，runId都会发生变化。info server 可以看到master run id。如果只根据host+ip定位master node是不靠谱的。若发现slave node发送的同步请求中runId 不同，则触发全量复制，同步给slave node。如果需要不更改run id重启redis，可以使用redis-cli debug reload命令。</p></li><li><p>offset：主节点和从节点都各自维护自己的主从复制偏移量offset，当主节点有写入命令时，offset=offset+命令的字节长度。从节点在收到主节点发送的命令后，也会增加自己的offset，并把自己的offset发送给主节点。这样，<strong>主节点同时保存自己的offset和从节点的offset</strong>，通过对比offset来判断主从节点数据是否一致。</p></li><li><p>repl_backlog_size：保存在主节点上的一个固定长度的先进先出队列，默认大小是1MB。master node给slave node复制数据时，也会将数据在backlog中同步写一份。</p></li></ul><h3 id="psync的执行流程："><a href="#psync的执行流程：" class="headerlink" title="psync的执行流程："></a>psync的执行流程：</h3><p><img src="https://s2.ax1x.com/2019/12/28/leIvjJ.png" alt="leIvjJ.png"></p><p>从节点发送psync[runId][offset]命令，主节点有三种响应：</p><ul><li>FULLRESYNC：第一次连接，进行全量复制</li><li>CONTINUE：之后的连接，进行部分复制</li><li>ERR：不支持psync命令，进行全量复制</li></ul><blockquote><p>从节点第一次连接到主节点时，主节点会发送<strong>FULLRESYNC</strong> 进行全量复制，<strong>之后的每次复制都进行部分复制。</strong></p></blockquote><blockquote><p>主节点响应写命令时，<strong>不但会把命名发送给从节点，还会写入复制积压缓冲区</strong>，用于复制命令丢失的数据补救。</p></blockquote><h2 id="全量复制和部分复制"><a href="#全量复制和部分复制" class="headerlink" title="全量复制和部分复制"></a>全量复制和部分复制</h2><p><img src="https://s2.ax1x.com/2019/12/28/leoi4K.png" alt="leoi4K.png"></p><h3 id="全量复制的流程"><a href="#全量复制的流程" class="headerlink" title="全量复制的流程"></a>全量复制的流程</h3><ul><li><p>从节点发送psync ? -1命令（因为第一次发送，不知道主节点的runId，所以为?，因为是第一次复制，所以offset=-1）。</p></li><li><p>主节点发现从节点是第一次复制，返回FULLRESYNC {runId} {offset}，runId是主节点的runId，offset是主节点目前的offset。</p></li><li><p>从节点接收主节点信息后，保存到info中。</p></li><li><p>主节点在发送FULLRESYNC后，启动bgsave命令，生成RDB文件（数据持久化）。</p></li><li><p>主节点发送RDB文件给从节点，如果rdb复制事件超过60s(repl-timeout)，那么slave node就会认为复制失败，可以适当调大这个参数。</p></li><li><p>主节点在生成rdb时，会将所有新的写命令缓存在内存中，在从节点保存了rdb之后，再将新的写命令复制给从节点。</p></li><li><p><em>client-output-buffer-limit slave 256MB 64MB 60</em>，如果在复制期间，内存缓冲区持续消耗超过64MB，或者一次性超过256MB，那么停止复制，复制失败。</p></li><li><p>从节点收到rdb之后，清空自己的旧数据，然后重新加载RDB文件到内存中，同时基于旧的数据版本对外提供服务。</p></li><li><p>如果从节点开启了AOF，从节点会异步重写AOF文件。</p></li></ul><blockquote><p>如果复制的数据量在4G~6G之间，那么很可能全量复制时间消耗在1分半到2分钟。</p></blockquote><h3 id="部分复制-增量复制"><a href="#部分复制-增量复制" class="headerlink" title="部分复制(增量复制)"></a>部分复制(增量复制)</h3><ul><li><p>部分复制主要是Redis针对全量复制的过高开销做出的一种优化措施，使用psync [runId] [offset] 命令实现。当从节点正在复制主节点时，如果<strong>出现网络闪断或者命令丢失等</strong>异常情况时，<strong>从节点会向主节点要求补发丢失的命令数据</strong>，主节点的复制积压缓冲区（backlog）将这部分数据直接发送给从节点，这样就可以保持主从节点复制的一致性。补发的这部分数据一般远远小于全量数据。</p></li><li><p>主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内的复制积压缓冲区（backlog）依然可以保存最近一段时间的写命令数据。</p></li><li><p>当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行ID。因此会把它们当做psync参数发送给主节点，要求进行部分复制。</p></li><li><p>主节点接收到psync命令后首先核对参数runId是否与自身一致，如果一致，说明之前复制的是当前主节点；之后根据参数offset在复制积压缓冲区（backlog）中查找，如果offset之后的数据存在，则对从节点发送+CONTINUE命令，表示可以进行部分复制。因为缓冲区大小固定，若发生缓冲溢出，则进行全量复制。</p></li><li><p>主节点根据偏移量把复制积压缓冲区（backlog）里的数据发送给从节点，保证主从复制进入正常状态。</p></li></ul><h2 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h2><p>主从节点互相都会发送heartbeat信息  </p><p>master默认每隔10秒发送一次heartbeat，slave node每隔1秒发送一次heartbeat。</p><h2 id="主从复制断点续传"><a href="#主从复制断点续传" class="headerlink" title="主从复制断点续传"></a>主从复制断点续传</h2><p>从redis2.8开始，支持主从复制断点续传，如果主从复制过程中，网络连接断了，那么可以接着上次复制的地方，继续复制下去，而不是重新开始。</p><p>master node会在内存中创建一个backlog，master和slave都会保存一个replicate offset还有一个master id，offset就是保存在backlog中的。如果master和slave网络链接断掉了，slave会让master 从上次的replicat offset开始继续复制，如果没有找到对应的offset，那么就会执行一次resynchronization。</p><h2 id="无磁盘化复制"><a href="#无磁盘化复制" class="headerlink" title="无磁盘化复制"></a>无磁盘化复制</h2><p>master在内存中直接创建rdb，然后发送给slave，不会再自己本地落地磁盘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repl-diskless-sync</span><br><span class="line"># 等待一定时间在开始复制，因为要等更多的slave重新连接过来</span><br><span class="line">repl-diskless-sync-delay</span><br></pre></td></tr></table></figure><h2 id="过期Key"><a href="#过期Key" class="headerlink" title="过期Key"></a>过期Key</h2><p>slave 不存在过期key，智慧等待master过期key。如果master过期或者LRU淘汰了一个key，那么会模拟一个del命令发送给slave。</p><h2 id="主从复制会存在的问题"><a href="#主从复制会存在的问题" class="headerlink" title="主从复制会存在的问题"></a>主从复制会存在的问题</h2><ul><li><p>一旦主节点宕机，从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。</p></li><li><p>主节点的写能力受到单机的限制。</p></li><li><p>主节点的存储能力受到单机的限制。</p></li><li><p>原生复制的弊端在早期的版本中也会比较突出，比如：redis复制中断后，从节点会发起psync。此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时，可能会造成毫秒或秒级的卡顿。</p></li></ul><h3 id="比较主流的解决方案？"><a href="#比较主流的解决方案？" class="headerlink" title="比较主流的解决方案？"></a>比较主流的解决方案？</h3><p>哨兵。</p><hr><h1 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h1><p><img src="https://s2.ax1x.com/2019/12/28/leoXIP.png" alt="leoXIP.png"></p><p>如图，是Redis Sentinel（哨兵）的架构图。Redis Sentinel（哨兵）主要功能包括主节点存活检测、主从运行情况检测、自动故障转移、主从切换。Redis Sentinel最小配置是一主一从。</p><p>Redis的Sentinel系统可以用来管理多个Redis服务器，该系统可以执行以下四个任务：</p><ul><li><p>监控：不断检查主服务器和从服务器是否正常运行。</p></li><li><p>通知：当被监控的某个redis服务器出现问题，Sentinel通过API脚本向管理员或者其他应用程序发出通知。</p></li><li><p>自动故障转移：当主节点不能正常工作时，Sentinel会开始一次自动的故障转移操作，它会将与失效主节点是主从关系的其中一个从节点升级为新的主节点，并且将其他的从节点指向新的主节点，这样人工干预就可以免了。</p></li><li><p>配置提供者：在Redis Sentinel模式下，客户端应用在初始化时连接的是Sentinel节点集合，从中获取主节点的信息。</p></li></ul><h2 id="哨兵的工作原理"><a href="#哨兵的工作原理" class="headerlink" title="哨兵的工作原理"></a>哨兵的工作原理</h2><ol><li>每个Sentinel节点都需要定期执行以下任务：每个Sentinel以每秒一次的频率，向它所知的主服务器、从服务器以及其他的Sentinel实例发送一个PING命令。（如图）</li></ol><p><img src="https://s2.ax1x.com/2019/12/28/leTyJf.png" alt="leTyJf.png"></p><ol start="2"><li><p>如果一个实例距离最后一次有效回复PING命令的时间超过down-after-milliseconds所指定的值，那么这个实例会被Sentinel标记为主观下线。（如图）<br><img src="https://s2.ax1x.com/2019/12/28/leTBdI.png" alt="leTBdI.png"></p></li><li><p>如果一个主服务器被标记为主观下线，那么正在监视这个服务器的所有Sentinel节点，要以每秒一次的频率确认主服务器的确进入了主观下线状态。<br><img src="https://s2.ax1x.com/2019/12/28/leTsFP.png" alt="leTsFP.png"></p></li><li><p>如果一个主服务器被标记为主观下线，并且有足够数量的Sentinel（至少要达到配置文件指定的数量）在指定的时间范围内同意这一判断，那么这个主服务器被标记为客观下线。<br><img src="https://s2.ax1x.com/2019/12/28/le7Emd.png" alt="le7Emd.png"></p></li><li><p>一般情况下，每个Sentinel会以每10秒一次的频率向它已知的所有主服务器和从服务器发送INFO命令，当一个主服务器被标记为客观下线时，Sentinel向下线主服务器的所有从服务器发送INFO命令的频率，会从10秒一次改为每秒一次。<br><img src="https://s2.ax1x.com/2019/12/28/le7kOH.png" alt="le7kOH.png"></p></li><li><p>Sentinel和其他Sentinel协商客观下线的主节点的状态，如果处于SDOWN状态，则投票自动选出新的主节点，将剩余从节点指向新的主节点进行数据复制。<br><img src="https://s2.ax1x.com/2019/12/28/le7PSO.png" alt="le7PSO.png"></p></li><li><p>当没有足够数量的Sentinel同意主服务器下线时，主服务器的客观下线状态就会被移除。当主服务器重新向Sentinel的PING命令返回有效回复时，主服务器的主观下线状态就会被移除<br><img src="https://s2.ax1x.com/2019/12/28/le79fK.png" alt="le79fK.png"></p></li></ol><hr><h1 id="生产环境中redis是怎么部署的"><a href="#生产环境中redis是怎么部署的" class="headerlink" title="生产环境中redis是怎么部署的"></a>生产环境中redis是怎么部署的</h1><h2 id="机器什么配置"><a href="#机器什么配置" class="headerlink" title="机器什么配置"></a>机器什么配置</h2><p>32G内存 + 8核CPU + 1T磁盘。分配给redis是10g内存。(生产环境，redis内存尽量不超过10g)</p><h2 id="redis-cluster"><a href="#redis-cluster" class="headerlink" title="redis cluster"></a>redis cluster</h2><p>10台机器，5台机器部署了redis主实例，另外5台机器部署了redis的从实例，每个主实例挂了一个从实例，5个节点对外提供写服务，每个节点的读写高峰QPS可能达到每秒5万，5台机器最多是每秒25万读写请求。</p><p>高峰请求 3500请求/s.</p><p>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis从实例会自动变成主实例继续提供读写服务。</p><h2 id="内存中写的是什么数据？每条数据大小是多少？"><a href="#内存中写的是什么数据？每条数据大小是多少？" class="headerlink" title="内存中写的是什么数据？每条数据大小是多少？"></a>内存中写的是什么数据？每条数据大小是多少？</h2><p>商品数据，每条数据10kb.100条是1mb，10万条数据是1g。常驻内存是200万条数据，占用内存是20g，仅仅不到中内存的50%。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-是什么&quot;&gt;&lt;a href=&quot;#Redis-是什么&quot; class=&quot;headerlink&quot; title=&quot;Redis 是什么&quot;&gt;&lt;/a&gt;Redis 是什么&lt;/h1&gt;&lt;p&gt;Redis: REmote DIctionary Server(远程字典服务器)&lt;br&gt;完全开源免费，C语言编写遵守BSD协议，一个高性能的（key/value)分布式内存数据库。基于内存运行并支持持久化的NOSQL数据库被称为数据结构服务器。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://jelly54.github.io/categories/Redis/"/>
    
    
      <category term="缓存穿透" scheme="https://jelly54.github.io/tags/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/"/>
    
      <category term="缓存雪崩" scheme="https://jelly54.github.io/tags/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/"/>
    
      <category term="原理" scheme="https://jelly54.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="主从架构" scheme="https://jelly54.github.io/tags/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"/>
    
      <category term="redis" scheme="https://jelly54.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis为什么用跳表而不用平衡树？</title>
    <link href="https://jelly54.github.io/redis-skiplist-why/"/>
    <id>https://jelly54.github.io/redis-skiplist-why/</id>
    <published>2019-12-21T12:33:17.000Z</published>
    <updated>2020-08-27T11:05:52.291Z</updated>
    
    <content type="html"><![CDATA[<p>Redis里面使用skiplist是为了实现sorted set这种对外的数据结构。sorted set提供的操作非常丰富，可以满足非常多的应用场景。这也意味着，sorted set相对来说实现比较复杂。同时，skiplist这种数据结构对于很多人来说都比较陌生，因为大部分学校里的算法课都没有对这种数据结构进行过详细的介绍。因此，为了介绍得足够清楚，本文会比这个系列的其它几篇花费更多的篇幅。</p><a id="more"></a><p>我们将大体分成三个部分进行介绍：</p><ol><li>介绍经典的skiplist数据结构，并进行简单的算法分析。这一部分的介绍，与Redis没有直接关系。我会尝试尽量使用通俗易懂的语言进行描述。</li><li>讨论Redis里的skiplist的具体实现。为了支持sorted set本身的一些要求，在经典的skiplist基础上，Redis里的相应实现做了若干改动。</li><li>讨论sorted set是如何在skiplist, dict和ziplist基础上构建起来的。</li></ol><p>我们在讨论中还会涉及到两个Redis配置（在redis.conf中的ADVANCED CONFIG部分）：</p><pre><code>zset-max-ziplist-entries 128zset-max-ziplist-value 64</code></pre><p>我们在讨论中会详细解释这两个配置的含义。</p><p>注：本文讨论的代码实现基于Redis源码的3.2分支。</p><h1 id="skiplist数据结构简介"><a href="#skiplist数据结构简介" class="headerlink" title="skiplist数据结构简介"></a>skiplist数据结构简介</h1><p>skiplist本质上也是一种查找结构，用于解决算法中的查找问题（Searching），即根据给定的key，快速查到它所在的位置（或者对应的value）。</p><p>我们在《Redis内部数据结构详解》系列的<a href="http://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261203&idx=1&sn=f7ff61ce42e29b874a8026683875bbb1#rd" target="_blank" rel="noopener">第一篇</a>中介绍dict的时候，曾经讨论过：一般查找问题的解法分为两个大类：一个是基于各种平衡树，一个是基于哈希表。但skiplist却比较特殊，它没法归属到这两大类里面。</p><p>这种数据结构是由<a href="https://en.wikipedia.org/wiki/William_Pugh" target="_blank" rel="noopener">William Pugh</a>发明的，最早出现于他在1990年发表的论文《<a href="ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf" target="_blank" rel="noopener">Skip Lists: A Probabilistic Alternative to Balanced Trees</a>》。对细节感兴趣的同学可以下载论文原文来阅读。</p><p>skiplist，顾名思义，首先它是一个list。实际上，它是在有序链表的基础上发展起来的。</p><p>我们先来看一个有序链表，如下图（最左侧的灰色节点表示一个空的头结点）：</p><p><img src="https://lc-gold-cdn.xitu.io/659f5bec14ccd8d8c052.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>在这样一个链表中，如果我们要查找某个数据，那么需要从头开始逐个进行比较，直到找到包含数据的那个节点，或者找到第一个比给定数据大的节点为止（没找到）。也就是说，时间复杂度为O(n)。同样，当我们要插入新数据的时候，也要经历同样的查找过程，从而确定插入位置。</p><p>假如我们每相邻两个节点增加一个指针，让指针指向下下个节点，如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2016/11/29/a9648d8a8d71023a630eee04a57e2116?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一半（上图中是7, 19, 26）。现在当我们想查找数据的时候，可以先沿着这个新链表进行查找。当碰到比待查数据大的节点时，再回到原来的链表中进行查找。比如，我们想查找23，查找的路径是沿着下图中标红的指针所指向的方向进行的：</p><p><img src="https://lc-gold-cdn.xitu.io/1b1a48631a5325f03821.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><ul><li>23首先和7比较，再和19比较，比它们都大，继续向后比较。</li><li>但23和26比较的时候，比26要小，因此回到下面的链表（原链表），与22比较。</li><li>23比22要大，沿下面的指针继续向后和26比较。23比26小，说明待查数据23在原链表中不存在，而且它的插入位置应该在22和26之间。</li></ul><p>在这个查找过程中，由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了。需要比较的节点数大概只有原来的一半。</p><p>利用同样的方式，我们可以在上层新产生的链表上，继续为每相邻的两个节点增加一个指针，从而产生第三层链表。如下图：</p><p><img src="https://lc-gold-cdn.xitu.io/d88e4d282ec5981c207c.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>在这个新的三层链表结构上，如果我们还是查找23，那么沿着最上层链表首先要比较的是19，发现23比19大，接下来我们就知道只需要到19的后面去继续查找，从而一下子跳过了19前面的所有节点。可以想象，当链表足够长的时候，这种多层链表的查找方式能让我们跳过很多下层节点，大大加快查找的速度。</p><p>skiplist正是受这种多层链表的想法的启发而设计出来的。实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到O(log n)。但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。</p><p>skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个skiplist的过程：</p><p><img src="https://user-gold-cdn.xitu.io/2016/11/29/580b14b344513bbead4d1b188f94bb25?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>从上面skiplist的创建和插入过程可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点不会影响其它节点的层数。因此，插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。实际上，这是skiplist的一个很重要的特性，这让它在插入性能上明显优于平衡树的方案。这在后面我们还会提到。</p><p>根据上图中的skiplist结构，我们很容易理解这种数据结构的名字的由来。skiplist，翻译成中文，可以翻译成“跳表”或“跳跃表”，指的就是除了最下面第1层链表之外，它会产生若干层稀疏的链表，这些链表里面的指针故意跳过了一些节点（而且越高层的链表跳过的节点越多）。这就使得我们在查找数据的时候能够先在高层的链表中进行查找，然后逐层降低，最终降到第1层链表来精确地确定数据位置。在这个过程中，我们跳过了一些节点，从而也就加快了查找速度。</p><p>刚刚创建的这个skiplist总共包含4层链表，现在假设我们在它里面依然查找23，下图给出了查找路径：</p><p><img src="https://lc-gold-cdn.xitu.io/714264ea6eba7af0fe67.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>需要注意的是，前面演示的各个节点的插入过程，实际上在插入之前也要先经历一个类似的查找过程，在确定插入位置后，再完成插入操作。</p><p>至此，skiplist的查找和插入操作，我们已经很清楚了。而删除操作与插入操作类似，我们也很容易想象出来。这些操作我们也应该能很容易地用代码实现出来。</p><p>当然，实际应用中的skiplist每个节点应该包含key和value两部分。前面的描述中我们没有具体区分key和value，但实际上列表中是按照key进行排序的，查找过程也是根据key在比较。</p><p>但是，如果你是第一次接触skiplist，那么一定会产生一个疑问：节点插入时随机出一个层数，仅仅依靠这样一个简单的随机数操作而构建出来的多层链表结构，能保证它有一个良好的查找性能吗？为了回答这个疑问，我们需要分析skiplist的统计性能。</p><p>在分析之前，我们还需要着重指出的是，执行插入操作时计算随机数的过程，是一个很关键的过程，它对skiplist的统计特性有着很重要的影响。这并不是一个普通的服从均匀分布的随机数，它的计算过程如下：</p><ul><li>首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）。</li><li>如果一个节点有第i层(i&gt;=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p。</li><li>节点最大的层数不允许超过一个最大值，记为MaxLevel。</li></ul><p>这个计算随机层数的伪码如下所示：</p><pre><code>randomLevel()    level := 1    // random()返回一个[0...1)的随机数    while random() &lt; p and level &lt; MaxLevel do        level := level + 1    return level复制代码</code></pre><p>randomLevel()的伪码中包含两个参数，一个是p，一个是MaxLevel。在Redis的skiplist实现中，这两个参数的取值为：</p><pre><code>p = 1/4MaxLevel = 32复制代码</code></pre><h1 id="skiplist的算法性能分析"><a href="#skiplist的算法性能分析" class="headerlink" title="skiplist的算法性能分析"></a>skiplist的算法性能分析</h1><p>在这一部分，我们来简单分析一下skiplist的时间复杂度和空间复杂度，以便对于skiplist的性能有一个直观的了解。如果你不是特别偏执于算法的性能分析，那么可以暂时跳过这一小节的内容。</p><p>我们先来计算一下每个节点所包含的平均指针数目（概率期望）。节点包含的指针数目，相当于这个算法在空间上的额外开销(overhead)，可以用来度量空间复杂度。</p><p>根据前面randomLevel()的伪码，我们很容易看出，产生越高的节点层数，概率越低。定量的分析如下：</p><ul><li>节点层数至少为1。而大于1的节点层数，满足一个概率分布。</li><li>节点层数恰好等于1的概率为1-p。</li><li>节点层数大于等于2的概率为p，而节点层数恰好等于2的概率为p(1-p)。</li><li>节点层数大于等于3的概率为p2，而节点层数恰好等于3的概率为p2(1-p)。</li><li>节点层数大于等于4的概率为p3，而节点层数恰好等于4的概率为p3(1-p)。</li><li>……</li></ul><p>因此，一个节点的平均层数（也即包含的平均指针数目），计算如下：</p><p><img src="https://lc-gold-cdn.xitu.io/7b78ead5c11087fd6948.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>现在很容易计算出：</p><ul><li>当p=1/2时，每个节点所包含的平均指针数目为2；</li><li>当p=1/4时，每个节点所包含的平均指针数目为1.33。这也是Redis里的skiplist实现在空间上的开销。</li></ul><p>接下来，为了分析时间复杂度，我们计算一下skiplist的平均查找长度。查找长度指的是查找路径上跨越的跳数，而查找过程中的比较次数就等于查找长度加1。以前面图中标出的查找23的查找路径为例，从左上角的头结点开始，一直到结点22，查找长度为6。</p><p>为了计算查找长度，这里我们需要利用一点小技巧。我们注意到，每个节点插入的时候，它的层数是由随机函数randomLevel()计算出来的，而且随机的计算不依赖于其它节点，每次插入过程都是完全独立的。所以，从统计上来说，一个skiplist结构的形成与节点的插入顺序无关。</p><p>这样的话，为了计算查找长度，我们可以将查找过程倒过来看，从右下方第1层上最后到达的那个节点开始，沿着查找路径向左向上回溯，类似于爬楼梯的过程。我们假设当回溯到某个节点的时候，它才被插入，这虽然相当于改变了节点的插入顺序，但从统计上不影响整个skiplist的形成结构。</p><p>现在假设我们从一个层数为i的节点x出发，需要向左向上攀爬k层。这时我们有两种可能：</p><ul><li>如果节点x有第(i+1)层指针，那么我们需要向上走。这种情况概率为p。</li><li>如果节点x没有第(i+1)层指针，那么我们需要向左走。这种情况概率为(1-p)。</li></ul><p>这两种情形如下图所示：</p><p><img src="https://lc-gold-cdn.xitu.io/427df004e806f2bd3fdf.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>用C(k)表示向上攀爬k个层级所需要走过的平均查找路径长度（概率期望），那么：</p><pre><code>C(0)=0C(k)=(1-p)×(上图中情况b的查找长度) + p×(上图中情况c的查找长度)</code></pre><p>代入，得到一个差分方程并化简：</p><pre><code>C(k)=(1-p)(C(k)+1) + p(C(k-1)+1)C(k)=1/p+C(k-1)C(k)=k/p</code></pre><p>这个结果的意思是，我们每爬升1个层级，需要在查找路径上走1/p步。而我们总共需要攀爬的层级数等于整个skiplist的总层数-1。</p><p>那么接下来我们需要分析一下当skiplist中有n个节点的时候，它的总层数的概率均值是多少。这个问题直观上比较好理解。根据节点的层数随机算法，容易得出：</p><ul><li>第1层链表固定有n个节点；</li><li>第2层链表平均有n*p个节点；</li><li>第3层链表平均有n*p2个节点；</li><li>…</li></ul><p>所以，从第1层到最高层，各层链表的平均节点数是一个指数递减的等比数列。容易推算出，总层数的均值为log1/pn，而最高层的平均节点数为1/p。</p><p>综上，粗略来计算的话，平均查找长度约等于：</p><pre><code>C(log1/pn-1)=(log1/pn-1)/p</code></pre><p>即，<strong>平均时间复杂度为O(log n)</strong>。</p><p>当然，这里的时间复杂度分析还是比较粗略的。比如，沿着查找路径向左向上回溯的时候，可能先到达左侧头结点，然后沿头结点一路向上；还可能先到达最高层的节点，然后沿着最高层链表一路向左。但这些细节不影响平均时间复杂度的最后结果。另外，这里给出的时间复杂度只是一个概率平均值，但实际上计算一个精细的概率分布也是有可能的。详情还请参见<a href="https://en.wikipedia.org/wiki/William_Pugh" target="_blank" rel="noopener">William Pugh</a>的论文《<a href="ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf" target="_blank" rel="noopener">Skip Lists: A Probabilistic Alternative to Balanced Trees</a>》。</p><h1 id="skiplist与平衡树、哈希表的比较"><a href="#skiplist与平衡树、哈希表的比较" class="headerlink" title="skiplist与平衡树、哈希表的比较"></a>skiplist与平衡树、哈希表的比较</h1><ul><li>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</li><li>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</li><li>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li><li>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</li><li>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</li><li>从算法实现难度上来比较，skiplist比平衡树要简单得多。</li></ul><h1 id="Redis中的skiplist实现"><a href="#Redis中的skiplist实现" class="headerlink" title="Redis中的skiplist实现"></a>Redis中的skiplist实现</h1><p>在这一部分，我们讨论Redis中的skiplist实现。</p><p>在Redis中，skiplist被用于实现暴露给外部的一个数据结构：sorted set。准确地说，sorted set底层不仅仅使用了skiplist，还使用了ziplist和dict。这几个数据结构的关系，我们下一章再讨论。现在，我们先花点时间把sorted set的关键命令看一下。这些命令对于Redis里skiplist的实现，有重要的影响。</p><h2 id="sorted-set的命令举例"><a href="#sorted-set的命令举例" class="headerlink" title="sorted set的命令举例"></a>sorted set的命令举例</h2><p>sorted set是一个有序的数据集合，对于像类似排行榜这样的应用场景特别适合。</p><p>现在我们来看一个例子，用sorted set来存储代数课（algebra）的成绩表。原始数据如下：</p><ul><li>Alice 87.5</li><li>Bob 89.0</li><li>Charles 65.5</li><li>David 78.0</li><li>Emily 93.5</li><li>Fred 87.5</li></ul><p>这份数据给出了每位同学的名字和分数。下面我们将这份数据存储到sorted set里面去：</p><p><img src="https://user-gold-cdn.xitu.io/2016/11/29/821bbbf6fe2c4653bfcd4300cfa09e56?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>对于上面的这些命令，我们需要的注意的地方包括：</p><ul><li>前面的6个zadd命令，将6位同学的名字和分数(score)都输入到一个key值为algebra的sorted set里面了。注意Alice和Fred的分数相同，都是87.5分。</li><li>zrevrank命令查询Alice的排名（命令中的rev表示按照倒序排列，也就是从大到小），返回3。排在Alice前面的分别是Emily、Bob、Fred，而排名(rank)从0开始计数，所以Alice的排名是3。注意，其实Alice和Fred的分数相同，这种情况下sorted set会把分数相同的元素，按照字典顺序来排列。按照倒序，Fred排在了Alice的前面。</li><li>zscore命令查询了Charles对应的分数。</li><li>zrevrange命令查询了从大到小排名为0~3的4位同学。</li><li>zrevrangebyscore命令查询了分数在80.0和90.0之间的所有同学，并按分数从大到小排列。</li></ul><p>总结一下，sorted set中的每个元素主要表现出3个属性：</p><ul><li>数据本身（在前面的例子中我们把名字存成了数据）。</li><li>每个数据对应一个分数(score)。</li><li>根据分数大小和数据本身的字典排序，每个数据会产生一个排名(rank)。可以按正序或倒序。</li></ul><h2 id="Redis中skiplist实现的特殊性"><a href="#Redis中skiplist实现的特殊性" class="headerlink" title="Redis中skiplist实现的特殊性"></a>Redis中skiplist实现的特殊性</h2><p>我们简单分析一下前面出现的几个查询命令：</p><ul><li>zrevrank由数据查询它对应的排名，这在前面介绍的skiplist中并不支持。</li><li>zscore由数据查询它对应的分数，这也不是skiplist所支持的。</li><li>zrevrange根据一个排名范围，查询排名在这个范围内的数据。这在前面介绍的skiplist中也不支持。</li><li>zrevrangebyscore根据分数区间查询数据集合，是一个skiplist所支持的典型的范围查找（score相当于key）。</li></ul><p>实际上，Redis中sorted set的实现是这样的：</p><ul><li>当数据较少时，sorted set是由一个ziplist来实现的。</li><li>当数据多的时候，sorted set是由一个dict + 一个skiplist来实现的。简单来讲，dict用来查询数据到分数的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。</li></ul><p>这里sorted set的构成我们在下一章还会再详细地讨论。现在我们集中精力来看一下sorted set与skiplist的关系，：</p><ul><li>zscore的查询，不是由skiplist来提供的，而是由那个dict来提供的。</li><li>为了支持排名(rank)，Redis里对skiplist做了扩展，使得根据排名能够快速查到数据，或者根据分数查到数据之后，也同时很容易获得排名。而且，根据排名的查找，时间复杂度也为O(log n)。</li><li>zrevrange的查询，是根据排名查数据，由扩展后的skiplist来提供。</li><li>zrevrank是先在dict中由数据查到分数，再拿分数到skiplist中去查找，查到后也同时获得了排名。</li></ul><p>前述的查询过程，也暗示了各个操作的时间复杂度：</p><ul><li>zscore只用查询一个dict，所以时间复杂度为O(1)</li><li>zrevrank, zrevrange, zrevrangebyscore由于要查询skiplist，所以zrevrank的时间复杂度为O(log n)，而zrevrange, zrevrangebyscore的时间复杂度为O(log(n)+M)，其中M是当前查询返回的元素个数。</li></ul><p>总结起来，Redis中的skiplist跟前面介绍的经典的skiplist相比，有如下不同：</p><ul><li>分数(score)允许重复，即skiplist的key允许重复。这在最开始介绍的经典skiplist中是不允许的。</li><li>在比较时，不仅比较分数（相当于skiplist的key），还比较数据本身。在Redis的skiplist实现中，数据本身的内容唯一标识这份数据，而不是由key来唯一标识。另外，当多个元素分数相同的时候，还需要根据数据内容来进字典排序。</li><li>第1层链表不是一个单向链表，而是一个双向链表。这是为了方便以倒序方式获取一个范围内的元素。</li><li>在skiplist中可以很方便地计算出每个元素的排名(rank)。</li></ul><h2 id="skiplist的数据结构定义"><a href="#skiplist的数据结构定义" class="headerlink" title="skiplist的数据结构定义"></a>skiplist的数据结构定义</h2><pre><code>#define ZSKIPLIST_MAXLEVEL 32#define ZSKIPLIST_P 0.25typedef struct zskiplistNode {    robj *obj;    double score;    struct zskiplistNode *backward;    struct zskiplistLevel {        struct zskiplistNode *forward;        unsigned int span;    } level[];} zskiplistNode;typedef struct zskiplist {    struct zskiplistNode *header, *tail;    unsigned long length;    int level;} zskiplist;</code></pre><p>这段代码出自server.h，我们来简要分析一下：</p><ul><li>开头定义了两个常量，ZSKIPLIST_MAXLEVEL和ZSKIPLIST_P，分别对应我们前面讲到的skiplist的两个参数：一个是MaxLevel，一个是p。</li><li>zskiplistNode定义了skiplist的节点结构。<ul><li>obj字段存放的是节点数据，它的类型是一个string robj。本来一个string robj可能存放的不是sds，而是long型，但zadd命令在将数据插入到skiplist里面之前先进行了解码，所以这里的obj字段里存储的一定是一个sds。有关robj的详情可以参见系列文章的第三篇：《<a href="http://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261237&idx=1&sn=380d183332d41d24ea6f88a54f533fc3#rd" target="_blank" rel="noopener">Redis内部数据结构详解(3)——robj</a>》。这样做的目的应该是为了方便在查找的时候对数据进行字典序的比较，而且，skiplist里的数据部分是数字的可能性也比较小。</li><li>score字段是数据对应的分数。</li><li>backward字段是指向链表前一个节点的指针（前向指针）。节点只有1个前向指针，所以只有第1层链表是一个双向链表。</li><li>level[]存放指向各层链表后一个节点的指针（后向指针）。每层对应1个后向指针，用forward字段表示。另外，每个后向指针还对应了一个span值，它表示当前的指针跨越了多少个节点。span用于计算元素排名(rank)，这正是前面我们提到的Redis对于skiplist所做的一个扩展。需要注意的是，level[]是一个柔性数组（<a href="https://en.wikipedia.org/wiki/Flexible_array_member" target="_blank" rel="noopener">flexible array member</a>），因此它占用的内存不在zskiplistNode结构里面，而需要插入节点的时候单独为它分配。也正因为如此，skiplist的每个节点所包含的指针数目才是不固定的，我们前面分析过的结论——skiplist每个节点包含的指针数目平均为1/(1-p)——才能有意义。</li></ul></li><li>zskiplist定义了真正的skiplist结构，它包含：<ul><li>头指针header和尾指针tail。</li><li>链表长度length，即链表包含的节点总数。注意，新创建的skiplist包含一个空的头指针，这个头指针不包含在length计数中。</li><li>level表示skiplist的总层数，即所有节点层数的最大值。</li></ul></li></ul><p>下图以前面插入的代数课成绩表为例，展示了Redis中一个skiplist的可能结构：</p><p><img src="https://lc-gold-cdn.xitu.io/5dacfcd1ef6f521fe0b3.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>注意：图中前向指针上面括号中的数字，表示对应的span的值。即当前指针跨越了多少个节点，这个计数不包括指针的起点节点，但包括指针的终点节点。</p><p>假设我们在这个skiplist中查找score=89.0的元素（即Bob的成绩数据），在查找路径中，我们会跨域图中标红的指针，这些指针上面的span值累加起来，就得到了Bob的排名(2+2+1)-1=4（减1是因为rank值以0起始）。需要注意这里算的是从小到大的排名，而如果要算从大到小的排名，只需要用skiplist长度减去查找路径上的span累加值，即6-(2+2+1)=1。</p><p>可见，在查找skiplist的过程中，通过累加span值的方式，我们就能很容易算出排名。相反，如果指定排名来查找数据（类似zrange和zrevrange那样），也可以不断累加span并时刻保持累加值不超过指定的排名，通过这种方式就能得到一条O(log n)的查找路径。</p><h1 id="Redis中的sorted-set"><a href="#Redis中的sorted-set" class="headerlink" title="Redis中的sorted set"></a>Redis中的sorted set</h1><p>我们前面提到过，Redis中的sorted set，是在skiplist, dict和ziplist基础上构建起来的:</p><ul><li>当数据较少时，sorted set是由一个ziplist来实现的。</li><li>当数据多的时候，sorted set是由一个叫zset的数据结构来实现的，这个zset包含一个dict + 一个skiplist。dict用来查询数据到分数(score)的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。</li></ul><p>在这里我们先来讨论一下前一种情况——基于ziplist实现的sorted set。在本系列前面<a href="http://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261265&idx=1&sn=e105c4b86a5640c5fc8212cd824f750b#rd" target="_blank" rel="noopener">关于ziplist的文章</a>里，我们介绍过，ziplist就是由很多数据项组成的一大块连续内存。由于sorted set的每一项元素都由数据和score组成，因此，当使用zadd命令插入一个(数据, score)对的时候，底层在相应的ziplist上就插入两个数据项：数据在前，score在后。</p><p>ziplist的主要优点是节省内存，但它上面的查找操作只能按顺序查找（可以正序也可以倒序）。因此，sorted set的各个查询操作，就是在ziplist上从前向后（或从后向前）一步步查找，每一步前进两个数据项，跨域一个(数据, score)对。</p><p>随着数据的插入，sorted set底层的这个ziplist就可能会转成zset的实现（转换过程详见t_zset.c的zsetConvert）。那么到底插入多少才会转呢？</p><p>还记得本文开头提到的两个Redis配置吗？</p><pre><code>zset-max-ziplist-entries 128zset-max-ziplist-value 64</code></pre><p>这个配置的意思是说，在如下两个条件之一满足的时候，ziplist会转成zset（具体的触发条件参见t_zset.c中的zaddGenericCommand相关代码）：</p><ul><li>当sorted set中的元素个数，即(数据, score)对的数目超过128的时候，也就是ziplist数据项超过256的时候。</li><li>当sorted set中插入的任意一个数据的长度超过了64的时候。</li></ul><p>最后，zset结构的代码定义如下：</p><pre><code>typedef struct zset {    dict *dict;    zskiplist *zsl;} zset;</code></pre><h1 id="Redis为什么用skiplist而不用平衡树？"><a href="#Redis为什么用skiplist而不用平衡树？" class="headerlink" title="Redis为什么用skiplist而不用平衡树？"></a>Redis为什么用skiplist而不用平衡树？</h1><p>在前面我们对于skiplist和平衡树、哈希表的比较中，其实已经不难看出Redis里使用skiplist而不用平衡树的原因了。现在我们看看，对于这个问题，Redis的作者 @antirez 是怎么说的：</p><blockquote><p>There are a few reasons:</p><p>1) They are not very memory intensive. It’s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.</p><p>2) A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.</p><p>3) They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.</p></blockquote><p>这段话原文出处：</p><blockquote><p><a href="https://news.ycombinator.com/item?id=1171423" target="_blank" rel="noopener">news.ycombinator.com/item?id=117…</a></p></blockquote><p>这里从内存占用、对范围查找的支持和实现难易程度这三方面总结的原因，我们在前面其实也都涉及到了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis里面使用skiplist是为了实现sorted set这种对外的数据结构。sorted set提供的操作非常丰富，可以满足非常多的应用场景。这也意味着，sorted set相对来说实现比较复杂。同时，skiplist这种数据结构对于很多人来说都比较陌生，因为大部分学校里的算法课都没有对这种数据结构进行过详细的介绍。因此，为了介绍得足够清楚，本文会比这个系列的其它几篇花费更多的篇幅。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://jelly54.github.io/categories/Redis/"/>
    
    
      <category term="数据结构" scheme="https://jelly54.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="redis" scheme="https://jelly54.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis集群搭建</title>
    <link href="https://jelly54.github.io/redis-cluster/"/>
    <id>https://jelly54.github.io/redis-cluster/</id>
    <published>2019-12-21T11:33:55.000Z</published>
    <updated>2020-08-27T11:05:52.290Z</updated>
    
    <content type="html"><![CDATA[<p>手把手教你搭建一个redis集群</p><a id="more"></a><h2 id="脚本部署"><a href="#脚本部署" class="headerlink" title="脚本部署"></a>脚本部署</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash </span><br><span class="line"># auto start redis program</span><br><span class="line">mkdir /usr/local/redis</span><br><span class="line">cd /usr/local/redis</span><br><span class="line">tar -zxvf /redis-5.0.4.tar.gz</span><br><span class="line">cd redis-5.0.4/src</span><br><span class="line"># 编译</span><br><span class="line">make </span><br><span class="line">make MALLOC=libc</span><br><span class="line"># 让端口可用</span><br><span class="line">firewall-cmd --add-port=16379/tcp --permanent</span><br><span class="line">firewall-cmd --add-port=6379/tcp --permanent</span><br><span class="line">mkdir /usr/local/redis/data</span><br><span class="line"># 把redis。conf配置文件复制到src文件夹下</span><br><span class="line">cp /usr/local/redis/redis-5.0.4/redis.conf /usr/local/redis/redis-5.0.4/src </span><br><span class="line">mkdir /usr/local/redis/log</span><br><span class="line"># 修改日志文档</span><br><span class="line">sed -i &apos;s/logfile &quot;&quot;/logfile \/usr\/local\/redis\/log\/redis.log/g&apos; redis.conf     </span><br><span class="line">#  redis在后台运行</span><br><span class="line">sed -i &apos;s/daemonize no/daemonize yes/g&apos; redis.conf</span><br><span class="line"># 修改bind的ip地址</span><br><span class="line">sed -i &apos;s/bind 127.0.0.1/bind 0.0.0.0/g&apos; redis.conf </span><br><span class="line"># 设定开始故障转移的时间</span><br><span class="line">sed -i &apos;s/# cluster-node-timeout 15000/cluster-node-timeout 15000/g&apos; redis.conf</span><br><span class="line"># 判断是否有故障转移的资格</span><br><span class="line">sed -i &apos;s/# cluster-replica-validity-factor 10/cluster-replica-validity-factor 10/g&apos; redis.conf</span><br><span class="line">#  确定故障转移需要几个节点</span><br><span class="line">sed -i &apos;s/# cluster-migration-barrier 1/cluster-migration-barrier 1/g&apos; redis.conf</span><br><span class="line"># 修改dir文件目录</span><br><span class="line">sed -i &apos;s/dir .\//dir \/usr\/local\/redis\/data/g&apos; redis.conf</span><br><span class="line"># 开启集群模式</span><br><span class="line">sed -i &apos;s/# cluster-enabled yes/cluster-enabled yes/g&apos; redis.conf</span><br><span class="line"># 启动redis服务</span><br><span class="line">/usr/local/redis/redis-5.0.4/src/redis-server /usr/local/redis/redis-5.0.4/src/redis.conf</span><br><span class="line">#集群搭建</span><br><span class="line">/usr/local/redis/redis-5.0.4/src/redis-cli --cluster create 192.100.3.90:6379 192.100.3.91:6379 192.100.3.92:6379 --cluster-replicas 0</span><br></pre></td></tr></table></figure><h2 id="docker部署"><a href="#docker部署" class="headerlink" title="docker部署"></a>docker部署</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#拉取镜像</span><br><span class="line">docker pull redis:5.0.2</span><br><span class="line">#创建容器</span><br><span class="line">docker create --name redis-node01 --net host -v /data/redis-data/node01:/data</span><br><span class="line">redis:5.0.2 --cluster-enabled yes --cluster-config-file nodes-node-01.conf --port</span><br><span class="line">6379</span><br><span class="line">docker create --name redis-node02 --net host -v /data/redis-data/node02:/data</span><br><span class="line">redis:5.0.2 --cluster-enabled yes --cluster-config-file nodes-node-02.conf --port</span><br><span class="line">6380</span><br><span class="line">docker create --name redis-node03 --net host -v /data/redis-data/node03:/data</span><br><span class="line">redis:5.0.2 --cluster-enabled yes --cluster-config-file nodes-node-03.conf --port</span><br><span class="line">6381</span><br><span class="line">#启动容器</span><br><span class="line">docker start redis-node01 redis-node02 redis-node03</span><br><span class="line">#进入redis-node01容器进行操作</span><br><span class="line">docker exec -it redis-node01 /bin/bash</span><br><span class="line">#172.16.55.185是主机的ip地址</span><br><span class="line">redis-cli --cluster create 172.16.55.185:6379 172.16.55.185:6380 172.16.55.185:6381</span><br><span class="line">--cluster-replicas 0</span><br></pre></td></tr></table></figure><h1 id="Redis5-高可用集群"><a href="#Redis5-高可用集群" class="headerlink" title="Redis5 高可用集群"></a>Redis5 高可用集群</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HA(High Available，高可用性群集)机集群系统简称，是保证业务连续性的有效解决方案，一般有两个或两个以上的节点，且分为活动节点及备用节点。通常把正在执 行业务的称为活动节点，而作为活动节点的一个备份的则称为备用节点。当活动节点出现问题，导致正在运行的业务（任务）不能正常运行时，备用节点此时就会侦测到，并立即接续活动节点来执行业务。从而实现业务的不中断或短暂中断。</p><p>Redis 一般以主/从方式部署（这里讨论的应用从实例主要用于备份，主实例提供读写）该方式要实现 HA 主要有如下几种方案：</p><ul><li><strong>keepalived：</strong> 通过 keepalived 的虚拟 IP，提供主从的统一访问，在主出现问题时， 通过 keepalived 运行脚本将从提升为主，待主恢复后先同步后自动变为主，该方案的好处是主从切换后，应用程序不需要知道(因为访问的虚拟 IP 不变)，坏处是引入 keepalived 增加部署复杂性，在有些情况下会导致数据丢失</li><li><strong>zookeeper：</strong> 通过 zookeeper 来监控主从实例， 维护最新有效的 IP， 应用通过 zookeeper 取得 IP，对 Redis 进行访问，该方案需要编写大量的监控代码</li><li><strong>sentinel：</strong> 通过 Sentinel 监控主从实例，自动进行故障恢复，该方案有个缺陷：因为主从实例地址( IP &amp; PORT )是不同的，当故障发生进行主从切换后，应用程序无法知道新地址，故在 Jedis2.2.2 中新增了对 Sentinel 的支持，应用通过 <code>redis.clients.jedis.JedisSentinelPool.getResource()</code> 取得的 Jedis 实例会及时更新到新的主实例地址</li></ul><p><img src="http://www.qfdmy.com/wp-content/uploads/2019/09/264650839c34e8a.png" alt="img"></p><p><strong>注意：</strong> sentinel 是解决 HA 问题的，cluster 是解决主从复制问题的，不重复，并且经常一起用</p><h2 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis Sentinel"></a>Redis Sentinel</h2><p>Redis 集群可以在一组 redis 节点之间实现高可用性和 sharding。在集群中会有 1 个 master 和多个 slave 节点。当 master 节点失效时，应选举出一个 slave 节点作为新的 master。然而 Redis 本身 (包括它的很多客户端) 没有实现自动故障发现并进行主备切换的能力，需要外部的监控方案来实现自动故障恢复。</p><p>Redis Sentinel 是官方推荐的高可用性解决方案。它是 Redis 集群的监控管理工具，可以提供节点监控、通知、自动故障恢复和客户端配置发现服务。</p><p><img src="http://www.qfdmy.com/wp-content/uploads/2019/09/db9cb6dd1d9defc.jpg" alt="img"></p><h2 id="基于-Docker-安装-Redis-集群"><a href="#基于-Docker-安装-Redis-集群" class="headerlink" title="基于 Docker 安装 Redis 集群"></a>基于 Docker 安装 Redis 集群</h2><p>2018 年 10 月 Redis 发布了稳定版本的 5.0 版本，推出了各种新特性，其中一点是放弃 Ruby 的集群方式，改为 使用 C 语言编写的 <code>redis-cli</code> 的方式，使集群的构建方式复杂度大大降低</p><h3 id="下载所需镜像"><a href="#下载所需镜像" class="headerlink" title="下载所需镜像"></a>下载所需镜像</h3><ul><li>Redis (5.x 测试有效)：<code>docker pull redis</code></li><li>Redis Trib (用于创建集群)：<code>docker pull zvelo/redis-trib</code></li></ul><h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><p>官方配置文件地址：<a href="http://www.qfdmy.com/wp-content/themes/quanbaike/go.php?url=aHR0cDovL2Rvd25sb2FkLnJlZGlzLmlvL3JlZGlzLXN0YWJsZS9yZWRpcy5jb25m" target="_blank" rel="noopener">http://download.redis.io/redis-stable/redis.conf</a> ，我们部署 3 个节点，需要分别创建 3 个配置文件，路径如下</p><ul><li>renode1：<code>cluster/node1/redis.conf</code></li><li>renode2：<code>cluster/node2/redis.conf</code></li><li>renode3：<code>cluster/node3/redis.conf</code></li></ul><p>配置文件内容如下 (<strong>端口号不要重复</strong>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line"># 关闭保护模式</span><br><span class="line">protected-mode no</span><br><span class="line"># 绑定自定义端口</span><br><span class="line">port 6379</span><br><span class="line"># 禁止 Redis 后台运行</span><br><span class="line"># daemonize yes</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line"># 开启集群</span><br><span class="line">cluster-enabled yes</span><br><span class="line"># 集群的配置，配置文件首次启动自动生成</span><br><span class="line">cluster-config-file nodes_6379.conf</span><br><span class="line"># 开启 AOF</span><br><span class="line"># appendonly yes</span><br><span class="line"># 集群的 IP</span><br><span class="line">cluster-announce-ip 192.168.x.x</span><br><span class="line"># 集群的端口</span><br><span class="line">cluster-announce-port 6379</span><br><span class="line"># 集群的总线端口</span><br><span class="line">cluster-announce-bus-port 16379</span><br></pre></td></tr></table></figure><h3 id="创建资源配置"><a href="#创建资源配置" class="headerlink" title="创建资源配置"></a>创建资源配置</h3><p><code>docker-compose.yml</code> 配置文件如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;3.1&apos;</span><br><span class="line">services:</span><br><span class="line">  renode1:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: renode1</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 6379:6379</span><br><span class="line">      - 16379:16379</span><br><span class="line">    volumes:</span><br><span class="line">      - ./cluster/node1:/usr/local/etc/redis</span><br><span class="line">    command:</span><br><span class="line">      redis-server /usr/local/etc/redis/redis.conf</span><br><span class="line">  renode2:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: renode2</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 6380:6380</span><br><span class="line">      - 16380:16380</span><br><span class="line">    volumes:</span><br><span class="line">      - ./cluster/node2:/usr/local/etc/redis</span><br><span class="line">    command:</span><br><span class="line">      redis-server /usr/local/etc/redis/redis.conf</span><br><span class="line">  renode3:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: renode3</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 6381:6381</span><br><span class="line">      - 16381:16381</span><br><span class="line">    volumes:</span><br><span class="line">      - ./cluster/node3:/usr/local/etc/redis</span><br><span class="line">    command:</span><br><span class="line">      redis-server /usr/local/etc/redis/redis.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -it zvelo/redis-trib create 192.168.141.220:6379 192.168.141.220:6380 192.168.141.220:6381</span><br><span class="line"># 输出如下</span><br><span class="line">&gt;&gt;&gt; Creating cluster</span><br><span class="line">&gt;&gt;&gt; Performing hash slots allocation on 3 nodes...</span><br><span class="line">Using 3 masters:</span><br><span class="line">192.168.141.220:6379</span><br><span class="line">192.168.141.220:6380</span><br><span class="line">192.168.141.220:6381</span><br><span class="line">M: 9250c85592b7bb8a19636b90e4cf22590bd3334f 192.168.141.220:6379</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">M: 7373de7b44ee50a1e4f653bfba1bb808138e7e3a 192.168.141.220:6380</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">M: ec7e6e4cdd142249e3aa83541044932655d75b66 192.168.141.220:6381</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">Can I set the above configuration? (type &apos;yes&apos; to accept): yes</span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting for the cluster to join..</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.141.220:6379)</span><br><span class="line">M: 9250c85592b7bb8a19636b90e4cf22590bd3334f 192.168.141.220:6379</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">M: 7373de7b44ee50a1e4f653bfba1bb808138e7e3a 192.168.141.220:6380</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">M: ec7e6e4cdd142249e3aa83541044932655d75b66 192.168.141.220:6381</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><h3 id="验证集群是否成功"><a href="#验证集群是否成功" class="headerlink" title="验证集群是否成功"></a>验证集群是否成功</h3><ul><li>交互式进入容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it renode1 /bin/bash</span><br></pre></td></tr></table></figure><ul><li>登录 Redis</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379</span><br></pre></td></tr></table></figure><ul><li>查看集群信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; cluster info</span><br><span class="line"># 输出如下</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:3</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:3</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:860</span><br><span class="line">cluster_stats_messages_pong_sent:870</span><br><span class="line">cluster_stats_messages_sent:1730</span><br><span class="line">cluster_stats_messages_ping_received:868</span><br><span class="line">cluster_stats_messages_pong_received:860</span><br><span class="line">cluster_stats_messages_meet_received:2</span><br><span class="line">cluster_stats_messages_received:1730</span><br></pre></td></tr></table></figure><ul><li>查看集群节点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; cluster nodes</span><br><span class="line"># 输出如下</span><br><span class="line">ec7e6e4cdd142249e3aa83541044932655d75b66 192.168.141.220:6381@16381 master - 0 1569665070102 3 connected 10923-16383</span><br><span class="line">7373de7b44ee50a1e4f653bfba1bb808138e7e3a 192.168.141.220:6380@16380 master - 0 1569665069094 2 connected 5461-10922</span><br><span class="line">9250c85592b7bb8a19636b90e4cf22590bd3334f 192.168.141.220:6379@16379 myself,master - 0 1569665069000 1 connected 0-5460</span><br></pre></td></tr></table></figure><ul><li>查看集群插槽</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">27.0.0.1:6379&gt; cluster slots</span><br><span class="line"># 输出如下</span><br><span class="line">1) 1) (integer) 10923</span><br><span class="line">   2) (integer) 16383</span><br><span class="line">   3) 1) &quot;192.168.141.220&quot;</span><br><span class="line">      2) (integer) 6381</span><br><span class="line">      3) &quot;ec7e6e4cdd142249e3aa83541044932655d75b66&quot;</span><br><span class="line">2) 1) (integer) 5461</span><br><span class="line">   2) (integer) 10922</span><br><span class="line">   3) 1) &quot;192.168.141.220&quot;</span><br><span class="line">      2) (integer) 6380</span><br><span class="line">      3) &quot;7373de7b44ee50a1e4f653bfba1bb808138e7e3a&quot;</span><br><span class="line">3) 1) (integer) 0</span><br><span class="line">   2) (integer) 5460</span><br><span class="line">   3) 1) &quot;192.168.141.220&quot;</span><br><span class="line">      2) (integer) 6379</span><br><span class="line">      3) &quot;9250c85592b7bb8a19636b90e4cf22590bd3334f&quot;</span><br></pre></td></tr></table></figure><h2 id="基于-Docker-安装-Redis-Sentinel"><a href="#基于-Docker-安装-Redis-Sentinel" class="headerlink" title="基于 Docker 安装 Redis Sentinel"></a>基于 Docker 安装 Redis Sentinel</h2><h3 id="创建配置文件-1"><a href="#创建配置文件-1" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><p>我们部署 3 个 Sentinel 节点，需要分别创建 3 个配置文件，路径如下</p><ul><li>resentinel1：<code>cluster/node1/sentinel.conf</code></li><li>resentinel2：<code>cluster/node2/sentinel.conf</code></li><li>resentinel3：<code>cluster/node3/sentinel.conf</code></li></ul><p>配置文件内容如下 (<strong>端口号不要重复</strong>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">port 26379</span><br><span class="line">dir /tmp</span><br><span class="line"># 自定义集群名，其中 192.168.141.220 为 Redis Master 的 IP，6379 为 Redis Master 的端口，2 为最小投票数（因为有 3 台 Sentinel 所以可以设置成 2）</span><br><span class="line">sentinel monitor rmaster 192.168.141.220 6379 2</span><br><span class="line">sentinel down-after-milliseconds rmaster 30000</span><br><span class="line">sentinel parallel-syncs rmaster 1</span><br><span class="line">sentinel failover-timeout rmaster 180000</span><br><span class="line">sentinel deny-scripts-reconfig yes</span><br></pre></td></tr></table></figure><h3 id="创建资源配置-1"><a href="#创建资源配置-1" class="headerlink" title="创建资源配置"></a>创建资源配置</h3><p><code>docker-compose.yml</code> 配置文件如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;3.1&apos;</span><br><span class="line">services:</span><br><span class="line">  resentinel1:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: resentinel1</span><br><span class="line">    ports:</span><br><span class="line">      - 26379:26379</span><br><span class="line">    command: redis-sentinel /usr/local/etc/redis/sentinel.conf</span><br><span class="line">    volumes:</span><br><span class="line">      - ./cluster/node1/sentinel.conf:/usr/local/etc/redis/sentinel.conf</span><br><span class="line">  resentinel2:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: resentinel2</span><br><span class="line">    ports:</span><br><span class="line">      - 26380:26380</span><br><span class="line">    command: redis-sentinel /usr/local/etc/redis/sentinel.conf</span><br><span class="line">    volumes:</span><br><span class="line">      - ./cluster/node2/sentinel.conf:/usr/local/etc/redis/sentinel.conf</span><br><span class="line">  resentinel3:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: resentinel3</span><br><span class="line">    ports:</span><br><span class="line">      - 26381:26381</span><br><span class="line">    command: redis-sentinel /usr/local/etc/redis/sentinel.conf</span><br><span class="line">    volumes:</span><br><span class="line">      - ./cluster/node3/sentinel.conf:/usr/local/etc/redis/sentinel.conf</span><br></pre></td></tr></table></figure><h3 id="验证集群是否成功-1"><a href="#验证集群是否成功-1" class="headerlink" title="验证集群是否成功"></a>验证集群是否成功</h3><ul><li>交互式进入容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it resentinel1 /bin/bash</span><br></pre></td></tr></table></figure><ul><li>登录 Redis Sentinel</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 26379</span><br></pre></td></tr></table></figure><ul><li>查看集群 Master 信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26379&gt; sentinel master rmaster</span><br><span class="line"># 输出如下</span><br><span class="line"> 1) &quot;name&quot;</span><br><span class="line"> 2) &quot;rmaster&quot;</span><br><span class="line"> 3) &quot;ip&quot;</span><br><span class="line"> 4) &quot;192.168.141.220&quot;</span><br><span class="line"> 5) &quot;port&quot;</span><br><span class="line"> 6) &quot;6379&quot;</span><br><span class="line"> 7) &quot;runid&quot;</span><br><span class="line"> 8) &quot;30055483aeb9d75f35c0046aaec03440731e3e88&quot;</span><br><span class="line"> 9) &quot;flags&quot;</span><br><span class="line">10) &quot;master&quot;</span><br><span class="line">11) &quot;link-pending-commands&quot;</span><br><span class="line">12) &quot;0&quot;</span><br><span class="line">13) &quot;link-refcount&quot;</span><br><span class="line">14) &quot;1&quot;</span><br><span class="line">15) &quot;last-ping-sent&quot;</span><br><span class="line">16) &quot;0&quot;</span><br><span class="line">17) &quot;last-ok-ping-reply&quot;</span><br><span class="line">18) &quot;413&quot;</span><br><span class="line">19) &quot;last-ping-reply&quot;</span><br><span class="line">20) &quot;413&quot;</span><br><span class="line">21) &quot;down-after-milliseconds&quot;</span><br><span class="line">22) &quot;30000&quot;</span><br><span class="line">23) &quot;info-refresh&quot;</span><br><span class="line">24) &quot;2878&quot;</span><br><span class="line">25) &quot;role-reported&quot;</span><br><span class="line">26) &quot;master&quot;</span><br><span class="line">27) &quot;role-reported-time&quot;</span><br><span class="line">28) &quot;143537&quot;</span><br><span class="line">29) &quot;config-epoch&quot;</span><br><span class="line">30) &quot;0&quot;</span><br><span class="line">31) &quot;num-slaves&quot;</span><br><span class="line">32) &quot;0&quot;</span><br><span class="line">33) &quot;num-other-sentinels&quot;</span><br><span class="line">34) &quot;2&quot;</span><br><span class="line">35) &quot;quorum&quot;</span><br><span class="line">36) &quot;2&quot;</span><br><span class="line">37) &quot;failover-timeout&quot;</span><br><span class="line">38) &quot;180000&quot;</span><br><span class="line">39) &quot;parallel-syncs&quot;</span><br><span class="line">40) &quot;1&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手把手教你搭建一个redis集群&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://jelly54.github.io/categories/Redis/"/>
    
    
      <category term="安装教程" scheme="https://jelly54.github.io/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
      <category term="redis" scheme="https://jelly54.github.io/tags/redis/"/>
    
      <category term="集群" scheme="https://jelly54.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
      <category term="doker" scheme="https://jelly54.github.io/tags/doker/"/>
    
  </entry>
  
  <entry>
    <title>硬链接、软连接引出的inode</title>
    <link href="https://jelly54.github.io/linux-inode/"/>
    <id>https://jelly54.github.io/linux-inode/</id>
    <published>2019-11-27T09:15:40.000Z</published>
    <updated>2020-08-27T11:05:52.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="inode定义"><a href="#inode定义" class="headerlink" title="inode定义"></a>inode定义</h1><p>inode是linux系统中<strong>用作数据索引的标识符</strong>。简单来说，inode指示了一个文件的基本信息，如inode编号、修改时间、文件的位置等。</p><p>如同一本书的目录，会直接告诉你想看的章节是在第几页。不同的是，书是以页为单位的，而Linux文件存取是以“块”为单位的。</p><a id="more"></a><h2 id="找寻文件"><a href="#找寻文件" class="headerlink" title="找寻文件"></a>找寻文件</h2><p>操作系统在读取硬盘的时候，会一次性读取一个“块”（一个“块”的大小往往是4KB，包含了连续8个扇区，每个扇区存储512个字节）。而inode就告诉了文件位于哪个“块”，于是系统就会从这个“块”开始读取内容，我们就可以看到文件的内容。</p><p>每个文件都有对应的inode，存储着这个文件的基本信息。Linux系统不使用文件名，而使用inode号来识别文件。对于使用者，我们是通过文件名寻找、打开文件；对于系统，是通过以下三步找到的：</p><ol><li>系统找到这个文件名对应的inode号</li><li>通过inode号，获取inode信息</li><li>根据inode信息，找到文件数据所在的block，读取内容</li></ol><h2 id="inode内容"><a href="#inode内容" class="headerlink" title="inode内容"></a>inode内容</h2><p>inode 包含了文件的以下基本信息：</p><ul><li>文件的字节数</li><li>node 编号</li><li>文件拥有者的 Uid</li><li>文件所属group的 Gid</li><li>文件的读、写、执行权限</li><li>文件的时间戳，共有三个：<ul><li>change：inode 上一次变动的时间</li><li>modify：文件内容上一次变动的时间</li><li>access：文件上一次打开的时间</li></ul></li><li>链接数，即有多少文件名指向这个inode</li><li>文件数据 block 的位置</li></ul><p>我们可以使用 <strong>stat</strong> 命令查看文件的inode信息，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> stat v0.1.0.zip </span><br><span class="line">  File: ‘v0.1.0.zip’</span><br><span class="line">  Size: 94267     Blocks: 192        IO Block: 4096   regular file</span><br><span class="line">Device: 811h/2065dInode: 5659765     Links: 1</span><br><span class="line">Access: (0640/-rw-r-----)  Uid: ( 3457/mart_bda)   Gid: ( 3457/mart_bda)</span><br><span class="line">Access: 2018-06-12 14:22:18.434027485 +0800</span><br><span class="line">Modify: 2018-06-12 14:18:00.840994081 +0800</span><br><span class="line">Change: 2018-06-12 14:18:00.840994081 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><p>也可以在 <strong>ls</strong> 后加上 <strong>-i</strong> 直接获取inode编号:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ls -i v0.1.0.zip </span><br><span class="line">5659765 v0.1.0.zip</span><br></pre></td></tr></table></figure><h2 id="inode大小"><a href="#inode大小" class="headerlink" title="inode大小"></a>inode大小</h2><p>inode存储了文件的基本信息，虽然信息很少，但是也会占用空间。<br>硬盘格式化的时候，操作系统自动将硬盘分为两个区域：</p><ul><li>数据区：存放文件内容</li><li>inode 区：存放 inode 包含的信息，也叫作 inode table</li></ul><p>每个 inode 节点的大小，一般是 128 字节或 256 字节。<strong>inode节点的总数，在硬盘格式化时就固定了</strong>。一般，数据区每1KB或2KB，inode区就会增加一个 inode。</p><p>假如在一块 1GB 的硬盘中，每个 inode 节点的大小为 128 字节，那么 inode 表的大小就会达到 128 MB，占整块硬盘的 12.8%。既然 inode 节点总数是有限的，那么分区的节点数就有用完的时候，一旦 <strong>inode 用完，即使磁盘空间还有剩余，也不能再存放任何数据</strong>，因为需要保证每个文件必须有一个 inode。</p><p>查看每个硬盘分区的 inode 或者磁盘容量的使用情况，可以使用 df 命令加上参数 -i 或者 -h，如：</p><blockquote><p>文件-h, –human-readable 使用人类可读的格式(预设值是不加这个选项的…)</p><p>文件-H, –si 很像 -h, 但是用 1000 为单位而不是用 1024</p><p>文件-i, –inodes 列出 inode 资讯，不列出已使用 block</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> df -i</span><br><span class="line">Filesystem        Inodes   IUsed     IFree IUse% Mounted on</span><br><span class="line">/dev/sda5      275436544  801853 274634691    1% /</span><br><span class="line">devtmpfs         8192960     524   8192436    1% /dev</span><br><span class="line">tmpfs            8195307       4   8195303    1% /dev/shm</span><br><span class="line">tmpfs            8195307     765   8194542    1% /run</span><br><span class="line">tmpfs            8195307      13   8195294    1% /sys/fs/cgroup</span><br><span class="line">/dev/sda2         204800     342    204458    1% /boot</span><br><span class="line">/dev/sdb1       11443200 3329257   8113943   30% /data0</span><br><span class="line">tmpfs            8195307       1   8195306    1% /run/user/0</span><br><span class="line">tmpfs            8195307       1   8195306    1% /run/user/3457</span><br><span class="line"><span class="meta">$</span> df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda5       263G  134G  130G  51% /</span><br><span class="line">devtmpfs         32G     0   32G   0% /dev</span><br><span class="line">tmpfs            32G   12K   32G   1% /dev/shm</span><br><span class="line">tmpfs            32G  394M   31G   2% /run</span><br><span class="line">tmpfs            32G     0   32G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda2       197M  139M   58M  71% /boot</span><br><span class="line">/dev/sdb1        11T  5.2T  5.2T  51% /data0</span><br><span class="line">tmpfs           6.3G     0  6.3G   0% /run/user/0</span><br><span class="line">tmpfs           6.3G     0  6.3G   0% /run/user/3457</span><br></pre></td></tr></table></figure><p>关于 df -h -i 的区别，可以参考 <a href="http://www.runoob.com/linux/linux-comm-df.html" target="_blank" rel="noopener">Linux df命令</a>。</p><h1 id="文件操作对-inode-的影响"><a href="#文件操作对-inode-的影响" class="headerlink" title="文件操作对 inode 的影响"></a>文件操作对 inode 的影响</h1><p>要理解文件的操作对 inode 的影响，先要理解目录的原理。目录对外表现是一个容器，存放着子文件和子目录，实际上在系统内部，目录本身也是一个文件，目录文件的内容即是该目录下的文件名与 inode 号的映射表（即一个个的目录项）。</p><p>因此，linux访问一个文件时，要先查询到上一级目录，根据目录内容查找到文件对应的 inode号，然后读取对应的 block。</p><h2 id="cp-命令"><a href="#cp-命令" class="headerlink" title="cp 命令"></a>cp 命令</h2><p>系统内部会执行以下操作：</p><ol><li><p>分配一个未被使用的 inode 号，在 inode 表中新添一个项目。如果是覆盖复制，则 inode号不变，沿用之前同名文件的 inode 号。</p></li><li><p>在目录中新建一个目录项，并指向步骤 1 中的 inode。</p></li><li><p>把数据复制到 block 中。</p></li></ol><h2 id="rm-命令"><a href="#rm-命令" class="headerlink" title="rm 命令"></a>rm 命令</h2><p>系统内部会执行以下操作：</p><ol><li><p>减少待删除文件名所对应的 inode 的链接数量，如果链接数变为0，则释放 inode，同时数据块放到可用空间中（对外表现为数据已删除，因为随时可以覆盖。如果没有覆盖，数据还可以恢复；一旦覆盖了，那么删除的数据无法恢复。）。</p></li><li><p>删除目录中的目录项。</p></li></ol><h2 id="mv-命令"><a href="#mv-命令" class="headerlink" title="mv 命令"></a>mv 命令</h2><p>如果目标文件和源文件属于同一个文件系统：</p><ol><li>在目标文件的目录中新建目录项</li><li>删除源文件的目录中的目录项</li><li>目标文件名会指向源文件名的 inode。因此该操作对 inode 没有影响（除了时间戳），对数据的位置也没有影响，不移动任何数据。</li></ol><p>如果目标文件和源文件属于不同文件系统:</p><ol><li>相当于 cp + rm。</li></ol><h2 id="ln-命令"><a href="#ln-命令" class="headerlink" title="ln 命令"></a>ln 命令</h2><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>一般情况下，文件名和 inode 号是一一对应，但是也<strong>有可能多个文件名指向同一个inode号</strong>，即硬链接。</p><ul><li>硬链接可以实现用不同的文件名访问同一个文件；</li><li>对文件内容修改，会影响到所有的文件名；</li><li>但是，删除一个文件名，不影响其他文件名的访问。</li></ul><p><img src="https://s2.ax1x.com/2020/03/07/3XH3E6.png" alt="3XH3E6.png"></p><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>创建硬链接的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln [source file] [new file]</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ll -h -i</span><br><span class="line">total 479M</span><br><span class="line">5659849 -rw-r----- 1 mart_bda mart_bda 479M Jun 13 10:57 test_file</span><br><span class="line"><span class="meta">$</span> ln test_file test_file_hardlink</span><br><span class="line"><span class="meta">$</span> ll -i -h</span><br><span class="line">total 957M</span><br><span class="line">5659849 -rw-r----- 2 mart_bda mart_bda 479M Jun 13 10:57 test_file</span><br><span class="line">5659849 -rw-r----- 2 mart_bda mart_bda 479M Jun 13 10:57 test_file_hardlink</span><br></pre></td></tr></table></figure><p>这样，两个文件的 inode 号均为 5659849。</p><p>具体查看两个文件的 inode 内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> stat test_file</span><br><span class="line">  File: ‘test_file’</span><br><span class="line">  Size: 501577774 Blocks: 979656     IO Block: 4096   regular file</span><br><span class="line">Device: 811h/2065dInode: 5659849     Links: 2</span><br><span class="line">Access: (0640/-rw-r-----)  Uid: ( 3457/mart_bda)   Gid: ( 3457/mart_bda)</span><br><span class="line">Access: 2018-06-13 10:57:13.961409755 +0800</span><br><span class="line">Modify: 2018-06-13 10:57:14.931383436 +0800</span><br><span class="line">Change: 2018-06-13 10:58:11.382851699 +0800</span><br><span class="line"> Birth: -</span><br><span class="line"><span class="meta">$</span> stat test_file_hardlink </span><br><span class="line">  File: ‘test_file_hardlink’</span><br><span class="line">  Size: 501577774 Blocks: 979656     IO Block: 4096   regular file</span><br><span class="line">Device: 811h/2065dInode: 5659849     Links: 2</span><br><span class="line">Access: (0640/-rw-r-----)  Uid: ( 3457/mart_bda)   Gid: ( 3457/mart_bda)</span><br><span class="line">Access: 2018-06-13 10:57:13.961409755 +0800</span><br><span class="line">Modify: 2018-06-13 10:57:14.931383436 +0800</span><br><span class="line">Change: 2018-06-13 10:58:11.382851699 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><p>可以看到，两个文件的 inode 内容完全相同，且 <strong>Links 变成了 2</strong>。<strong>修改</strong>任何一个文件名的内容，另一个文件名的内容也<strong>会同时改变</strong>，因为访问的就是硬盘中的同一块数据。</p><p>如果再将 test_file_hardlink <strong>删掉</strong>，会使得 <strong>Links 变回 1</strong>。当这个值减到 0 时，说明没有文件名指向这个 inode，系统就会回收这个号码，以及所对应的 block 区域。</p><p>另外，对于目录的链接数，创建一个目录时，默认会生成两个目录项：<strong>. 和 .. 前者的 inode 号就是当前目录的 inode 号，等同于当前目录的硬链接；后者的 inode 号是父目录的 inode 号，等同于父目录的硬链接</strong>。</p><p>因此，任何一个目录的硬链接总数，总是等于 2 加上它的子目录总数（含隐藏目录，且除去. 和 ..）。</p><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>软链接也可以通过不同的文件名访问同一块数据，但是与硬链接不同的是，<strong>两个文件名的 inode 是不一样的</strong>。</p><p>那如何访问同一块区域呢？</p><p>比如文件 A 是文件 B 的软连接，那么<strong>文件 A 的内容存放的是文件 B 的路径名</strong>（可以通过这个找到文件 B 的目录项）。因此访问 A 时，会读取文件 B 的路径，进而读取文件 B 的内容。这样，对外表现来看，文件 A 和文件 B 的内容就相同了。<strong>类似于 windows 系统下的快捷方式</strong>。</p><p><img src="https://s2.ax1x.com/2020/03/07/3XHG4O.png" alt="3XHG4O.png"></p><h4 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>建立软链接的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s [source file] [new file]</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ll</span><br><span class="line">total 489824</span><br><span class="line">-rw-r----- 1 mart_bda mart_bda 501577774 Jun 13 11:21 test_file</span><br><span class="line"><span class="meta">$</span> ln -s test_file test_file_soft</span><br><span class="line"><span class="meta">$</span> ll -h -i</span><br><span class="line">total 479M</span><br><span class="line">5659853 -rw-r----- 1 mart_bda mart_bda 479M Jun 13 11:21 test_file</span><br><span class="line">5659854 lrwxrwxrwx 1 mart_bda mart_bda    9 Jun 13 11:22 test_file_soft -&gt; test_file</span><br></pre></td></tr></table></figure><p>如果是对文件夹简历软链接，则为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /tmp/test_directory ./</span><br></pre></td></tr></table></figure><p>会自动地在当前目录建立一个文件夹 test_directory ，并指向 /tmp/test_directory</p><ul><li>两个文件的 inode 号是不同的。</li><li>既然文件 A 是依赖文件 B 存在的，那么如果删除了文件 B，打开文件 A 就会报错：No such file or directory；</li><li>如果删除了文件 A，则对文件 B 的打开无影响，因为只是删除了“快捷方式”而已。</li><li>软连接的建立，不会影响到文件 B 的 inode 的任何信息，包括 Links。</li></ul><h3 id="硬链接和软链接的不同"><a href="#硬链接和软链接的不同" class="headerlink" title="硬链接和软链接的不同"></a>硬链接和软链接的不同</h3><ol><li>本质不同：硬链接是指向同一个文件，软链接指向的不是同一个文件。</li><li>删除时：硬链接不受影响，软链接失效</li><li>创建链接时：创建硬链接链接数加1，创建软链接连接数不变</li><li>是否可以跨分区：硬链接不可以跨分区，软链接可以跨分区</li><li>目录是否可以创建链接：<strong>硬链接不可以对目录创建，软链接可以对目录创建</strong></li><li>硬链接的inode号相同，软链接inode号不同</li></ol><h3 id="硬链接和软链接的占用空间分析"><a href="#硬链接和软链接的占用空间分析" class="headerlink" title="硬链接和软链接的占用空间分析"></a>硬链接和软链接的占用空间分析</h3><p>硬链接不占用磁盘空间，软链接占用的空间只是存储路径所占用的极小空间。</p><blockquote><p>ll –h 或者 ls –h这命令进行统计文件总大小的时候并不是从磁盘进行统计的，而是根据文件属性中的大小叠加得来的。而硬链接的文件属性中的大小就是就是inode号对应的数据块的大小，所以total中进行统计就把各个文件属性中的大小加起来作为总和，这种统计是不标准，也不具有代表性的，</p><p>真正的查看某个文件夹占用磁盘空间大小命令是：du –h   这个命令是从磁盘上进行统计，不会被文件的属性中大小影响，所以更准确</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;inode定义&quot;&gt;&lt;a href=&quot;#inode定义&quot; class=&quot;headerlink&quot; title=&quot;inode定义&quot;&gt;&lt;/a&gt;inode定义&lt;/h1&gt;&lt;p&gt;inode是linux系统中&lt;strong&gt;用作数据索引的标识符&lt;/strong&gt;。简单来说，inode指示了一个文件的基本信息，如inode编号、修改时间、文件的位置等。&lt;/p&gt;
&lt;p&gt;如同一本书的目录，会直接告诉你想看的章节是在第几页。不同的是，书是以页为单位的，而Linux文件存取是以“块”为单位的。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://jelly54.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="原理" scheme="https://jelly54.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="Linux" scheme="https://jelly54.github.io/tags/Linux/"/>
    
      <category term="操作系统" scheme="https://jelly54.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
