<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱吃jelly的Jelly</title>
  
  <subtitle>就揪啾  就是 Jelly</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jelly54.github.io/"/>
  <updated>2020-08-28T07:04:59.442Z</updated>
  <id>https://jelly54.github.io/</id>
  
  <author>
    <name>Big Jelly</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>netty-start</title>
    <link href="https://jelly54.github.io/netty-start/"/>
    <id>https://jelly54.github.io/netty-start/</id>
    <published>2020-08-27T13:00:55.000Z</published>
    <updated>2020-08-28T07:04:59.442Z</updated>
    
    <content type="html"><![CDATA[<p>本文为<a href="https://juejin.im/book/6844733738119593991" target="_blank" rel="noopener">《Netty 入门与实战：仿写微信 IM 即时通讯系统》</a> 的读书笔记</p><a id="more"></a><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><ul><li>本质：JBoss做的一个Jar包</li><li>目的：快速开发高性能、高可靠性的网络服务器和客户端程序</li><li>优点：提供异步的、事件驱动的网络应用程序框架和工具</li><li>通俗的说：一个可以让你优雅地处理Socket的Jar包</li></ul><h2 id="Netty的特性"><a href="#Netty的特性" class="headerlink" title="Netty的特性"></a>Netty的特性</h2><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>统一的API，适用于不同的协议（阻塞和非阻塞）</p><p>基于灵活、可扩展的事件驱动模型</p><p>高度可定制的线程模型</p><p>可靠的无连接数据Socket支持（UDP）</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>更好的吞吐量，低延迟</p><p>更省资源</p><p>尽量减少不必要的内存拷贝</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>完整的SSL/TLS和STARTTLS的支持</p><p>能在Applet与Android的限制环境运行良好</p><h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h3><p>不再因过快、过慢或超负载连接导致OutOfMemoryError</p><p>不再有在高速网络环境下NIO读写频率不一致的问题</p><h3 id="易用"><a href="#易用" class="headerlink" title="易用"></a>易用</h3><p>完善的JavaDoc，用户指南和样例</p><p>简洁简单</p><p>仅信赖于JDK1.5</p><h1 id="能干什么"><a href="#能干什么" class="headerlink" title="能干什么"></a>能干什么</h1><p>有了Netty，你可以实现自己的HTTP服务器，FTP服务器，UDP服务器，RPC服务器，WebSocket服务器，Redis的Proxy服务器，MySQL的Proxy服务器等等。  </p><h2 id="传统的HTTP服务器的原理"><a href="#传统的HTTP服务器的原理" class="headerlink" title="传统的HTTP服务器的原理"></a>传统的HTTP服务器的原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 创建一个ServerSocket，监听并绑定一个端口</span><br><span class="line">2. 一系列客户端来请求这个端口</span><br><span class="line">3. 服务器使用Accept，获得一个来自客户端的Socket连接对象</span><br><span class="line">4. 启动一个新线程处理连接</span><br><span class="line">    4.1 读Socket，得到字节流</span><br><span class="line">    4.2 解码协议，得到Http请求对象 </span><br><span class="line">    4.3 处理Http请求，得到一个结果，封装成一个HttpResponse对象 </span><br><span class="line">    4.4 编码协议，将结果序列化字节流 写Socket，将字节流发给客户端</span><br><span class="line">5. 继续循环步骤3</span><br></pre></td></tr></table></figure><p>HTTP服务器之所以称为HTTP服务器，是因为编码解码协议是HTTP协议，如果协议是Redis协议，那它就成了Redis服务器，如果协议是WebSocket，那它就成了WebSocket服务器，等等。<font color="red">使用Netty你就可以定制编解码协议，实现自己的特定协议的服务器。</font></p><h2 id="典型的应用"><a href="#典型的应用" class="headerlink" title="典型的应用"></a>典型的应用</h2><p>从组网情况看，垂直的架构拆分之后，系统采用分布式部署，各个节点之间需要远程服务调用，高性能的 RPC 框架必不可少，Netty 作为异步高性能的通信框架，往往作为基础通信组件被这些 RPC 框架使用。</p><p>如：阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各进程节点之间的内部通信。</p><h1 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.1.6.Final&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h2 id="Netty服务端demo"><a href="#Netty服务端demo" class="headerlink" title="Netty服务端demo"></a>Netty服务端demo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import io.netty.bootstrap.ServerBootstrap;</span><br><span class="line">import io.netty.channel.ChannelHandlerContext;</span><br><span class="line">import io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line">import io.netty.channel.ChannelInitializer;</span><br><span class="line">import io.netty.channel.ChannelOption;</span><br><span class="line">import io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line">import io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line">import io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line">import io.netty.util.AttributeKey;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 要启动一个Netty服务端，必须要指定三类属性，分别是线程模型、IO 模型、连接读写处理逻辑、绑定端口</span><br><span class="line"> *</span><br><span class="line"> * @author zhang guo dong</span><br><span class="line"> */</span><br><span class="line">public class NettyServer &#123;</span><br><span class="line"> </span><br><span class="line">    private static final int BEGIN_PORT = 10101;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        NioEventLoopGroup boosGroup = new NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line"> </span><br><span class="line">        final ServerBootstrap serverBootstrap = new ServerBootstrap();</span><br><span class="line">        final AttributeKey&lt;Object&gt; clientKey = AttributeKey.newInstance(&quot;clientKey&quot;);</span><br><span class="line">        serverBootstrap</span><br><span class="line">                // 1.绑定线程模型，一个负责接受请求，一个负责干活</span><br><span class="line">                .group(boosGroup, workerGroup)</span><br><span class="line">                // 2.指定IO模型</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                // 可选：用于指定在服务端启动过程中的一些逻辑</span><br><span class="line">                .handler(new ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">                        super.channelActive(ctx);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                // 可选：可以给服务端的 channel，也就是NioServerSocketChannel指定一些自定义属性, 然后可以通过channel.attr()取出这个属性</span><br><span class="line">                .attr(AttributeKey.newInstance(&quot;serverName&quot;), &quot;nettyServer&quot;)</span><br><span class="line">                // 可选：可以给每一条连接指定自定义属性</span><br><span class="line">                .childAttr(clientKey, &quot;clientValue&quot;)</span><br><span class="line">                // 可选：给服务端channel设置一些属性。表示系统用于临时存放已完成三次握手的请求的队列的最大长度</span><br><span class="line">                // 可选：如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, 1024)</span><br><span class="line">                // 可选：每条连接设置一些TCP底层相关的属性。表示是否开启TCP底层心跳机制</span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, true)</span><br><span class="line">                // 可选：表示是否开启Nagle算法，如果要求高实时性，有数据发送时就马上发送，就关闭，如果需要减少发送次数减少网络交互，就开启</span><br><span class="line">                .childOption(ChannelOption.TCP_NODELAY, true)</span><br><span class="line">                // 3.定义后续每条连接的数据读写，业务处理逻辑</span><br><span class="line">                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void initChannel(NioSocketChannel ch) &#123;</span><br><span class="line">                        System.out.println(ch.attr(clientKey).get());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"> </span><br><span class="line">        // 4.绑定端口</span><br><span class="line">        bind(serverBootstrap, BEGIN_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 自动绑定递增端口</span><br><span class="line">     *</span><br><span class="line">     * @param serverBootstrap 启动器</span><br><span class="line">     * @param port            待绑定的端口</span><br><span class="line">     */</span><br><span class="line">    private static void bind(final ServerBootstrap serverBootstrap, final int port) &#123;</span><br><span class="line">        // bind(port) 是一个异步的方法，调用之后是立即返回的，他的返回值是一个ChannelFuture</span><br><span class="line">        serverBootstrap.bind(port)</span><br><span class="line">                // 给这个ChannelFuture添加一个监听器GenericFutureListener，在operationComplete方法里，可以监听端口是否绑定成功</span><br><span class="line">                .addListener(future -&gt; &#123;</span><br><span class="line">                    if (future.isSuccess()) &#123;</span><br><span class="line">                        System.out.println(&quot;端口[&quot; + port + &quot;]绑定成功!&quot;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        System.err.println(&quot;端口[&quot; + port + &quot;]绑定失败!&quot;);</span><br><span class="line">                        bind(serverBootstrap, port + 1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Netty客户端demo"><a href="#Netty客户端demo" class="headerlink" title="Netty客户端demo"></a>Netty客户端demo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">import io.netty.bootstrap.Bootstrap;</span><br><span class="line">import io.netty.channel.ChannelInitializer;</span><br><span class="line">import io.netty.channel.ChannelOption;</span><br><span class="line">import io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line">import io.netty.channel.socket.SocketChannel;</span><br><span class="line">import io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line">import io.netty.util.AttributeKey;</span><br><span class="line"> </span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 要启动一个Netty客户端，必须要指定三类属性，分别是线程模型、IO 模型、连接读写处理逻辑、绑定端口</span><br><span class="line"> *</span><br><span class="line"> * @author zhang guo dong</span><br><span class="line"> */</span><br><span class="line">public class NettyClient &#123;</span><br><span class="line">    private static final int MAX_RETRY = 5;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        NioEventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line"> </span><br><span class="line">        Bootstrap bootstrap = new Bootstrap();</span><br><span class="line">        bootstrap</span><br><span class="line">                // 1.指定线程模型</span><br><span class="line">                .group(workerGroup)</span><br><span class="line">                // 2.指定 IO 类型为 NIO</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                // 可选：可以给客户端 Channel，也就是NioSocketChannel绑定自定义属性,可以通过channel.attr()取出这个属性</span><br><span class="line">                .attr(AttributeKey.newInstance(&quot;clientName&quot;), &quot;nettyClient&quot;)</span><br><span class="line">                // 可选：设置TCP底层属性，表示连接的超时时间</span><br><span class="line">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)</span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, true)</span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, true)</span><br><span class="line">                // 3.IO 处理逻辑</span><br><span class="line">                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void initChannel(SocketChannel ch) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"> </span><br><span class="line">        // 4.建立连接</span><br><span class="line">        connect(bootstrap, &quot;127.0.0.1&quot;, 10101, MAX_RETRY);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void connect(Bootstrap bootstrap, String host, int port, int retry) &#123;</span><br><span class="line">        bootstrap.connect(host, port).addListener(future -&gt; &#123;</span><br><span class="line">            if (future.isSuccess()) &#123;</span><br><span class="line">                System.out.println(&quot;连接成功!&quot;);</span><br><span class="line">            &#125; else if (retry == 0) &#123;</span><br><span class="line">                System.err.println(&quot;重试次数已用完，放弃连接！&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 第几次重连</span><br><span class="line">                int order = (MAX_RETRY - retry) + 1;</span><br><span class="line">                // 本次重连的间隔</span><br><span class="line">                int delay = 1 &lt;&lt; order;</span><br><span class="line">                System.err.println(new Date() + &quot;: 连接失败，第&quot; + order + &quot;次重连……&quot;);</span><br><span class="line">                bootstrap.config().group().schedule(() -&gt; connect(bootstrap, host, port, retry - 1), delay, TimeUnit</span><br><span class="line">                        .SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="仔细看"><a href="#仔细看" class="headerlink" title="仔细看"></a>仔细看</h1><h2 id="传输载体ByteBuf"><a href="#传输载体ByteBuf" class="headerlink" title="传输载体ByteBuf"></a>传输载体ByteBuf</h2><p><img src="https://s1.ax1x.com/2020/08/27/d4nbHs.png" alt="d4nbHs.png"></p><ol><li>ByteBuf是一个字节容器，包含三个部分，第一部分是已经丢弃的字节，这部分数据是无效的；第二部分是可读字节，这部分是ByteBuf的主体数据；第三部分是可写字节，所有写到ButeBuf的数据都会写到这个区域。后边虚线部分是该ByteBuf最多还能扩容多少容量。</li><li>上述三个部门是被两个指针划分出来，从左到右，依次是读指针（readerIndex）、写指针（writerIndex）、总容量capacity。</li><li>从ByteBuf中每读取一个字节，rederIndex自增1，ByteBuf里面总共有writerIndex - readerIndex个可读字节，当readerIndex 与 writerIndex相等的时候，ByteBuf不可读。</li><li>写数据是从writeIndex指向的部分开始写，每写一个字节，writerIndex自增1，直到和capacity相等，ByteBuf不可写了。</li><li>ByteBuf 里面其实还有一个参数 maxCapacity，当向 ByteBuf 写数据的时候，如果容量不足，那么这个时候可以进行扩容，每次扩容64字节的倍数，直到 capacity 扩容到 maxCapacity，超过 maxCapacity 就会报错。</li></ol><h2 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 前者表示返回当前的读指针 readerIndex, 后者表示设置读指针</span><br><span class="line">readerIndex() 与 readerIndex(int)</span><br><span class="line"> </span><br><span class="line">// 前者表示返回当前的写指针 writerIndex, 后者表示设置写指针</span><br><span class="line">writeIndex() 与 writeIndex(int)</span><br><span class="line"> </span><br><span class="line">// 前者表示把当前的读指针保存起来，后者表示把当前的读指针恢复到之前保存的值，下面两段代码是等价的</span><br><span class="line">markReaderIndex() 与 resetReaderIndex()</span><br><span class="line"> </span><br><span class="line">//</span><br><span class="line">markWriterIndex() 与 resetWriterIndex()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 代码片段1</span><br><span class="line">int readerIndex = buffer.readerIndex();</span><br><span class="line">// .. 其他操作</span><br><span class="line">buffer.readerIndex(readerIndex);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">// 代码片段二</span><br><span class="line">buffer.markReaderIndex();</span><br><span class="line">// .. 其他操作</span><br><span class="line">buffer.resetReaderIndex();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 关于 ByteBuf 的读写都可以看作从指针开始的地方开始读写数据</span><br><span class="line"> </span><br><span class="line">// 表示把字节数组 src 里面的数据全部写到 ByteBuf，src 字节数组大小的长度通常小于等于 writableBytes()</span><br><span class="line">writeBytes(byte[] src)</span><br><span class="line"> </span><br><span class="line">// 把 ByteBuf 里面的数据全部读取到 dst，这里 dst 字节数组的大小通常等于 readableBytes()</span><br><span class="line">buffer.readBytes(byte[] dst)</span><br></pre></td></tr></table></figure><p>writeByte() 表示往 ByteBuf 中写一个字节，而 buffer.readByte() 表示从 ByteBuf 中读取一个字节，类似的 API 还有 writeBoolean()、writeChar()、writeShort()、writeInt()、writeLong()、writeFloat()、writeDouble() 与 readBoolean()、readChar()、readShort()、readInt()、readLong()、readFloat()、readDouble() </p><p>与读写 API 类似的 API 还有 getBytes、getByte() 与 setBytes()、setByte() 系列，唯一的区别就是 get/set 不会改变读写指针，而 read/write 会改变读写指针，这点在解析数据的时候千万要注意</p><p>由于 Netty 使用了堆外内存，而堆外内存是不被 jvm 直接管理的，也就是说申请到的内存无法被垃圾回收器直接回收，所以需要我们手动回收。有点类似于c语言里面，申请到的内存必须手工释放，否则会造成内存泄漏。</p><p>Netty 的 ByteBuf 是通过引用计数的方式管理的，如果一个 ByteBuf 没有地方被引用到，需要回收底层内存。默认情况下，当创建完一个 ByteBuf，它的引用为1，然后每次调用 retain() 方法， 它的引用就加一， release() 方法原理是将引用计数减一，减完之后如果发现引用计数为0，则直接回收 ByteBuf 底层的内存。</p><h2 id="通信协议编码"><a href="#通信协议编码" class="headerlink" title="通信协议编码"></a>通信协议编码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">release()</span><br><span class="line"> </span><br><span class="line">retain()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 方法从原始 ByteBuf 中截取一段，这段数据是从 readerIndex 到 writeIndex，</span><br><span class="line">// 同时，返回的新的 ByteBuf 的最大容量 maxCapacity 为原始 ByteBuf 的 readableBytes()</span><br><span class="line">slice()</span><br><span class="line"> </span><br><span class="line">// 方法把整个 ByteBuf 都截取出来，包括所有的数据，指针信息</span><br><span class="line">duplicate()</span><br><span class="line"> </span><br><span class="line">// slice() 方法与 duplicate() 方法的相同点是：底层内存以及引用计数与原始的 ByteBuf 共享，也就是说经过 slice() 或者 duplicate() 返回的 ByteBuf 调用 write 系列方法都会影响到 原始的 ByteBuf，但是它们都维持着与原始 ByteBuf 相同的内存引用计数和不同的读写指针</span><br><span class="line"> </span><br><span class="line">// slice() 方法与 duplicate() 不同点就是：slice() 只截取从 readerIndex 到 writerIndex 之间的数据，它返回的 ByteBuf 的最大容量被限制到 原始 ByteBuf 的 readableBytes(), 而 duplicate() 是把整个 ByteBuf 都与原始的 ByteBuf 共享</span><br><span class="line"> </span><br><span class="line">// slice() 方法与 duplicate() 方法不会拷贝数据，它们只是通过改变读写指针来改变读写的行为，而最后一个方法 copy() 会直接从原始的 ByteBuf 中拷贝所有的信息，包括读写指针以及底层对应的数据，因此，往 copy() 返回的 ByteBuf 中写数据不会影响到原始的 ByteBuf</span><br><span class="line"> </span><br><span class="line">// slice() 和 duplicate() 不会改变 ByteBuf 的引用计数，所以原始的 ByteBuf 调用 release() 之后发现引用计数为零，就开始释放内存，调用这两个方法返回的 ByteBuf 也会被释放，这个时候如果再对它们进行读写，就会报错。因此，我们可以通过调用一次 retain() 方法 来增加引用，表示它们对应的底层的内存多了一次引用，引用计数为2，在释放内存的时候，需要调用两次 release() 方法，将引用计数降到零，才会释放内存</span><br><span class="line"> </span><br><span class="line">// 这三个方法均维护着自己的读写指针，与原始的 ByteBuf 的读写指针无关，相互之间不受影响</span><br></pre></td></tr></table></figure><p>使用到 slice 和 duplicate 方法的时候，<font color="red">千万要弄清楚内存共享，引用计数共享，读写指针不共享几个概念</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">retainedSlice() 与 retainedDuplicate()</span><br><span class="line"> </span><br><span class="line">// 它们的作用是在截取内存片段的同时，增加内存的引用计数，分别与下面两段代码等价</span><br><span class="line"> </span><br><span class="line">// retainedSlice 等价于</span><br><span class="line">slice().retain();</span><br><span class="line"> </span><br><span class="line">// retainedDuplicate() 等价于</span><br><span class="line">duplicate().retain()</span><br></pre></td></tr></table></figure><h2 id="pipeline-与-channelHandler"><a href="#pipeline-与-channelHandler" class="headerlink" title="pipeline 与 channelHandler"></a>pipeline 与 channelHandler</h2><p>通过责任链设计模式来组织代码逻辑，并且能够支持逻辑的动态添加和删除 ，Netty 能够支持各类协议的扩展，比如 HTTP，Websocket，Redis，靠的就是 pipeline 和 channelHandler。</p><p><img src="https://s1.ax1x.com/2020/08/27/d4n7uQ.png" alt="d4n7uQ.png"></p><p>无论是从服务端来看，还是客户端来看，在 Netty 整个框架里面，一条连接对应着一个 Channel，这条 Channel 所有的处理逻辑都在一个叫做 ChannelPipeline 的对象里面，ChannelPipeline 是一个双向链表结构，他和 Channel 之间是一对一的关系。</p><p>ChannelPipeline 里面每个节点都是一个 ChannelHandlerContext 对象，这个对象能够拿到和 Channel 相关的所有的上下文信息，然后这个对象包着一个重要的对象，那就是逻辑处理器 ChannelHandler。</p><h2 id="ChannelHandler-有哪些分类"><a href="#ChannelHandler-有哪些分类" class="headerlink" title="ChannelHandler 有哪些分类"></a>ChannelHandler 有哪些分类</h2><p><img src="https://s1.ax1x.com/2020/08/27/d4nLEn.png" alt="d4nLEn.png"></p><ol><li>ChannelInboundHandler: 从字面意思也可以猜到，它是处理读数据的逻辑。在一端读到一段数据，首先要解析这段数据，然后对这些数据做一系列逻辑处理，最终把响应写到对端， 在开始组装响应之前的所有的逻辑，都可以放置在 ChannelInboundHandler 里处理，其中一个最重要的方法就是 channelRead()。</li><li>ChannelOutBoundHandler 是处理写数据的逻辑，它是定义我们一端在组装完响应之后，把数据写到对端的逻辑。我们封装好一个 response 对象，接下来我们有可能对这个 response 做一些其他的特殊逻辑，然后，再编码成 ByteBuf，最终写到对端，它里面最核心的一个方法就是 write()。</li></ol><h2 id="inBoundHandler和outBoundHandler执行顺序"><a href="#inBoundHandler和outBoundHandler执行顺序" class="headerlink" title="inBoundHandler和outBoundHandler执行顺序"></a>inBoundHandler和outBoundHandler执行顺序</h2><p>这两个子接口分别有对应的默认实现，ChannelInboundHandlerAdapter，和 ChanneloutBoundHandlerAdapter，它们分别实现了两大接口的所有功能，默认情况下会把读写事件传播到下一个 handler。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 在服务端的 pipeline 添加三个 ChannelInboundHandler</span><br><span class="line">NettyServer.java</span><br><span class="line"> </span><br><span class="line">serverBootstrap</span><br><span class="line">        .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            protected void initChannel(NioSocketChannel ch) &#123;</span><br><span class="line">                ch.pipeline().addLast(new InBoundHandlerA());</span><br><span class="line">                ch.pipeline().addLast(new InBoundHandlerB());</span><br><span class="line">                ch.pipeline().addLast(new InBoundHandlerC());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">// 每个 inBoundHandler 都继承自 ChannelInboundHandlerAdapter，然后实现了 channelRead() 方法</span><br><span class="line">public class InBoundHandlerA extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;InBoundHandlerA: &quot; + msg);</span><br><span class="line">        super.channelRead(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class InBoundHandlerB extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;InBoundHandlerB: &quot; + msg);</span><br><span class="line">        super.channelRead(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class InBoundHandlerC extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;InBoundHandlerC: &quot; + msg);</span><br><span class="line">        super.channelRead(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 channelRead() 方法里面，我们打印当前 handler 的信息，然后调用父类的 channelRead() 方法，而这里父类的 channelRead() 方法会自动调用到下一个 inBoundHandler 的 channelRead() 方法，并且会把当前 inBoundHandler 里处理完毕的对象传递到下一个 inBoundHandler。</p><p><font color="red">inBoundHandler的添加顺序和传递顺序一致，顺序为 A -&gt; B -&gt; C。</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 我们继续在服务端的 pipeline 添加三个 ChanneloutBoundHandler</span><br><span class="line">serverBootstrap</span><br><span class="line">        .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            protected void initChannel(NioSocketChannel ch) &#123;</span><br><span class="line">                // inBound，处理读数据的逻辑链</span><br><span class="line">                ch.pipeline().addLast(new InBoundHandlerA());</span><br><span class="line">                ch.pipeline().addLast(new InBoundHandlerB());</span><br><span class="line">                ch.pipeline().addLast(new InBoundHandlerC());</span><br><span class="line">                 </span><br><span class="line">                // outBound，处理写数据的逻辑链</span><br><span class="line">                ch.pipeline().addLast(new OutBoundHandlerA());</span><br><span class="line">                ch.pipeline().addLast(new OutBoundHandlerB());</span><br><span class="line">                ch.pipeline().addLast(new OutBoundHandlerC());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">// 每个 outBoundHandler 都继承自 ChanneloutBoundHandlerAdapter，然后实现了 write() 方法</span><br><span class="line">public class OutBoundHandlerA extends ChannelOutboundHandlerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;OutBoundHandlerA: &quot; + msg);</span><br><span class="line">        super.write(ctx, msg, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class OutBoundHandlerB extends ChannelOutboundHandlerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;OutBoundHandlerB: &quot; + msg);</span><br><span class="line">        super.write(ctx, msg, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class OutBoundHandlerC extends ChannelOutboundHandlerAdapter &#123;</span><br><span class="line">    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;OutBoundHandlerC: &quot; + msg);</span><br><span class="line">        super.write(ctx, msg, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">outBoundHandler 的执行顺序与我们添加的顺序相反，顺序为 A -&gt; B -&gt; C。</font></p><h2 id="pipeline-的结构"><a href="#pipeline-的结构" class="headerlink" title="pipeline 的结构"></a>pipeline 的结构</h2><p><img src="https://s1.ax1x.com/2020/08/27/d4KtF1.png" alt="d4KtF1.png"></p><h2 id="pipline-的执行顺序"><a href="#pipline-的执行顺序" class="headerlink" title="pipline 的执行顺序"></a>pipline 的执行顺序</h2><p><img src="https://s1.ax1x.com/2020/08/27/d4nHBj.png" alt="d4nHBj.png"></p><p>虽然两种类型的 handler 在一个双向链表里，但是这两类 handler 的分工是不一样的，inBoundHandler 的事件通常只会传播到下一个 inBoundHandler，outBoundHandler 的事件通常只会传播到下一个 outBoundHandler，两者相互不受干扰。</p><h1 id="拆包粘包"><a href="#拆包粘包" class="headerlink" title="拆包粘包"></a>拆包粘包</h1><p>尽管我们在应用层面使用了 Netty，但是对于操作系统来说，只认 TCP 协议，尽管我们的应用层是按照ByteBuf为单位发送数据，但是到了底层操作系统仍然是按照字节流发送数据，因此，数据到了服务端，也是按照字节流的方式读入，然后到了Netty应用层，重新拼装成ByteBuf。问题就在传输和接收过程，这两个ByteBuf可能是不对等的。</p><p>因此，我们需要在客户端根据自定义协议来组装我们应用层的数据包，然后在服务端根据我们的应用层的协议来组装数据包，这个过程通常在服务端称为拆包，而在客户端称为粘包。</p><h2 id="拆包原理"><a href="#拆包原理" class="headerlink" title="拆包原理"></a>拆包原理</h2><ul><li>如果当前读取的数据不足以拼接成一个完整的业务数据包，那就保留该数据，继续从 TCP 缓冲区中读取，直到得到一个完整的数据包。</li><li>如果当前读到的数据加上已经读取的数据足够拼接成一个数据包，那就将已经读取的数据拼接上本次读取的数据，构成一个完整的业务数据包传递到业务逻辑，多余的数据仍然保留，以便和下次读到的数据尝试拼接。</li></ul><h2 id="Netty自带拆包器"><a href="#Netty自带拆包器" class="headerlink" title="Netty自带拆包器"></a>Netty自带拆包器</h2><ol><li><p>固定长度的拆包器 FixedLengthFrameDecoder。如果你的应用层协议非常简单，每个数据包的长度都是固定的，比如 100，那么只需要把这个拆包器加到 pipeline 中，Netty 会把一个个长度为 100 的数据包 (ByteBuf) 传递到下一个 channelHandler。</p></li><li><p>行拆包器 LineBasedFrameDecoder。从字面意思来看，发送端发送数据包的时候，每个数据包之间以换行符作为分隔，接收端通过 LineBasedFrameDecoder 将粘过的 ByteBuf 拆分成一个个完整的应用层数据包。</p></li><li><p>分隔符拆包器 DelimiterBasedFrameDecoder。DelimiterBasedFrameDecoder 是行拆包器的通用版本，只不过我们可以自定义分隔符。</p></li><li><p>基于长度域拆包器 LengthFieldBasedFrameDecoder。最后一种拆包器是最通用的一种拆包器，只要你的自定义协议中包含长度域字段，均可以使用这个拆包器来实现应用层拆包。由于上面三种拆包器比较简单，读者可以自行写出 demo，接下来，我们就结合我们小册的自定义协议，来学习一下如何使用基于长度域的拆包器来拆解我们的数据包。</p></li></ol><p><img src="https://s1.ax1x.com/2020/08/27/d4nojg.png" alt="d4nojg.png"></p><h2 id="channelHandler的生命周期"><a href="#channelHandler的生命周期" class="headerlink" title="channelHandler的生命周期"></a>channelHandler的生命周期</h2><p>ChannelHandler 有很多回调方法，这些回调方法的执行是有顺序的，而这个执行顺序可以称为 ChannelHandler 的生命周期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">LifeCyCleTestHandler.java</span><br><span class="line"> </span><br><span class="line">public class LifeCyCleTestHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;逻辑处理器被添加：handlerAdded()&quot;);</span><br><span class="line">        super.handlerAdded(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void channelRegistered(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;channel 绑定到线程(NioEventLoop)：channelRegistered()&quot;);</span><br><span class="line">        super.channelRegistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;channel 准备就绪：channelActive()&quot;);</span><br><span class="line">        super.channelActive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;channel 有数据可读：channelRead()&quot;);</span><br><span class="line">        super.channelRead(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;channel 某次数据读完：channelReadComplete()&quot;);</span><br><span class="line">        super.channelReadComplete(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;channel 被关闭：channelInactive()&quot;);</span><br><span class="line">        super.channelInactive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;channel 取消线程(NioEventLoop) 的绑定: channelUnregistered()&quot;);</span><br><span class="line">        super.channelUnregistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;逻辑处理器被移除：handlerRemoved()&quot;);</span><br><span class="line">        super.handlerRemoved(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 我们把这个 handler 添加到 构建的 pipeline 中</span><br><span class="line">// 前面代码略</span><br><span class="line">.childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">    protected void initChannel(NioSocketChannel ch) &#123;</span><br><span class="line">        // 添加到第一个</span><br><span class="line">        ch.pipeline().addLast(new LifeCyCleTestHandler());</span><br><span class="line">        ch.pipeline().addLast(new PacketDecoder());</span><br><span class="line">        ch.pipeline().addLast(new LoginRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(new MessageRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(new PacketEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>先运行 NettyServer.java，然后再运行 NettyClient.java</p><p><img src="https://s1.ax1x.com/2020/08/27/d4nzgU.png" alt="d4nzgU.png"></p><p>可以看到，ChannelHandler 回调方法的执行顺序为</p><p>handlerAdded() -&gt; channelRegistered() -&gt; channelActive() -&gt; channelRead() -&gt; channelReadComplete() -&gt; channelInactive() -&gt; channelUnregistered() -&gt; handlerRemoved()</p><ol><li>handlerAdded() ：指的是当检测到新连接之后，调用 ch.pipeline().addLast(new LifeCyCleTestHandler()); 之后的回调，表示在当前的 channel 中，已经成功添加了一个 handler 处理器。</li><li>channelRegistered()：这个回调方法，表示当前的 channel 的所有的逻辑处理已经和某个 NIO 线程建立了绑定关系，accept 到新的连接，然后创建一个线程来处理这条连接的读写，只不过 Netty 里面是使用了线程池的方式，只需要从线程池里面去抓一个线程绑定在这个 channel 上即可，这里的 NIO 线程通常指的是 NioEventLoop,不理解没关系，后面我们还会讲到。</li><li>channelActive()：当 channel 的所有的业务逻辑链准备完毕（也就是说 channel 的 pipeline 中已经添加完所有的 handler）以及绑定好一个 NIO 线程之后，这条连接算是真正激活了，接下来就会回调到此方法。</li><li>channelRead()：客户端向服务端发来数据，每次都会回调此方法，表示有数据可读。</li><li>channelReadComplete()：服务端每次读完一次完整的数据之后，回调该方法，表示数据读取完毕。</li><li>channelInactive(): 表面这条连接已经被关闭了，这条连接在 TCP 层面已经不再是 ESTABLISH 状态了</li><li>channelUnregistered(): 既然连接已经被关闭，那么与这条连接绑定的线程就不需要对这条连接负责了，这个回调就表明与这条连接对应的 NIO 线程移除掉对这条连接的处理</li><li>handlerRemoved()：最后，我们给这条连接上添加的所有的业务逻辑处理器都给移除掉。</li></ol><p><img src="https://s1.ax1x.com/2020/08/27/d4nONq.png" alt="d4nONq.png"></p><h1 id="客户端互聊原理"><a href="#客户端互聊原理" class="headerlink" title="客户端互聊原理"></a>客户端互聊原理</h1><ul><li>如下图，A 要和 B 聊天，首先 A 和 B 需要与服务器建立连接，然后进行一次登录流程，服务端保存用户标识和 TCP 连接的映射关系。</li><li>A 发消息给 B，首先需要将带有 B 标识的消息数据包发送到服务器，然后服务器从消息数据包中拿到 B 的标识，找到对应的 B 的连接，将消息发送给 B。</li></ul><p><img src="https://s1.ax1x.com/2020/08/27/d4nX40.png" alt="d4nX40.png"></p><h2 id="群聊发起和通知"><a href="#群聊发起和通知" class="headerlink" title="群聊发起和通知"></a>群聊发起和通知</h2><p>如下图，要实现群聊，其实和单聊类似</p><ul><li>A，B，C 依然会经历登录流程，服务端保存用户标识对应的 TCP 连接</li><li>A 发起群聊的时候，将 A，B，C 的标识发送至服务端，服务端拿到之后建立一个群聊 ID，然后把这个 ID 与 A，B，C 的标识绑定</li><li>群聊里面任意一方在群里聊天的时候，将群聊 ID 发送至服务端，服务端拿到群聊 ID 之后，取出对应的用户标识，遍历用户标识对应的 TCP 连接，就可以将消息发送至每一个群聊成员</li></ul><p><img src="https://s1.ax1x.com/2020/08/27/d4nvCV.png" alt="d4nvCV.png"></p><h2 id="心跳与空闲检测"><a href="#心跳与空闲检测" class="headerlink" title="心跳与空闲检测"></a>心跳与空闲检测</h2><p>连接假死的现象是：在某一端（服务端或者客户端）看来，底层的 TCP 连接已经断开了，但是应用程序并没有捕获到，因此会认为这条连接仍然是存在的，从 TCP 层面来说，只有收到四次握手数据包或者一个 RST 数据包，连接的状态才表示已断开。</p><h3 id="连接假死会带来以下两大问题"><a href="#连接假死会带来以下两大问题" class="headerlink" title="连接假死会带来以下两大问题"></a>连接假死会带来以下两大问题</h3><ul><li>对于服务端来说，因为每条连接都会耗费 cpu 和内存资源，大量假死的连接会逐渐耗光服务器的资源，最终导致性能逐渐下降，程序奔溃。</li><li>对于客户端来说，连接假死会造成发送数据超时，影响用户体验。</li></ul><h3 id="通常，连接假死由以下几个原因造成的"><a href="#通常，连接假死由以下几个原因造成的" class="headerlink" title="通常，连接假死由以下几个原因造成的"></a>通常，连接假死由以下几个原因造成的</h3><ul><li>应用程序出现线程堵塞，无法进行数据的读写。</li><li>客户端或者服务端网络相关的设备出现故障，比如网卡，机房故障。</li><li>公网丢包。公网环境相对内网而言，非常容易出现丢包，网络抖动等现象，如果在一段时间内用户接入的网络连续出现丢包现象，那么对客户端来说数据一直发送不出去，而服务端也是一直收不到客户端来的数据，连接就一直耗着。</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>要处理假死问题首先我们要实现客户端与服务端定期发送心跳，在这里，其实服务端只需要对客户端的定时心跳包进行回复。</li><li>客户端与服务端如果都需要检测假死，那么直接在 pipeline 的最前方插入一个自定义 IdleStateHandler，在 channelIdle() 方法里面自定义连接假死之后的逻辑。</li><li>通常空闲检测时间要比发送心跳的时间的两倍要长一些，这也是为了排除偶发的公网抖动，防止误判</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为&lt;a href=&quot;https://juejin.im/book/6844733738119593991&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Netty 入门与实战：仿写微信 IM 即时通讯系统》&lt;/a&gt; 的读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="Netty" scheme="https://jelly54.github.io/categories/Netty/"/>
    
    
      <category term="原理" scheme="https://jelly54.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="网络" scheme="https://jelly54.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="netty" scheme="https://jelly54.github.io/tags/netty/"/>
    
      <category term="NIO" scheme="https://jelly54.github.io/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>synchronized的锁升级、锁膨胀</title>
    <link href="https://jelly54.github.io/java-lock-upgrade/"/>
    <id>https://jelly54.github.io/java-lock-upgrade/</id>
    <published>2020-08-25T12:55:37.000Z</published>
    <updated>2020-08-28T05:56:07.835Z</updated>
    
    <content type="html"><![CDATA[<p>本文将将讲解java中synchronized从偏向锁逐步走到轻量级锁、自旋锁再到重量级锁的过程，以及java8中的锁降级优化。</p><a id="more"></a><ul><li><a href="#%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a></li><li><a href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81">轻量级锁</a></li><li><a href="#%E8%87%AA%E6%97%8B%E9%94%81">自旋锁</a></li><li><a href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81">重量级锁</a></li><li><a href="#%E9%94%81%E9%99%8D%E7%BA%A7">锁降级</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%94%81%E4%BF%A1%E6%81%AF%E5%AD%98%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E5%A4%B4%E9%87%8C">为什么锁信息存放在对象头里</a></li></ul><h1 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h1><p>偏向<strong>第一个</strong>拿到锁的线程。</p><p>即第一个拿到锁的线程，锁会在对象头Mark Word中通过CAS<strong>记录线程ID</strong>，该线程以后每次拿锁时都<strong>不需要进行CAS</strong>（指轻量级锁）。</p><p>如果该线程正在执行同步代码块时有其他线程在<strong>竞争</strong>（指其他线程尝试CAS让Mark Work设置自己的线程ID），会<strong>被升级</strong>为轻量级锁。</p><p>如果其他线程发现Mark Word里记的不是自己，且发现原持有偏向锁的线程已经执行完同步代码块，会尝试CAS把Mark Word中的改为自己的线程ID。</p><h1 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h1><p>轻量级锁就是通过<strong>CAS</strong>进行加锁的。</p><p>JVM会给线程的<strong>栈帧</strong>中创建一个叫<strong>锁记录Lock Record</strong>的空间，把对象头Mark Word复制到该空间里（Displaced Mark Word），并通过<strong>CAS</strong>尝试把原对象头Mark Word中锁记录指针指向该锁记录。如果成功，表示线程拿到了锁。如果失败，则进行自选（<strong>自旋锁</strong>），自旋超过一定次数时升级为重量级锁，这时该线程会被内核挂起。</p><h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><p>轻量级锁膨胀为重量级锁前，线程在执行monitorenter指令进入<strong>等待队列</strong>时，会通过<strong>自旋</strong>去尝试获得锁。</p><p>如果自旋超过一定次数时还未拿到锁，就会进入<strong>阻塞</strong>状态，等待内核来调度。此时会发生内核态与用户态之间的上下文切换，所以会影响性能（引入自旋锁就是为了减少这个开销）。</p><p>因为后面的线程也进行自选尝试获取锁，所以这对于已被阻塞的那些线程来说，会<strong>不公平</strong>。</p><h1 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h1><p>重量级锁就是通过内核来操作线程。因为频繁出现内核态与用户态的切换，会严重影响性能。</p><p>升级为重量级锁时会在堆中创建monitor对象，并将Mark Work指向该monitor对象。monitor中有cxq（ContentionList），EntryList，WaitSet，owner</p><p><img src="https://s1.ax1x.com/2020/08/27/d4HTbR.png" alt="d4HTbR.png"></p><h1 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h1><p>Hotspot在1.8开始有了锁降级。在STW期间JVM进入安全点时如果发现有闲置的monitor（重量级锁对象），就会进行锁降级。</p><p><img src="https://s1.ax1x.com/2020/08/27/d4Hor9.jpg" alt="d4Hor9.jpg"></p><h1 id="为什么锁信息存放在对象头里"><a href="#为什么锁信息存放在对象头里" class="headerlink" title="为什么锁信息存放在对象头里"></a>为什么锁信息存放在对象头里</h1><p>死磕Sunchronized底层实现–概论中：</p><p>因为在Java中任意对象都可以用作锁，因此必定要有一个映射关系，存储该对象以及其对应的锁信息（比如当前哪个线程持有锁，哪些线程在等待）。一种很直观的方法是，用一个全局map，来存储这个映射关系，但这样会有一些问题：需要对map做线程安全保障，不同的<em>sunchronized</em>之间会互相影响，性能差；另外当同步对象较多时，该map可能会占用比较多的内存。</p><p>所以最好的办法是将这个映射关系存储在对象头中，因为对象头本身也有一些hashcode、GC相关的数据，所以如果能将锁信息与这些信息<strong>共存</strong>在对象头中就好了。</p><p>也就是说，如果用一个全局map来存对象的锁信息，还需要对该map做线程安全处理，不同的锁之间会有影响，所以直接存到对象头。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将将讲解java中synchronized从偏向锁逐步走到轻量级锁、自旋锁再到重量级锁的过程，以及java8中的锁降级优化。&lt;/p&gt;
    
    </summary>
    
      <category term="Java锁" scheme="https://jelly54.github.io/categories/Java%E9%94%81/"/>
    
    
      <category term="锁" scheme="https://jelly54.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>断点续传小解</title>
    <link href="https://jelly54.github.io/net-break-transport/"/>
    <id>https://jelly54.github.io/net-break-transport/</id>
    <published>2020-08-23T13:05:05.000Z</published>
    <updated>2020-08-28T06:00:32.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="断点续传的原理"><a href="#断点续传的原理" class="headerlink" title="断点续传的原理"></a>断点续传的原理</h1><p>HTTP 协议是互联网上应用最广泛网络传输协议之一，它基于 TCP/IP 通信协议来传递数据。断点续传的奥秘就隐藏在这 HTTP 协议中了。</p><p>我们知道HTTP请求会有一个Request header 和 Response header，在请求头里边有个和Range相关的参数</p><a id="more"></a><p>当下载文件的时候，response header会有如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 65804256  // 请求的文件的大小，单位 byte</span><br><span class="line">Accept-Ranges: bytes      // 是否允许指定传输范围，bytes：范围请求的单位是 bytes （字节），none：不支持任何范围请求单位，</span><br><span class="line">Last-Modified: Tue, 07 Jul 2020 13:19:46 GMT  // 服务端文件最后修改时间，可以用于校验文件是否更改过</span><br><span class="line">x-bs-meta-crc32: 3545941535 // crc32，可以用于校验文件是否更改过</span><br><span class="line">ETag: dcd0bfef7d90dbb3de50a26b875143fc //Etag 标签，可以用于校验文件是否更改过</span><br></pre></td></tr></table></figure><p>可见<font color="red">并不是所有的下载都支持断点续传，只有在response header中有 Accpet-Ranges: bytes字段时，才可以断点续传。</font></p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>利用content-range字段，就可以实现断点续传了。只需要在response header中指定Content-Range值就可以了。</p><p>使用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Content-Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;/&lt;size&gt; // size 为文件总大小,如果不知道可以用 *</span><br><span class="line">Content-Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;/*  </span><br><span class="line">Content-Range: &lt;unit&gt;=&lt;range-start&gt;-</span><br><span class="line">Content-Range: &lt;unit&gt;=*/&lt;size&gt;</span><br></pre></td></tr></table></figure><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>单位 bytes，从第 10 个 bytes 开始下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Range: bytes=10-</span><br></pre></td></tr></table></figure><p>单位 bytes，从第 10 个 bytes 开始下载，下载到第100个 bytes</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Range: bytes=10-100</span><br></pre></td></tr></table></figure><h1 id="重启续传文件时保证文件一致性"><a href="#重启续传文件时保证文件一致性" class="headerlink" title="重启续传文件时保证文件一致性"></a>重启续传文件时保证文件一致性</h1><h2 id="下载中，如何保证文件的完整性？"><a href="#下载中，如何保证文件的完整性？" class="headerlink" title="下载中，如何保证文件的完整性？"></a>下载中，如何保证文件的完整性？</h2><p>我们要写的下载器是支持断点续传的，那么在进行续传时，怎么确定文件从我们上次下载时没有进行更新呢？这里通过response header中的几个属性值进行判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Tue, 07 Jul 2020 13:19:46 GMT  // 服务端文件最后修改时间，可以用于校验文件是否更改过</span><br><span class="line">ETag: dcd0bfef7d90dbb3de50a26b875143fc //Etag 标签，可以用于校验文件是否更改过</span><br><span class="line">x-bs-meta-crc32: 3545941535 // crc32，可以用于校验文件是否更改过</span><br></pre></td></tr></table></figure><ul><li>ETag: 根据 HTTP 协议的规定，当文件更新时，是会生成新的 ETag 值的，它类似于文件的指纹信息</li><li>Last-Modified: 只是上次修改时间，有时候可能并不能够证明文件内容被修改过</li></ul><h2 id="写入阶段，如何保证文件顺序"><a href="#写入阶段，如何保证文件顺序" class="headerlink" title="写入阶段，如何保证文件顺序?"></a>写入阶段，如何保证文件顺序?</h2><p>不管单线程还是多线程，由于要断点续传，在写入时都要在指定位置进行字符追加。</p><p>在Java中使用RandomAccessFile类，它可以在使用时指定读写模式，使用 seek 方法可以随意移动要操作的文件指针位置。很适合断点续传的写入场景。使用它你可以快速定位到已知的位置，进行快速检索；也可以在同一个文件的不同位置进行并发读写。</p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>在 aaa.text 文件中的位置 0 开始写入字符 abcdef，在位置 100 的位置开始写入字符 ddeeff。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// rw 为读写模式</span><br><span class="line">try (RandomAccessFile rw = new RandomAccessFile(&quot;test.txt&quot;, &quot;rw&quot;))&#123; </span><br><span class="line">    // 移动文件内容指针位置 </span><br><span class="line">    rw.seek(0);</span><br><span class="line">    rw.writeChars(&quot;abc&quot;);</span><br><span class="line">    rw.seek(100);</span><br><span class="line">    rw.writeChars(&quot;ddd&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="网速贷宽固定，为什么多线程下载可以提速"><a href="#网速贷宽固定，为什么多线程下载可以提速" class="headerlink" title="网速贷宽固定，为什么多线程下载可以提速"></a>网速贷宽固定，为什么多线程下载可以提速</h1><p>最大网速是固定的，运营商给你 100Mbs的网速，不管你怎么使用，速度最大也就是100/8=12.5MB/s。那么为什么多线程下载可以提高下载速度呢?</p><p>理论上来说，单线程下载就可以达到最大的理想网速，但是事实是，网络经常不那么通畅，很难达到理想的最大速度，也就是说只有在网路不那么通畅的时候，多线程下载才能提速。</p><h2 id="多线程下载提速原因"><a href="#多线程下载提速原因" class="headerlink" title="多线程下载提速原因"></a>多线程下载提速原因</h2><p>HTTP 协议在传输时候是基于 TCP 协议传输数据的，TCP 协具有拥塞控制机制。拥塞控制 是TCP 的一个避免网络拥塞的算法，它是基于和性增长/乘性降低这样的控制方法来控制拥塞的。</p><p><img src="https://s1.ax1x.com/2020/08/01/a8Gc0s.png" alt="a8Gc0s.png"></p><p>简单来说就是在 TCP 开始传输数据时，服务端会不断的探测可用带宽。在一个传输内容段被成功接收后，会加倍传输两倍段内容，如果再次被成功接收，就继续加倍，直到发生了丢包，这是这也被叫做慢启动。当达到<strong>慢启动阀值（ssthresh）</strong>时，慢启动算法就会转换为线性增长的阶段，每次只增加一个分段，放缓增加速度。我觉得其实慢启动的加倍增速过程并不慢，只是一种叫法。</p><p>但是当发生了丢包，也就是检测到拥塞时，发送方就会将发送段大小降低一个乘数，比如二分之一，慢启动阈值降为超时前拥塞窗口的一半大小、拥塞窗口会降为1个MSS，并且重新回到慢启动阶段。这时多线程的优势就体现出来了，因为你的多线程会让这个速度减速没有那么猛烈，毕竟这时可能有另一个线程正处在慢启动的在最终加速阶段，这样总体的下载速度就优于单线程了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;断点续传的原理&quot;&gt;&lt;a href=&quot;#断点续传的原理&quot; class=&quot;headerlink&quot; title=&quot;断点续传的原理&quot;&gt;&lt;/a&gt;断点续传的原理&lt;/h1&gt;&lt;p&gt;HTTP 协议是互联网上应用最广泛网络传输协议之一，它基于 TCP/IP 通信协议来传递数据。断点续传的奥秘就隐藏在这 HTTP 协议中了。&lt;/p&gt;
&lt;p&gt;我们知道HTTP请求会有一个Request header 和 Response header，在请求头里边有个和Range相关的参数&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://jelly54.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="原理" scheme="https://jelly54.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="TCP/IP" scheme="https://jelly54.github.io/tags/TCP-IP/"/>
    
      <category term="网络" scheme="https://jelly54.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>基于深度学习的车型APP-毕设</title>
    <link href="https://jelly54.github.io/graduation-project/"/>
    <id>https://jelly54.github.io/graduation-project/</id>
    <published>2020-07-13T02:01:42.000Z</published>
    <updated>2020-08-28T02:39:14.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>通过深度学习技术搭建残差网络，<a href="http://mmlab.ie.cuhk.edu.hk/datasets/comp_cars/index.html" target="_blank" rel="noopener">使用CompsCars数据集</a> 进行车型识别模型的训练，并将训练好的模型移植到了Android端，实现了通过手机扫一扫的方式进行汽车车型识别的功能。</p><p>项目涉及到的技术点较多，需要开发者有一定的技术功底。如：python语言的使用、深度学习框架pytorch的使用、爬虫脚本的理解、Java语言的使用、Android平台架构的理解等等。</p><p>虽然属于跨语言开发，但是要求并不高，只要达到入门级别即可看懂本项目，并可以尝试一些定制化的改造。毕竟框架已经搭建好了，只需要修改数据源、重新训练出模型，就可以实现一款新的应用啦。</p><a id="more"></a><hr><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p>以下视频将展示所有功能完成后的APP的使用情况。</p><p><a href="https://www.bilibili.com/video/BV1Pk4y1B7qK" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Pk4y1B7qK</a></p><h2 id="模型训练精度"><a href="#模型训练精度" class="headerlink" title="模型训练精度"></a>模型训练精度</h2><p>以下是使用Resnet-34进行400次车型识别训练的 train-validation图表。</p><p><img src="https://s1.ax1x.com/2020/07/14/Utg8HO.png" alt="Utg8HO.png"></p><p>以下是使用Resnet-34进行400次车型识别训练 Top-1的错误率。</p><p><img src="https://s1.ax1x.com/2020/07/14/Utg3DK.png" alt="Utg3DK.png"></p><p>以下是使用Resnet-34进行400次车型识别训练 Top-5的错误率。</p><p><img src="https://s1.ax1x.com/2020/07/14/UtgJED.png" alt="UtgJED.png"></p><h2 id="扫一扫识别功能"><a href="#扫一扫识别功能" class="headerlink" title="扫一扫识别功能"></a>扫一扫识别功能</h2><p>以下是移植到android平台后进行识别的结果展示图。<br><img src="https://s1.ax1x.com/2020/07/14/UtcItH.png" alt="UtcItH.png"></p><hr><h1 id="使用的技术-amp-框架"><a href="#使用的技术-amp-框架" class="headerlink" title="使用的技术&amp;框架"></a>使用的技术&amp;框架</h1><ul><li>开发语言：Python、Java</li><li>技术框架：pytorch、resnet-34、Android平台</li><li>可选借助平台：百度AI平台</li><li>项目构成：模型训练项目、爬虫项目、APP开发项目</li></ul><h2 id="软-硬件需求"><a href="#软-硬件需求" class="headerlink" title="软/硬件需求"></a>软/硬件需求</h2><h3 id="机器要求"><a href="#机器要求" class="headerlink" title="机器要求"></a>机器要求</h3><blockquote><p>因为涉及到机器学习模型训练，所以你应该拥有一台用来训练模型的机器，<strong>且需要搭载支持CUDA的GPU</strong>（如：GeForce、GTX、Tesla等），显存大小，自然是越大越好。</p></blockquote><p>本人项目环境：</p><ul><li>windows10 专业版；GeForce MAX150；独显 2G；1T硬盘</li></ul><p>也就是说这是最低配了，你至少要和我同一配置。</p><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><ul><li>Pycharm：用来训练模型、pyhton爬虫、模型移植脚本</li><li>Android Studio：用来开发安卓APP</li></ul><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p><strong>数据集是项目最重要的一部分，有了数据集才能开始训练</strong></p><p>本项目使用的是 <a href="http://mmlab.ie.cuhk.edu.hk/datasets/comp_cars/index.html" target="_blank" rel="noopener">香港中文大学的CompCars细粒度汽车数据集</a>。</p><p><img src="http://mmlab.ie.cuhk.edu.hk/datasets/comp_cars/illustration.png" alt="CompCars数据集"></p><p>需要的同学可以私聊找我要网盘链接。</p><hr><h1 id="各模块介绍"><a href="#各模块介绍" class="headerlink" title="各模块介绍"></a>各模块介绍</h1><h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><p>Github 地址：<a href="https://github.com/jelly54/pytorch_train" target="_blank" rel="noopener">pytorch_train</a></p><p><img src="https://s1.ax1x.com/2020/07/14/UtyvKf.png" alt="UtyvKf.png"></p><p>训练模型主要分为五个模块：启动器、自定义数据加载器、网络模型、学习率/损失率调整以及训练可视化。</p><p>启动器是项目的入口，通过对启动器参数的设置，可以进行很多灵活的启动方式，下图为部分启动器参数设置。</p><p><img src="https://s1.ax1x.com/2020/07/14/UtciwD.png" alt="UtciwD.png"></p><p>任何一个深度学习的模型训练都是离不开数据集的，根据多种多样的数据集，我们应该使用一个方式将数据集用一种通用的结构返回，方便网络模型的加载处理。</p><p><img src="https://s1.ax1x.com/2020/07/14/Utc9OK.png" alt="Utc9OK.png"></p><p>这里使用了残差网络Resnet-34，代码中还提供了Resnet-18、Resnet-50、Resnet-101以及Resnet-152。残差结构是通过一个快捷连接，极大的减少了参数数量，降低了内存使用。</p><p>以下为残差网络的基本结构和Resnet-34 部分网络结构图。</p><p><img src="https://s1.ax1x.com/2020/07/14/UtcPeO.png" alt="UtcPeO.png"></p><p><img src="https://s1.ax1x.com/2020/07/14/Utcn6P.png" alt="Utcn6P.png"></p><p>除了最开始看到的train-val图表、Top-、Top-5的error记录表以外，在训练过程中，使用进度条打印当前训练的进度、训练精度等信息。打印时机可以通过上边提到的 启动器 优雅地配置。</p><p><img src="https://s1.ax1x.com/2020/07/14/Utc3kQ.png" alt="Utc3kQ.png"></p><p>以下为最终的项目包架构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pytorch_train</span><br><span class="line">  |-- data                -- 存放读取训练、校验、测试数据路径的txt</span><br><span class="line">  |   |-- train.txt       </span><br><span class="line">  |   |-- val.txt</span><br><span class="line">  |   |-- test.txt</span><br><span class="line">  |-- result              -- 存放最终生成训练结果的目录</span><br><span class="line">  |-- util                -- 模型移植工具</span><br><span class="line">  |-- clr.py              -- 学习率</span><br><span class="line">  |-- dataset.py          -- 自定义数据集</span><br><span class="line">  |-- flops_benchmark.py  -- 统计每秒浮点运算次数</span><br><span class="line">  |-- logger.py           -- 日志可视化</span><br><span class="line">  |-- mobile_net.py       -- 网络模型之一 mobile_net2</span><br><span class="line">  |-- resnet.py           -- 网络模型之一 Resnet系列</span><br><span class="line">  |-- run.py              -- 具体执行训练、测试方法</span><br><span class="line">  |-- start.py            -- 启动器</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/07/14/UtgkuV.png" alt="UtgkuV.png"></p><h2 id="数据抓取"><a href="#数据抓取" class="headerlink" title="数据抓取"></a>数据抓取</h2><p>Github 地址：<a href="https://github.com/jelly54/crawler/tree/master/dongchedi" target="_blank" rel="noopener">crawer/dongchedi</a></p><p><img src="https://s1.ax1x.com/2020/07/14/UtyXxP.png" alt="UtyXxP.png"></p><p>最终获取的数据如下图：</p><p><img src="https://s1.ax1x.com/2020/07/14/Utc8Yj.png" alt="Utc8Yj.png"></p><h2 id="模型移植"><a href="#模型移植" class="headerlink" title="模型移植"></a>模型移植</h2><p>Github 地址：<a href="https://github.com/jelly54/pytorch_train/blob/master/util/transfor.py" target="_blank" rel="noopener">pytorch_train/transfor</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line">model_pth = os.path.join(<span class="string">"results"</span>, <span class="string">"2020-04-27_10-27-17"</span>, <span class="string">'checkpoint.pth.tar'</span>)</span><br><span class="line"><span class="comment"># 将resnet34模型保存为Android可以调用的文件</span></span><br><span class="line">mobile_pt = os.path.join(<span class="string">"results"</span>, <span class="string">"2020-04-27_10-27-17"</span>, <span class="string">'resnet34.pt'</span>)</span><br><span class="line">num_class = <span class="number">13</span></span><br><span class="line">device = <span class="string">'cpu'</span>  <span class="comment"># 'cuda:0'  # cpu</span></span><br><span class="line"></span><br><span class="line">model = torchvision.models.resnet34(num_classes=num_class)</span><br><span class="line">model = torch.nn.DataParallel(model, [<span class="number">0</span>])</span><br><span class="line">model.to(device=device)</span><br><span class="line"></span><br><span class="line">checkpoint = torch.load(model_pth, map_location=device)</span><br><span class="line">model.load_state_dict(checkpoint[<span class="string">'state_dict'</span>])</span><br><span class="line"></span><br><span class="line">model.eval()  <span class="comment"># 模型设为评估模式</span></span><br><span class="line"><span class="comment"># 1张3通道224*224的图片</span></span><br><span class="line">input_tensor = torch.rand(<span class="number">1</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>)  <span class="comment"># 设定输入数据格式</span></span><br><span class="line">traced_script_module = torch.jit.trace(model.module, input_tensor)  <span class="comment"># 模型转化</span></span><br><span class="line">traced_script_module.save(mobile_pt)  <span class="comment"># 保存文件</span></span><br></pre></td></tr></table></figure><h2 id="安卓界面-amp-数据走向"><a href="#安卓界面-amp-数据走向" class="headerlink" title="安卓界面&amp;数据走向"></a>安卓界面&amp;数据走向</h2><p>Github 地址：<a href="https://github.com/jelly54/carIdentify" target="_blank" rel="noopener">carIdentify</a></p><p><img src="https://s1.ax1x.com/2020/07/14/UtyO2t.png" alt="UtyO2t.png"></p><p>实现了以下功能：</p><ul><li>调用摄像头权限自动申请</li><li>摄像头预览</li><li>读取pytorch训练模型</li><li>调用第三方接口，精准预测</li></ul><p>最终界面展示：</p><p><img src="https://s1.ax1x.com/2020/07/14/UtgABT.png" alt="UtgABT.png"></p><p>安卓项目结构如图：</p><p><img src="https://s1.ax1x.com/2020/07/14/UtgEHU.png" alt="UtgEHU.png"></p><hr><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="启动模型训练"><a href="#启动模型训练" class="headerlink" title="启动模型训练"></a>启动模型训练</h2><p><font color="red">启动前需要确保你已经有了本项目使用的数据集 CompCars</font></p><h3 id="重新开始新的训练"><a href="#重新开始新的训练" class="headerlink" title="重新开始新的训练"></a>重新开始新的训练</h3><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python start.py --data_root "./data" --gpus 0,1,2 -w 2 -b 120 --num_class 13</span><br></pre></td></tr></table></figure><ul><li>–data_root 数据集路径位置</li><li>–gups 使用gpu训练的块数</li><li>-w 为gpu加载自定义数据集的工作线程</li><li>-b 用来gpu训练的 batch size是多少</li><li>–num_class 分类类别数量</li></ul><h3 id="使用上次训练结果继续训练"><a href="#使用上次训练结果继续训练" class="headerlink" title="使用上次训练结果继续训练"></a>使用上次训练结果继续训练</h3><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python start.py --data_root "./data" --gpus 0,1,2 -w 2 -b 120 --num_class 13 --resume "results/2020-04-14_12-36-16"</span><br></pre></td></tr></table></figure><ul><li>–data_root 数据集路径位置</li><li>–gups 使用gpu训练的块数</li><li>-w 为gpu加载自定义数据集的工作线程</li><li>-b 用来gpu训练的 batch size是多少</li><li>–num_class 分类类别数量</li><li>–resume 上次训练结果文件夹，可继续上次的训练</li></ul><h3 id="模型移植-1"><a href="#模型移植-1" class="headerlink" title="模型移植"></a>模型移植</h3><p>将训练好的模型转换为Android可以执行的模型</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python transfor.py</span><br></pre></td></tr></table></figure><h3 id="项目定制化"><a href="#项目定制化" class="headerlink" title="项目定制化"></a>项目定制化</h3><ul><li>找寻自己的数据集</li><li>需要修改启动脚本中 <strong>–num_class</strong>，模型类别</li></ul><p>目前项目中具备很多备注记录，稍加review代码就可以理解，如有不清楚，可以私信询问。</p><h2 id="启动APP"><a href="#启动APP" class="headerlink" title="启动APP"></a>启动APP</h2><p>APP下载链接：<a href="https://pan.baidu.com/s/1X7tobj4R302WmGu116-2mg" target="_blank" rel="noopener">https://pan.baidu.com/s/1X7tobj4R302WmGu116-2mg</a> 提取码: 1606</p><ul><li>安装完成后</li><li>同意调用系统相机权限</li><li>使用扫一扫对准汽车</li><li>稍后将会展示识别后的结果和识别的图片</li></ul><p>具体使用方式，可参见：<a href="https://www.bilibili.com/video/BV1Pk4y1B7qK" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Pk4y1B7qK</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;通过深度学习技术搭建残差网络，&lt;a href=&quot;http://mmlab.ie.cuhk.edu.hk/datasets/comp_cars/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;使用CompsCars数据集&lt;/a&gt; 进行车型识别模型的训练，并将训练好的模型移植到了Android端，实现了通过手机扫一扫的方式进行汽车车型识别的功能。&lt;/p&gt;
&lt;p&gt;项目涉及到的技术点较多，需要开发者有一定的技术功底。如：python语言的使用、深度学习框架pytorch的使用、爬虫脚本的理解、Java语言的使用、Android平台架构的理解等等。&lt;/p&gt;
&lt;p&gt;虽然属于跨语言开发，但是要求并不高，只要达到入门级别即可看懂本项目，并可以尝试一些定制化的改造。毕竟框架已经搭建好了，只需要修改数据源、重新训练出模型，就可以实现一款新的应用啦。&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="https://jelly54.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://jelly54.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="残差网络" scheme="https://jelly54.github.io/tags/%E6%AE%8B%E5%B7%AE%E7%BD%91%E7%BB%9C/"/>
    
      <category term="车型识别" scheme="https://jelly54.github.io/tags/%E8%BD%A6%E5%9E%8B%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之观察者模式</title>
    <link href="https://jelly54.github.io/design-pattern-observa/"/>
    <id>https://jelly54.github.io/design-pattern-observa/</id>
    <published>2020-06-01T10:58:05.000Z</published>
    <updated>2020-08-28T06:59:48.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。（摘自Head First中文版51页）</p><a id="more"></a><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某主题对象。该主题对象状态变化时，会通知所有观察者对象，让其能够自动更新。它将观察者和被观察者的对象分离开，提高了应用程序的可维护性和重用性。</p><p>观察者模式可分为推模型和拉模型两种方式。</p><ol><li>推模型： 主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。</li><li>拉模型：主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。拉模型通常都是把主题对象当做参数传递。</li></ol><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="https://s1.ax1x.com/2020/05/14/YBRGw9.png" alt="YBRGw9.png"></p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>被观察者接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line">//添加观察者</span><br><span class="line">public void addObserver(Observer o);</span><br><span class="line">//删除观察者</span><br><span class="line">public void deleteObserver(Observer o);</span><br><span class="line">//通知所有观察者</span><br><span class="line">public void notifyAllObservers();</span><br><span class="line">//通知指定观察者</span><br><span class="line">public void notifyObserver(Observer o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察者接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Observer &#123;</span><br><span class="line">//观察者获取观察对象的更新</span><br><span class="line">void update (Subject o, Object arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的被观察者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteSubject implements Subject &#123;</span><br><span class="line">//所持有的观察者们</span><br><span class="line">List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();</span><br><span class="line">//Subject 被观察的相关属性</span><br><span class="line">private String state = null;</span><br><span class="line">@Override</span><br><span class="line">public void addObserver(Observer o) &#123;</span><br><span class="line">observers.add(o);//添加到被观察者的 集合中</span><br><span class="line">o.update(this, &quot;观察成功&quot;);//通知观察者，观察成功</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void deleteObserver(Observer o) &#123;</span><br><span class="line">observers.remove(o);//删除观察者</span><br><span class="line">o.update(this, &quot;解除观察&quot;);//通知观察者接触观察</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void notifyAllObservers() &#123;//通知所有观察者，被观察者的状态</span><br><span class="line">for (int i = 0; i &lt; observers.size(); i++) &#123;</span><br><span class="line">observers.get(i).update(this, state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void notifyObserver(Observer o) &#123;//通知指定观察者   被观察对象的状态</span><br><span class="line">observers.get(observers.indexOf(o)).update(this, state);;</span><br><span class="line">&#125;</span><br><span class="line">public String getState() &#123;</span><br><span class="line">return state;</span><br><span class="line">&#125;</span><br><span class="line">public void setState(String state) &#123;</span><br><span class="line">this.state = state;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的观察对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteObserver1 implements Observer&#123;</span><br><span class="line">//持有的被观察的对象</span><br><span class="line">public ConcreteSubject csub = null;</span><br><span class="line">@Override</span><br><span class="line">public void update(Subject o, Object arg) &#123;</span><br><span class="line">csub = (ConcreteSubject) o;</span><br><span class="line">System.out.println(&quot;ConcreteObserver1  获得更新--&quot; + o.getClass().getSimpleName()+ &quot;  发生了 &quot; + arg.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的观察对象2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteObserver2 implements Observer &#123;</span><br><span class="line">//持有的被观察的对象</span><br><span class="line">public ConcreteSubject csub = null;</span><br><span class="line">@Override</span><br><span class="line">public void update(Subject o, Object arg) &#123;</span><br><span class="line">System.out.println(&quot;ConcreteObserver2  获得更新--&quot; + o.getClass().getSimpleName()+ &quot;  发生了 &quot; + arg.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ConcreteSubject csub = new ConcreteSubject();</span><br><span class="line">ConcreteObserver1 observer1 = new ConcreteObserver1();</span><br><span class="line">ConcreteObserver2 observer2 = new ConcreteObserver2();</span><br><span class="line">csub.setState(&quot;苹果x大降价&quot;);</span><br><span class="line">//开启观察</span><br><span class="line">csub.addObserver(observer1);</span><br><span class="line">csub.addObserver(observer2);</span><br><span class="line">//observer1 拉取消息</span><br><span class="line">observer1.csub.notifyObserver(observer1);</span><br><span class="line">//更新状态</span><br><span class="line">csub.setState(&quot;MacBook Pro 七折疯抢&quot;);</span><br><span class="line">//subject 推消息</span><br><span class="line">csub.notifyAllObservers();</span><br><span class="line">//放弃观察</span><br><span class="line">csub.deleteObserver(observer1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ol><li>当一个对象的改变需要同时改变其他对象，并且它不知道具体有多少对象有待改变时，应考虑使用观察者模式；</li><li>一个抽象模型有两个方面，其中一方面依赖与另一方面，这是观察者模式可以将这两者封装在独立的对象中是它们各自独立地改变和复用。<br>总的来讲，观察者模式所做的工作其实就是在解除耦合，让耦合的双方都依赖于抽象，而不是依赖于具体，从而使得各自的变化都不会影响另一边的变化。</li></ol><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>观察者模式解除了主题和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>依赖关系并未完全解除，抽象通知者依旧依赖抽象的观察者。</p><p>观察者模式定义了对象之间的一对多关系。主题(可观察者)用一个共同的接口来更新观察者。观察者和被观察者之间用松耦合方式结合，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。</p><p>jdk中有很多观察者模式，java.util.Observable就是其中一种，但是要注意其实现上带来的一些问题。</p><p>我们发现Observable是一个“类”而不是一个“接口”，<strong>更为糟糕的是其甚至都没有实现一个接口</strong>。所以java.util.Observable的实现会产生很多问题，<strong>限制了它的使用和复用</strong>。我们要使用就必须继承它，如果一个类想同时具有Observable类和另一个超类的行为，则会陷入两难之中，毕竟java不支持多继承。在实际项目中使用观察者模式时，一定要注意这个问题，以免带来不必要的麻烦。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。（摘自Head First中文版51页）&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://jelly54.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://jelly54.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="观察者模式" scheme="https://jelly54.github.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之代理模式</title>
    <link href="https://jelly54.github.io/design-pattern-proxy/"/>
    <id>https://jelly54.github.io/design-pattern-proxy/</id>
    <published>2020-05-28T09:56:07.000Z</published>
    <updated>2020-08-28T06:59:15.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>代理是英文 Proxy 翻译过来的。我们在生活中见到过的代理，大概最常见的就是朋友圈中卖面膜的同学了。</p><a id="more"></a><p>她们从厂家拿货，然后在朋友圈中宣传，然后卖给熟人。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI5MjEzOTExMTYy" alt="这里写图片描述"></p><p>按理说，顾客可以直接从厂家购买产品，但是现实生活中，很少有这样的销售模式。一般都是厂家委托给代理商进行销售，顾客跟代理商打交道，而不直接与产品实际生产者进行关联。</p><p>所以，代理就有一种中间人的味道。</p><p>接下来，我们说说软件中的代理模式。</p><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式是面向对象编程中比较常见的设计模式。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI5MjEzOTM4NzM2" alt="这里写图片描述"></p><p>这是常见代理模式常见的 UML 示意图。</p><p>需要注意的有下面几点：</p><ol><li>用户只关心接口功能，而不在乎谁提供了功能。上图中接口是 Subject。</li><li>接口真正实现者是上图的 RealSubject，但是它不与用户直接接触，而是通过代理。</li><li>代理就是上图中的 Proxy，由于它实现了 Subject 接口，所以它能够直接与用户接触。</li><li>用户调用 Proxy 的时候，Proxy 内部调用了 RealSubject。所以，Proxy 是中介者，它可以增强 RealSubject 操作。</li></ol><p>如果难于理解的话，我用事例说明好了。值得注意的是，代理可以分为静态代理和动态代理两种。先从静态代理讲起。</p><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>我们平常去电影院看电影的时候，在电影开始的阶段是不是经常会放广告呢？</p><p>电影是电影公司委托给影院进行播放的，但是影院可以在播放电影的时候，产生一些自己的经济收益，比如卖爆米花、可乐等，然后在影片开始结束时播放一些广告。</p><p>现在用代码来进行模拟。</p><p>首先得有一个接口，通用的接口是代理模式实现的基础。这个接口我们命名为 Movie，代表电影播放的能力。</p><pre><code>package com.frank.test;public interface Movie {    void play();}</code></pre><p>​    </p><p>然后，我们要有一个真正的实现这个 Movie 接口的类，和一个只是实现接口的代理类。</p><pre><code>package com.frank.test;public class RealMovie implements Movie {    @Override    public void play() {        // TODO Auto-generated method stub        System.out.println(&quot;您正在观看电影 《肖申克的救赎》&quot;);    }}</code></pre><p>这个表示真正的影片。它实现了 Movie 接口，play() 方法调用时，影片就开始播放。那么 Proxy 代理呢？</p><pre><code>package com.frank.test;public class Cinema implements Movie {    RealMovie movie;    public Cinema(RealMovie movie) {        super();        this.movie = movie;    }</code></pre><p>​<br>        @Override<br>        public void play() {</p><pre><code>        guanggao(true);        movie.play();        guanggao(false);    }    public void guanggao(boolean isStart){        if ( isStart ) {            System.out.println(&quot;电影马上开始了，爆米花、可乐、口香糖9.8折，快来买啊！&quot;);        } else {            System.out.println(&quot;电影马上结束了，爆米花、可乐、口香糖9.8折，买回家吃吧！&quot;);        }    }}</code></pre><p>​    </p><p>Cinema 就是 Proxy 代理对象，它有一个 play() 方法。不过调用 play() 方法时，它进行了一些相关利益的处理，那就是广告。现在，我们编写测试代码。</p><pre><code>package com.frank.test;public class ProxyTest {    public static void main(String[] args) {        RealMovie realmovie = new RealMovie();        Movie movie = new Cinema(realmovie);        movie.play();    }}</code></pre><p>​    </p><p>然后观察结果：</p><pre><code>电影马上开始了，爆米花、可乐、口香糖9.8折，快来买啊！您正在观看电影 《肖申克的救赎》电影马上结束了，爆米花、可乐、口香糖9.8折，买回家吃吧！</code></pre><p>​    </p><p>现在可以看到，<strong>代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。</strong></p><p>上面介绍的是静态代理的内容，为什么叫做静态呢？因为它的类型是事先预定好的，比如上面代码中的 Cinema 这个类。下面要介绍的内容就是动态代理。</p><h1 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h1><p>既然是代理，那么它与静态代理的功能与目的是没有区别的，唯一有区别的就是动态与静态的差别。</p><p>那么在动态代理的中这个动态体现在什么地方？</p><p>上一节代码中 Cinema 类是代理，我们需要手动编写代码让 Cinema 实现 Movie 接口，而在动态代理中，我们可以让程序在运行的时候自动在内存中创建一个实现 Movie 接口的代理，而不需要去定义 Cinema 这个类。这就是它被称为动态的原因。</p><p>也许概念比较抽象。现在实例说明一下情况。</p><p>假设有一个大商场，商场有很多的柜台，有一个柜台卖茅台酒。我们进行代码的模拟。</p><pre><code>package com.frank.test;public interface SellWine {     void mainJiu();}</code></pre><p>SellWine 是一个接口，你可以理解它为卖酒的许可证。</p><pre><code>package com.frank.test;public class MaotaiJiu implements SellWine {    @Override    public void mainJiu() {        // TODO Auto-generated method stub        System.out.println(&quot;我卖得是茅台酒。&quot;);    }}</code></pre><p>​    </p><p>然后创建一个类 MaotaiJiu,对的，就是茅台酒的意思。</p><p>我们还需要一个柜台来卖酒：</p><pre><code>package com.frank.test;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;</code></pre><p>​<br>    public class GuitaiA implements InvocationHandler {</p><pre><code>private Object pingpai;</code></pre><p>​<br>        public GuitaiA(Object pingpai) {<br>            this.pingpai = pingpai;<br>        }</p><p>​<br>​<br>        @Override<br>        public Object invoke(Object proxy, Method method, Object[] args)<br>                throws Throwable {<br>            // TODO Auto-generated method stub<br>            System.out.println(“销售开始  柜台是： “+this.getClass().getSimpleName());<br>            method.invoke(pingpai, args);<br>            System.out.println(“销售结束”);<br>            return null;<br>        }</p><pre><code>}</code></pre><p>​    </p><p>GuitaiA 实现了 InvocationHandler 这个类，这个类是什么意思呢？大家不要慌张，待会我会解释。</p><p>然后，我们就可以卖酒了。</p><pre><code>package com.frank.test;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;</code></pre><p>​<br>    public class Test {</p><pre><code>public static void main(String[] args) {    // TODO Auto-generated method stub    MaotaiJiu maotaijiu = new MaotaiJiu();</code></pre><p>​<br>            InvocationHandler jingxiao1 = new GuitaiA(maotaijiu);</p><p>​<br>            SellWine dynamicProxy = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),<br>                    MaotaiJiu.class.getInterfaces(), jingxiao1);</p><pre><code>        dynamicProxy.mainJiu();    }}</code></pre><p>​<br>​    </p><p>这里，我们又接触到了一个新的概念，没有关系，先别管，先看结果。</p><pre><code>销售开始  柜台是： GuitaiA我卖得是茅台酒。销售结束</code></pre><p>​    </p><p>看到没有，我并没有像静态代理那样为 SellWine 接口实现一个代理类，但最终它仍然实现了相同的功能，这其中的差别，就是之前讨论的动态代理所谓“动态”的原因。</p><h2 id="动态代理语法"><a href="#动态代理语法" class="headerlink" title="动态代理语法"></a>动态代理语法</h2><p>放轻松，下面我们开始讲解语法，语法非常简单。</p><p>动态代码涉及了一个非常重要的类 Proxy。正是通过 Proxy 的静态方法 newProxyInstance 才会动态创建代理。</p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><pre><code>public static Object newProxyInstance(ClassLoader loader,                                          Class&lt;?&gt;[] interfaces,                                          InvocationHandler h)</code></pre><p>​    </p><p>下面讲解它的 3 个参数意义。</p><ul><li>loader 自然是类加载器</li><li>interfaces 代码要用来代理的接口</li><li>h 一个 InvocationHandler 对象</li></ul><p>初学者应该对于 InvocationHandler 很陌生，我马上就讲到这一块。</p><h3 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h3><p>InvocationHandler 是一个接口，官方文档解释说，每个代理的实例都有一个与之关联的 InvocationHandler 实现类，如果代理的方法被调用，那么代理便会通知和转发给内部的 InvocationHandler 实现类，由它决定处理。</p><pre><code>public interface InvocationHandler {    public Object invoke(Object proxy, Method method, Object[] args)        throws Throwable;}</code></pre><p>​    </p><p>InvocationHandler 内部只是一个 invoke() 方法，正是这个方法决定了怎么样处理代理传递过来的方法调用。</p><ul><li>proxy 代理对象</li><li>method 代理对象调用的方法</li><li>args 调用的方法中的参数</li></ul><p>因为，Proxy 动态产生的代理会调用 InvocationHandler 实现类，所以 InvocationHandler 是实际执行者。</p><pre><code>public class GuitaiA implements InvocationHandler {    private Object pingpai;</code></pre><p>​<br>        public GuitaiA(Object pingpai) {<br>            this.pingpai = pingpai;<br>        }</p><p>​<br>​<br>        @Override<br>        public Object invoke(Object proxy, Method method, Object[] args)<br>                throws Throwable {<br>            // TODO Auto-generated method stub<br>            System.out.println(“销售开始  柜台是： “+this.getClass().getSimpleName());<br>            method.invoke(pingpai, args);<br>            System.out.println(“销售结束”);<br>            return null;<br>        }</p><pre><code>}</code></pre><p>​    </p><p>GuitaiA 就是实际上卖酒的地方。</p><p>现在，我们加大难度，我们不仅要卖<strong>茅台酒</strong>，还想卖<strong>五粮液</strong>。</p><pre><code>package com.frank.test;public class Wuliangye implements SellWine {    @Override    public void mainJiu() {        // TODO Auto-generated method stub        System.out.println(&quot;我卖得是五粮液。&quot;);    }}</code></pre><p>​    </p><p>Wuliangye 这个类也实现了 SellWine 这个接口，说明它也拥有卖酒的许可证，同样把它放到 GuitaiA 上售卖。</p><pre><code>public class Test {    public static void main(String[] args) {        // TODO Auto-generated method stub        MaotaiJiu maotaijiu = new MaotaiJiu();        Wuliangye wu = new Wuliangye();        InvocationHandler jingxiao1 = new GuitaiA(maotaijiu);        InvocationHandler jingxiao2 = new GuitaiA(wu);        SellWine dynamicProxy = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),                MaotaiJiu.class.getInterfaces(), jingxiao1);        SellWine dynamicProxy1 = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),                MaotaiJiu.class.getInterfaces(), jingxiao2);        dynamicProxy.mainJiu();        dynamicProxy1.mainJiu();    }}</code></pre><p>​    </p><p>我们来看结果：</p><pre><code>销售开始  柜台是： GuitaiA我卖得是茅台酒。销售结束销售开始  柜台是： GuitaiA我卖得是五粮液。销售结束</code></pre><p>​    </p><p>有人会问，dynamicProxy 和 dynamicProxy1 什么区别没有？他们都是动态产生的代理，都是售货员，都拥有卖酒的技术证书。</p><p>我现在扩大商场的经营，除了卖酒之外，还要卖烟。</p><p>首先，同样要创建一个接口，作为卖烟的许可证。</p><pre><code>package com.frank.test;public interface SellCigarette {    void sell();}</code></pre><p>​    </p><p>然后，卖什么烟呢？我是湖南人，那就芙蓉王好了。</p><pre><code>public class Furongwang implements SellCigarette {    @Override    public void sell() {        // TODO Auto-generated method stub        System.out.println(&quot;售卖的是正宗的芙蓉王，可以扫描条形码查证。&quot;);    }}</code></pre><p>​    </p><p>然后再次测试验证：</p><pre><code>package com.frank.test;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;</code></pre><p>​<br>    public class Test {</p><pre><code>    public static void main(String[] args) {        // TODO Auto-generated method stub        MaotaiJiu maotaijiu = new MaotaiJiu();        Wuliangye wu = new Wuliangye();        Furongwang fu = new Furongwang();        InvocationHandler jingxiao1 = new GuitaiA(maotaijiu);        InvocationHandler jingxiao2 = new GuitaiA(wu);        InvocationHandler jingxiao3 = new GuitaiA(fu);        SellWine dynamicProxy = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),                MaotaiJiu.class.getInterfaces(), jingxiao1);        SellWine dynamicProxy1 = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),                MaotaiJiu.class.getInterfaces(), jingxiao2);        dynamicProxy.mainJiu();        dynamicProxy1.mainJiu();        SellCigarette dynamicProxy3 = (SellCigarette) Proxy.newProxyInstance(Furongwang.class.getClassLoader(),                Furongwang.class.getInterfaces(), jingxiao3);        dynamicProxy3.sell();    }}</code></pre><p>​    </p><p>然后，查看结果：</p><pre><code>销售开始  柜台是： GuitaiA我卖得是茅台酒。销售结束销售开始  柜台是： GuitaiA我卖得是五粮液。销售结束销售开始  柜台是： GuitaiA售卖的是正宗的芙蓉王，可以扫描条形码查证。销售结束</code></pre><p>​<br>​    </p><p>结果符合预期。大家仔细观察一下代码，同样是通过 Proxy.newProxyInstance() 方法，却产生了 SellWine 和 SellCigarette 两种接口的实现类代理，这就是动态代理的魔力。</p><h2 id="动态代理的秘密"><a href="#动态代理的秘密" class="headerlink" title="动态代理的秘密"></a>动态代理的秘密</h2><p>一定有同学对于为什么 Proxy 能够动态产生不同接口类型的代理感兴趣，我的猜测是肯定通过传入进去的接口然后通过反射动态生成了一个接口实例。<br>比如 SellWine 是一个接口，那么 Proxy.newProxyInstance() 内部肯定会有</p><pre><code>new SellWine();</code></pre><p>这样相同作用的代码，不过它是通过反射机制创建的。那么事实是不是这样子呢？直接查看它们的源码好了。需要说明的是，我当前查看的源码是 1.8 版本。</p><pre><code>public static Object newProxyInstance(ClassLoader loader,                                          Class&lt;?&gt;[] interfaces,                                          InvocationHandler h)        throws IllegalArgumentException    {        Objects.requireNonNull(h);        final Class&lt;?&gt;[] intfs = interfaces.clone();</code></pre><p>​<br>            /*<br>             * Look up or generate the designated proxy class.<br>             */<br>            Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</p><pre><code>/* * Invoke its constructor with the designated invocation handler. */try {</code></pre><p>​<br>                final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);<br>                final InvocationHandler ih = h;<br>                if (!Modifier.isPublic(cl.getModifiers())) {<br>                    AccessController.doPrivileged(new PrivilegedAction<void>() {<br>                        public Void run() {<br>                            cons.setAccessible(true);<br>                            return null;<br>                        }<br>                    });<br>                }</void></p><pre><code>        return cons.newInstance(new Object[]{h});    } catch (IllegalAccessException|InstantiationException e) {        throw new InternalError(e.toString(), e);    } catch (InvocationTargetException e) {        Throwable t = e.getCause();        if (t instanceof RuntimeException) {            throw (RuntimeException) t;        } else {            throw new InternalError(t.toString(), t);        }    } catch (NoSuchMethodException e) {        throw new InternalError(e.toString(), e);    }}</code></pre><p>​<br>​    </p><p>newProxyInstance 的确创建了一个实例，它是通过 cl 这个 Class 文件的构造方法反射生成。cl 由 getProxyClass0() 方法获取。</p><pre><code>private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,                                       Class&lt;?&gt;... interfaces) {    if (interfaces.length &gt; 65535) {        throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);    }    // If the proxy class defined by the given loader implementing    // the given interfaces exists, this will simply return the cached copy;    // otherwise, it will create the proxy class via the ProxyClassFactory    return proxyClassCache.get(loader, interfaces);}</code></pre><p>​    </p><p>直接通过缓存获取，如果获取不到，注释说会通过 ProxyClassFactory 生成。</p><pre><code>/**     * A factory function that generates, defines and returns the proxy class given     * the ClassLoader and array of interfaces.     */    private static final class ProxyClassFactory        implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;    {        // Proxy class 的前缀是 “$Proxy”，        private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;        // next number to use for generation of unique proxy class names        private static final AtomicLong nextUniqueNumber = new AtomicLong();        @Override        public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) {            Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);            for (Class&lt;?&gt; intf : interfaces) {                /*                 * Verify that the class loader resolves the name of this                 * interface to the same Class object.                 */                Class&lt;?&gt; interfaceClass = null;                try {                    interfaceClass = Class.forName(intf.getName(), false, loader);                } catch (ClassNotFoundException e) {                }                if (interfaceClass != intf) {                    throw new IllegalArgumentException(                        intf + &quot; is not visible from class loader&quot;);                }                /*                 * Verify that the Class object actually represents an                 * interface.                 */                if (!interfaceClass.isInterface()) {                    throw new IllegalArgumentException(                        interfaceClass.getName() + &quot; is not an interface&quot;);                }                /*                 * Verify that this interface is not a duplicate.                 */                if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {                    throw new IllegalArgumentException(                        &quot;repeated interface: &quot; + interfaceClass.getName());                }            }            String proxyPkg = null;     // package to define proxy class in            int accessFlags = Modifier.PUBLIC | Modifier.FINAL;            /*             * Record the package of a non-public proxy interface so that the             * proxy class will be defined in the same package.  Verify that             * all non-public proxy interfaces are in the same package.             */            for (Class&lt;?&gt; intf : interfaces) {                int flags = intf.getModifiers();                if (!Modifier.isPublic(flags)) {                    accessFlags = Modifier.FINAL;                    String name = intf.getName();                    int n = name.lastIndexOf(&apos;.&apos;);                    String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));                    if (proxyPkg == null) {                        proxyPkg = pkg;                    } else if (!pkg.equals(proxyPkg)) {                        throw new IllegalArgumentException(                            &quot;non-public interfaces from different packages&quot;);                    }                }            }            if (proxyPkg == null) {                // if no non-public proxy interfaces, use com.sun.proxy package                proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;            }            /*             * Choose a name for the proxy class to generate.             */            long num = nextUniqueNumber.getAndIncrement();            String proxyName = proxyPkg + proxyClassNamePrefix + num;            /*             * Generate the specified proxy class.             */            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(                proxyName, interfaces, accessFlags);            try {                return defineClass0(loader, proxyName,                                    proxyClassFile, 0, proxyClassFile.length);            } catch (ClassFormatError e) {                /*                 * A ClassFormatError here means that (barring bugs in the                 * proxy class generation code) there was some other                 * invalid aspect of the arguments supplied to the proxy                 * class creation (such as virtual machine limitations                 * exceeded).                 */                throw new IllegalArgumentException(e.toString());            }        }    }</code></pre><p>​<br>​    </p><p>这个类的注释说，通过指定的 ClassLoader 和 接口数组 用工厂方法生成 proxy class。 然后这个 proxy class 的名字是：</p><pre><code>// Proxy class 的前缀是 “$Proxy”，private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;long num = nextUniqueNumber.getAndIncrement();String proxyName = proxyPkg + proxyClassNamePrefix + num;</code></pre><p>​    </p><p>所以，动态生成的代理类名称是<strong>包名+$Proxy+id序号</strong>。</p><p>生成的过程，核心代码如下：</p><pre><code>byte[] proxyClassFile = ProxyGenerator.generateProxyClass(                proxyName, interfaces, accessFlags);</code></pre><p>​<br>    return defineClass0(loader, proxyName,<br>                        proxyClassFile, 0, proxyClassFile.length);</p><p>​    </p><p>这两个方法，我没有继续追踪下去，defineClass0() 甚至是一个 native 方法。我们只要知道，动态创建代理这回事就好了。</p><p>现在我们还需要做一些验证，我要检测一下动态生成的代理类的名字是不是<strong>包名+$Proxy+id序号</strong>。</p><pre><code>public class Test {    public static void main(String[] args) {        // TODO Auto-generated method stub        MaotaiJiu maotaijiu = new MaotaiJiu();        Wuliangye wu = new Wuliangye();        Furongwang fu = new Furongwang();        InvocationHandler jingxiao1 = new GuitaiA(maotaijiu);        InvocationHandler jingxiao2 = new GuitaiA(wu);        InvocationHandler jingxiao3 = new GuitaiA(fu);        SellWine dynamicProxy = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),                MaotaiJiu.class.getInterfaces(), jingxiao1);        SellWine dynamicProxy1 = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),                MaotaiJiu.class.getInterfaces(), jingxiao2);        dynamicProxy.mainJiu();        dynamicProxy1.mainJiu();        SellCigarette dynamicProxy3 = (SellCigarette) Proxy.newProxyInstance(Furongwang.class.getClassLoader(),                Furongwang.class.getInterfaces(), jingxiao3);        dynamicProxy3.sell();        System.out.println(&quot;dynamicProxy class name:&quot;+dynamicProxy.getClass().getName());        System.out.println(&quot;dynamicProxy1 class name:&quot;+dynamicProxy1.getClass().getName());        System.out.println(&quot;dynamicProxy3 class name:&quot;+dynamicProxy3.getClass().getName());    }}</code></pre><p>​    </p><p>结果如下：</p><pre><code>销售开始  柜台是： GuitaiA我卖得是茅台酒。销售结束销售开始  柜台是： GuitaiA我卖得是五粮液。销售结束销售开始  柜台是： GuitaiA售卖的是正宗的芙蓉王，可以扫描条形码查证。销售结束dynamicProxy class name:com.sun.proxy.$Proxy0dynamicProxy1 class name:com.sun.proxy.$Proxy0dynamicProxy3 class name:com.sun.proxy.$Proxy1</code></pre><p>​    </p><p>SellWine 接口的代理类名是：<code>com.sun.proxy.$Proxy0</code><br>SellCigarette 接口的代理类名是：<code>com.sun.proxy.$Proxy1</code></p><p>这说明动态生成的 proxy class 与 Proxy 这个类同一个包。</p><p>下面用一张图让大家记住动态代理涉及到的角色。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI5MjIwMzIzNjcz" alt="这里写图片描述"><br>红框中 <code>$Proxy0</code>就是通过 Proxy 动态生成的。<br><code>$Proxy0</code>实现了要代理的接口。<br><code>$Proxy0</code>通过调用 <code>InvocationHandler</code>来执行任务。</p><h1 id="Cglib动态代理"><a href="#Cglib动态代理" class="headerlink" title="Cglib动态代理"></a>Cglib动态代理</h1><p>见另一篇 Java Basic 下的 010动态代理</p><h1 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h1><p>可能有同学会问，已经学习了代理的知识，但是，它们有什么用呢？</p><p>主要作用，还是在不修改被代理对象的源码上，进行功能的增强。</p><p>这在 AOP 面向切面编程领域经常见。</p><blockquote><p>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p></blockquote><blockquote><p>主要功能<br>日志记录，性能统计，安全控制，事务处理，异常处理等等。</p></blockquote><p>上面的引用是百度百科对于 AOP 的解释，至于，如何通过代理来进行日志记录功能、性能统计等等，这个大家可以参考 AOP 的相关源码，然后仔细琢磨。</p><p>同注解一样，很多同学可能会有疑惑，我什么时候用代理呢？</p><p>这取决于你自己想干什么。你已经学会了语法了，其他的看业务需求。对于实现日志记录功能的框架来说，正合适。</p><p>至此，静态代理和动态代理者讲完了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>代理分为静态代理和动态代理两种。</li><li>静态代理，代理类需要自己编写代码写成。</li><li>动态代理，代理类通过 Proxy.newInstance() 方法生成。</li><li>不管是静态代理还是动态代理，代理与被代理者都要实现两样接口，它们的实质是面向接口编程。</li><li>静态代理和动态代理的区别是在于要不要开发者自己定义 Proxy 类。</li><li>动态代理通过 Proxy 动态生成 proxy class，但是它也指定了一个 InvocationHandler 的实现类。</li><li>代理模式本质上的目的是为了增强现有代码的功能。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;代理&quot;&gt;&lt;a href=&quot;#代理&quot; class=&quot;headerlink&quot; title=&quot;代理&quot;&gt;&lt;/a&gt;代理&lt;/h1&gt;&lt;p&gt;代理是英文 Proxy 翻译过来的。我们在生活中见到过的代理，大概最常见的就是朋友圈中卖面膜的同学了。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://jelly54.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://jelly54.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="代理模式" scheme="https://jelly54.github.io/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="https://jelly54.github.io/design-pattern-singleton/"/>
    <id>https://jelly54.github.io/design-pattern-singleton/</id>
    <published>2020-05-22T12:54:09.000Z</published>
    <updated>2020-08-28T06:55:33.027Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><a id="more"></a><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>单例模式(Singleton Pattern) 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</p><h1 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h1><p>单例模式有三个特性：</p><ul><li>单例类只能有一个实例</li><li>单例类必须自行创建自己的唯一的实例</li><li>单例类必须给所有其他对象提供这一实例</li></ul><p>单例模式结构如图所示：</p><p><img src="https://s2.ax1x.com/2020/02/29/3yaNeH.jpg" alt="3yaNeH.jpg"></p><p>Singleton（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。</p><h1 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h1><h2 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h2><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>Lazy初始化</td><td>是</td></tr><tr><td>多线程安全</td><td>否</td></tr><tr><td>实现难度</td><td>易</td></tr></tbody></table><p>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</p><p>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作</p><h2 id="饿汉式，线程安全"><a href="#饿汉式，线程安全" class="headerlink" title="饿汉式，线程安全"></a>饿汉式，线程安全</h2><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>Lazy初始化</td><td>否</td></tr><tr><td>多线程安全</td><td>是</td></tr><tr><td>实现难度</td><td>易</td></tr></tbody></table><p>这种方式比较常用，但容易产生垃圾对象。</p><p><strong>优点：</strong> 没有加锁，执行效率会提高。</p><p><strong>缺点：</strong> 类加载时就初始化，浪费内存。</p><p>它基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用getInstance方法， <strong>但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到lazy loading的效果。</strong></p><h2 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h2><h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>Lazy初始化</td><td>是</td></tr><tr><td>多线程安全</td><td>是</td></tr><tr><td>实现难度</td><td>易</td></tr></tbody></table><p>这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。</p><p><strong>优点：</strong> 第一次调用才初始化，避免内存浪费。</p><p><strong>缺点：</strong> 必须加锁 synchronized 才能保证单例，但加锁会影响效率。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p><h2 id="双检锁-DCL"><a href="#双检锁-DCL" class="headerlink" title="双检锁(DCL)"></a>双检锁(DCL)</h2><h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">       <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">            &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> singleton;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>Lazy初始化</td><td>否</td></tr><tr><td>多线程安全</td><td>是</td></tr><tr><td>实现难度</td><td>较复杂</td></tr><tr><td>jdk版本</td><td>jdk1.5起</td></tr></tbody></table><p>这种方式称为双重检查锁(Double-Check Locking)，需要注意的是，如果使用双重检查锁定来实现懒汉式单例类，需要<strong>在静态成员变量instance之前增加修饰符volatile</strong>，被volatile修饰的成员变量可以确保多个线程都能够正确处理(禁止指令重排序)，且该代码只能在JDK 1.5及以上版本中才能正确执行。</p><p>由于volatile关键字会屏蔽Java虚拟机所做的一些代码优化，可能会导致系统运行效率降低，因此即使使用双重检查锁定来实现单例模式也不是一种完美的实现方式。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><h3 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>Lazy初始化</td><td>是</td></tr><tr><td>多线程安全</td><td>是</td></tr><tr><td>实现难度</td><td>一般</td></tr></tbody></table><p>饿汉式单例类不能实现延迟加载，不管将来用不用始终占据内存；懒汉式单例类线程安全控制烦琐，而且性能受影响。</p><p>这种更好的被称之为Initialization Demand Holder (IoDH)的技术。在IoDH中，我们在单例类中增加一个静态(static)内部类，在该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用。</p><p>由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类SingletonHolder，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。</p><p>由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。通过使用IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的Java语言单例模式实现方式（其缺点是与编程语言本身的特性相关，很多面向对象语言不支持IoDH）。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </span><br><span class="line">   INSTANCE;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h3><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>Lazy初始化</td><td>否</td></tr><tr><td>多线程安全</td><td>是</td></tr><tr><td>实现难度</td><td>易</td></tr><tr><td>jdk版本</td><td>jdk1.5</td></tr></tbody></table><p>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。</p><p>这种方式是Effective Java作者Josh Bloch提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。</p><p>不能通过reflection attack来调用私有构造方法。</p><h1 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h1><p>一般情况下，不建议使用 2 种懒汉方式，建议使用饿汉方式。</p><p>只有在要明确实现lazy loading效果时，才会使用内部类方式。</p><p>如果涉及到反序列化创建对象时，可以尝试使用枚举方式。</p><p>如果有其他特殊的需求，可以考虑使用双检锁方式。</p><h1 id="Java中的语言中的单例模式"><a href="#Java中的语言中的单例模式" class="headerlink" title="Java中的语言中的单例模式"></a>Java中的语言中的单例模式</h1><p>Java语言中就有很多单例模式的应用实例，这里举例一个。</p><p>Java的Runtime对象</p><p>在Java语言内部，java.lang.Runtime对象就是一个使用单例模式的例子。在每一个Java应用程序里面，都有唯一的一个Runtime对象，应用程序可以与其运行环境发生相互作用。<br>Runtime类提供一个静态工厂方法getRuntime():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>通过调用此方法，可以获得Runtime类唯一的一个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime rt=Runtime.getRuntime();</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>单例模式作为一种目标明确、结构简单、理解容易的设计模式，在软件开发中使用频率相当高，在很多应用软件和框架中都得以广泛应用。</p><h2 id="主要优点"><a href="#主要优点" class="headerlink" title="主要优点"></a>主要优点</h2><p>单例模式的主要优点如下：<br>单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。</p><p>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。</p><p>允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例单例对象共享过多有损性能的问题。</p><h2 id="主要缺点"><a href="#主要缺点" class="headerlink" title="主要缺点"></a>主要缺点</h2><p>单例模式的主要缺点如下：<br>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</p><p>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</p><p>现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>在以下情况下可以考虑使用单例模式：<br>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。</p><p>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://jelly54.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://jelly54.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例模式" scheme="https://jelly54.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之工厂模式</title>
    <link href="https://jelly54.github.io/design-pattern-factory/"/>
    <id>https://jelly54.github.io/design-pattern-factory/</id>
    <published>2020-05-19T11:52:34.000Z</published>
    <updated>2020-08-28T06:53:35.767Z</updated>
    
    <content type="html"><![CDATA[<p>简单工厂模式是最简单的模式，有助于引出工厂方法模式，而工厂方法模式在后面的许多模式都有应用，它在模式的讨论里屡见不鲜。了解工厂方法模式是了解所有模式的起点。</p><a id="more"></a><h1 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h1><p>通过一个披萨项目的例子来引出问题，然后给出简单工厂模式这种解决方案，然后随着披萨项目的不断扩展，遇到新的问题，引出工厂方法模式，然后又遇到新的问题，引出最终解决方案，抽象工厂模式。</p><h2 id="讲解中的例子介绍"><a href="#讲解中的例子介绍" class="headerlink" title="讲解中的例子介绍"></a>讲解中的例子介绍</h2><p>比如一个披萨店，店长一名，目前卖两种口味披萨，GreekPizza和CheesePizza，每个披萨都有prePare(),bake(),cut(),box()这4种步骤，原料，烘培，切割，打包，最后给用户吃。<br>把上述这个过程抽象后，设计如下：</p><p><img src="https://s2.ax1x.com/2020/02/29/3scfO0.png" alt="3scfO0.png"></p><p>Pizza披萨抽象类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">bake</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">box</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GreekPizza披萨类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreekPizza</span>  <span class="keyword">extends</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"准备GreekPizza~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bake</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在烤GreekPizza~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在切GreekPizza~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在打包GreekPizza~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CheesePizza披萨类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"准备CheesePizza~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bake</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在烤CheesePizza~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在切CheesePizza~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在打包CheesePizza~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端,店长根据客户点的餐生成不同的披萨：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Pizza pizza;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"cheese"</span>.equal(orderType)) pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"greek"</span>.equal(orderType)) pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务很简答，根据用户想买的披萨，生成不同的披萨。<br>传统的设置这样也没错，如果业务发展，会造成什么问题呢？<br>现在如果多了一种口味 qiaokeliPizza，正常办法是生成一个QiaokeliPizza类，继承于Pizza，然后在OrderPizza中，添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">"qiaokeli"</span>.equal(orderType)) pizza = <span class="keyword">new</span> QiaokeliPizza();</span><br></pre></td></tr></table></figure><p>如果后来披萨口味越来越多，负责点餐的店长会很不开心的，既要点餐又要做披萨，一个人忙不够来，希望请一个厨师来专门做披萨，那样他才会轻松点。<br>他所想的解决方案，简单工厂模式就可以做到。</p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>简单工厂模式是类的创建模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是<strong>由一个工厂对象决定创建出哪一种产品类的实例</strong>。</p><p>简单工厂模式的结构如下：</p><p><img src="https://s2.ax1x.com/2020/02/29/3scWyq.png" alt="3scWyq.png"></p><p>从图中可以看出，简单工厂模式涉及到工厂角色，抽象产品角色以及具体产品角色等三个角色：</p><ul><li>工厂类（Factory）角色：担任这个角色的是工厂方法模式的核心，含有与应用紧密相关的商业逻辑。</li><li>抽象产品（Product）角色：担任这个角色的类是由工厂方法模式所创建的对象的父类，或它们共同拥有的接口，这里指的就是Pizza这个类。</li><li>具体产品（Concrete Product）角色：工厂方法模式所创建的任务对象都是这个角色的实例，这里指GreekPizza和CheesePizza。</li></ul><p>把上面的披萨项目用简单工厂模式来现实的话，无非就是创建一个工厂类（厨师）来接管店长之前要做得烤披萨的活，而店长只要告诉这个工厂类（厨师）他需要哪种披萨就好。</p><h2 id="代码示例讲解"><a href="#代码示例讲解" class="headerlink" title="代码示例讲解"></a>代码示例讲解</h2><p>SimplePizzaFactory简单工厂类，根据传递的参数来准备不同的披萨：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePizzaFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pizza <span class="title">CreatePizza</span><span class="params">(String orderType)</span></span>&#123;</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (orderType.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"greek"</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用时,店长只需要调用工厂类SimplePizzaFactory的静态方法CreatePizza()即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Pizza pizza;</span><br><span class="line">    pizza=SimplePizzaFactory.CreatePizza(<span class="string">"cheese"</span>);</span><br><span class="line">    pizza=SimplePizzaFactory.CreatePizza(<span class="string">"greek"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样设计后，店长就轻松多了，只要负责告诉工厂类（厨师）需要什么类型的披萨就可以，终于不要担心搞错了而负责任。</p><p>上面用披萨项目的列子来讲解了简单工厂模式的使用，总结下优缺点：</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>模式的核心是工厂类。这个类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例。而客户端则可以免除直接创建对象的责任。简单工厂模式通过这种做法实现了对责任的分割。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>这个工厂类集中了所以的创建逻辑，当有复杂的多层次等级结构时，所有的业务逻辑都在这个工厂类中实现。什么时候它不能工作了，整个系统都会受到影响。并且简单工厂模式违背了开闭原则（对扩展的开放，对修改的关闭）。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>在以下情况下可以考虑使用简单工厂模式：</p><ul><li>工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li><li>客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</li></ul><hr><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>工厂方法模式是类的创建模式，又叫做虚拟构造子(Cirtual Constructor)模式或者多态工厂（Polymorphic Factory）模式。</p><p>工厂方法模式的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。</p><p>首先，在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做.这个核心类则摇身一变，成为了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p><p>这种进一步抽象化的结果，使这种工厂方法模式可以用来予许系统在不修改具体工厂角色的情况下引进新的产品，也就遵循了开闭原则。</p><p>工厂方法模式的结构图如下:</p><p><img src="https://s2.ax1x.com/2020/02/29/3sc2Ss.png" alt="3sc2Ss.png"></p><p>从上图可以看出， 工厂方法模式涉及到抽象工厂角色，具体工厂角色，抽象产品角色以及具体产品角色等四个角色：</p><ul><li>抽象工厂角色：担任这个角色的是工厂方法模式的核心，它是与应用程序无关的。任何在模式中创建对象的工厂类必须实现这个接口。</li><li>具体工厂角色：担任这个角色的是实现了抽象工厂接口的具体Java类，具体工厂角色含有与应用密切相关的逻辑，并且受到应用程序的调用以创建产品对象。</li><li>抽象产品角色：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。</li><li>具体产品角色：这个角色实现了抽象产品角色所申明的接口。工厂方法模式所创建的每一个对象都是某个具体产品角色的实例。</li></ul><p>结合披萨系统，用白话文来说就是之前厨师（工厂类）负责所有的烤披萨任务，太累了。于是招了两个厨师分别负责烤 GreekPizza披萨和 CheesePizza披萨，之前的厨师升级为厨师长（抽象工厂类），负责教那两位厨师（具体工厂类）烤披萨，自己则不用亲自动手烤披萨了。</p><p>附上代码前先来看看完整的类图：</p><p><img src="https://s2.ax1x.com/2020/02/29/3scRln.jpg" alt="3scRln.jpg"></p><h2 id="代码示例讲解-1"><a href="#代码示例讲解-1" class="headerlink" title="代码示例讲解"></a>代码示例讲解</h2><p>下面是抽象工厂角色PizzaFactory的代码,这个角色是使用一个java接口实现，它声明了一个工厂方法，要求所有的具体工厂角色实现这个工厂方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PizzaFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是具体工厂角色CheesePizzaFactory的代码，这个角色实现了抽象工厂角色PizzaFactory所声明的工厂方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesePizzaFactory</span> <span class="keyword">implements</span> <span class="title">PizzaFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CheesePizza();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是具体工厂角色GreekPizzaFactory的代码，这个角色实现了抽象工厂角色PizzaFactory所声明的工厂方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreekPizzaFactory</span>  <span class="keyword">implements</span> <span class="title">PizzaFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GreekPizza();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是客户端角色的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        PizzaFactory factory=<span class="keyword">new</span> CheesePizzaFactory();</span><br><span class="line">        Pizza pizza=factory.createPizza();</span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        factory=<span class="keyword">new</span> GreekPizzaFactory();</span><br><span class="line">        pizza=factory.createPizza();</span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果演示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">准备CheesePizza~</span><br><span class="line">正在烤CheesePizza~</span><br><span class="line">正在切CheesePizza~</span><br><span class="line">正在打包CheesePizza~</span><br><span class="line">准备GreekPizza~</span><br><span class="line">正在烤GreekPizza~</span><br><span class="line">正在切GreekPizza~</span><br><span class="line">正在打包GreekPizza~</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式的注意点："><a href="#工厂方法模式的注意点：" class="headerlink" title="工厂方法模式的注意点："></a>工厂方法模式的注意点：</h2><ol><li>工厂方法创建对象：工厂方法不一定每一次都返还一个新的对象，但是它所返还的对象一定<strong>是它自己创建的</strong>。</li><li>工厂方法返还的类型：工厂方法<strong>返还的应当是抽象类型</strong>，而不是具体类型，只有这样才能保证针对产品的多态性。当工厂方法模式发生上面的退化时，就不再是工厂方法模式了。</li><li>工厂等级结构：工厂对象应当有一个抽象的超类型。换言之，应当有数个具体工厂类作为一个抽象超类型的具体子类存在于工厂等级结构中。如果等级结构中只有一个具体工程类的话，那么抽象工厂角色也可以省略，这时候，工厂方法模式就发生了退化，这一退化表现为针对工厂角色的多态性的丧失。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>工厂方法模式和简单工厂模式比较</strong>：</p><p>工厂方法模式跟简单工厂模式在结构上的不同是很明显的，工厂方法模式的核心是一个抽象工厂类，而简单工厂模式的核心在一个具体类。显而易见工厂方法模式这种结构更好扩展，权力下发，分布式比集中式更具优势。</p><p>如果系统需要加入一个新的产品，那么所需要的就是向系统中加入一个这个产品类以及它所对应的工厂类。没有必要修改客户端，也没有必要修改抽象工厂角色或者其他已有的具体工厂角色。对于增加新的产品类而言，这个系统完全支持开闭原则。</p><hr><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式可以向客户端提供一个接口，使得客户端在不必指定产品的具体类型的情况下，创建多个产品族中的产品对象。这就是抽象工厂的用意。</p><h2 id="抽象工厂模式的结构"><a href="#抽象工厂模式的结构" class="headerlink" title="抽象工厂模式的结构"></a>抽象工厂模式的结构</h2><p><img src="https://s2.ax1x.com/2020/02/29/3sccWj.png" alt="3sccWj.png"></p><p>从上图可以看出， 抽象工厂模式涉及到抽象工厂角色，具体工厂角色，抽象产品角色以及具体产品角色等四个角色：</p><ul><li>抽象工厂角色：担任这个角色的是工厂方法模式的核心，它是与应用程序无关的。任何在模式中创建对象的工厂类必须实现这个接口。</li><li>具体工厂角色：担任这个角色的是实现了抽象工厂接口的具体Java类，具体工厂角色含有与应用密切相关的逻辑，并且受到应用程序的调用以创建产品对象。</li><li>抽象产品角色：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。</li><li>具体产品角色：这个角色实现了抽象产品角色所申明的接口。工厂方法模式所创建的每一个对象都是某个具体产品角色的实例。</li></ul><p>为了更好地理解抽象工厂模式，我们先引入两个概念：</p><p><strong>(1) 产品等级结构：</strong></p><p>产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</p><p><strong>(2) 产品族：</strong></p><p>在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。</p><p>角色上跟工厂方法模式差不多。只是比之前多了一个产品汉堡，并且具体工厂类划分是按照产品族来划分的，这里划分为单人套餐（SingleFactory）以及家庭套餐（FamilyFactory）,单人套餐工厂类可以生产单人套餐披萨和单人套餐汉堡。家庭套餐工厂类可以生产家庭套餐披萨和家庭套餐汉堡。</p><p>下图所示是这个系统的产品等级结构与产品族示意图如图：</p><p><img src="https://s2.ax1x.com/2020/02/29/3sc4mV.png" alt="3sc4mV.png"></p><p>附上代码前先来看看完整的类图：</p><p><img src="https://s2.ax1x.com/2020/02/29/3sc5wT.jpg" alt="3sc5wT.jpg"></p><h2 id="代码示例讲解-2"><a href="#代码示例讲解-2" class="headerlink" title="代码示例讲解"></a>代码示例讲解</h2><p>下面是抽象产品的角色Pizza的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是具体产品的角色SinglePizza的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SinglePizza</span> <span class="keyword">implements</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"单人套餐披萨"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是具体产品的角色FamilyPizza的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FamilyPizza</span> <span class="keyword">implements</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"家庭套餐披萨"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是抽象产品的角色Hamburger的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是具体产品的角色SingleHamburger的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleHamburger</span>  <span class="keyword">implements</span> <span class="title">Hamburger</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"单人套餐汉堡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是具体产品的角色FamilyHamburger的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FamilyHamburger</span> <span class="keyword">implements</span> <span class="title">Hamburger</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"家庭套餐汉堡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是抽象工厂角色Factory的代码,这个角色是使用一个java接口实现，它声明了两个工厂方法，一个用来生产披萨，一个用来生产汉堡，并要求所有的具体工厂角色实现这个工厂方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hamburger <span class="title">createHamburger</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是具体工厂角色SingleFactory的代码，这个角色现实了抽象工厂角色Factory所声明的工厂方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SinglePizza();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hamburger <span class="title">createHamburger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SingleHamburger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是具体工厂角色FamilyFactory的代码，这个角色现实了抽象工厂角色Factory所声明的工厂方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FamilyFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FamilyPizza();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hamburger <span class="title">createHamburger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FamilyHamburger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是客户端角色的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Factory factory=<span class="keyword">new</span> SingleFactory();</span><br><span class="line">        Pizza pizza=factory.createPizza();</span><br><span class="line">        pizza.create();</span><br><span class="line">        Hamburger hamburger=factory.createHamburger();</span><br><span class="line">        hamburger.create();</span><br><span class="line">        factory= <span class="keyword">new</span> FamilyFactory();</span><br><span class="line">        pizza=factory.createPizza();</span><br><span class="line">        pizza.create();</span><br><span class="line">        hamburger=factory.createHamburger();</span><br><span class="line">        hamburger.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果演示：</span></span><br><span class="line">单人套餐披萨</span><br><span class="line">单人套餐汉堡</span><br><span class="line">家庭套餐披萨</span><br><span class="line">家庭套餐汉堡</span><br></pre></td></tr></table></figure><h2 id="实际常见的应用"><a href="#实际常见的应用" class="headerlink" title="实际常见的应用"></a>实际常见的应用</h2><p><img src="https://s2.ax1x.com/2020/02/29/3scITU.jpg" alt="3scITU.jpg"></p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>工厂方法模式和抽象工厂模式对比</p><p>工厂方法模式是一种极端情况的抽象工厂模式，而抽象工厂模式可以看成是工厂方法模式的推广。</p><p>工厂方法模式用来创建一个产品的等级结构，而抽象工厂模式是用来创建多个产品的等级结构。</p><p>工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个抽象产品类。</p><p>工厂方法模式中具体工厂类只有一个创建方法，而抽象工厂模式中具体工厂类有多个创建方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单工厂模式是最简单的模式，有助于引出工厂方法模式，而工厂方法模式在后面的许多模式都有应用，它在模式的讨论里屡见不鲜。了解工厂方法模式是了解所有模式的起点。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://jelly54.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://jelly54.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="工厂模式" scheme="https://jelly54.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式总览</title>
    <link href="https://jelly54.github.io/design-pattern-overview/"/>
    <id>https://jelly54.github.io/design-pattern-overview/</id>
    <published>2020-05-18T06:48:39.000Z</published>
    <updated>2020-08-28T06:52:03.625Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>23种设计模式分为三类</p><p><img src="https://s2.ax1x.com/2020/02/29/3smaWt.png" alt="3smaWt.png"></p><h1 id="学习顺序"><a href="#学习顺序" class="headerlink" title="学习顺序"></a>学习顺序</h1><table><thead><tr><th>学习顺序</th><th>设计模式</th><th>常用程度</th><th>适用层次</th><th>引入时机</th><th>结构复杂度</th><th>变化</th><th>实现</th><th>体现的原则</th></tr></thead><tbody><tr><td>1</td><td>工厂模式（Factory Method）</td><td>很常用</td><td>代码级</td><td>编码时</td><td>简单</td><td>子类的实例化</td><td>对象的创建工作延迟到子类</td><td>开闭原则</td></tr><tr><td>2</td><td>单例模式（Singleton）</td><td>很常用    代码级、应用级</td><td>设计时、编码时</td><td>简单</td><td>唯一实例</td><td>封装对象产生的个数</td><td></td><td></td></tr><tr><td>3</td><td>外观模式（Facade）</td><td>很常用</td><td>应用级、构架级</td><td>设计时、编码时</td><td>简单</td><td>子系统的高层接口</td><td>封装子系统</td><td>开闭原则</td></tr><tr><td>4</td><td>模板模式（Template Method）</td><td>很常用</td><td>代码级</td><td>编码时、重构时</td><td>简单</td><td>算法子步骤的变化</td><td>封装算法结构</td><td>依赖倒置原则</td></tr><tr><td>5</td><td>抽象工厂模式（Abstract Factory）</td><td>比较常用</td><td>应用级</td><td>设计时</td><td>比较复杂</td><td>产品家族的扩展</td><td>封装产品族系列内容的创建</td><td>开闭原则</td></tr><tr><td>6</td><td>组合模式（Composite）</td><td>比较常用</td><td>代码级</td><td>编码时、重构时</td><td>比较复杂</td><td>复杂对象接口的统一</td><td>统一复杂对象的接口</td><td>里氏代换原则</td></tr><tr><td>7</td><td>代理模式（Proxy）</td><td>比较常用</td><td>应用级、构架级</td><td>设计时、编码时</td><td>简单</td><td>对象访问的变化</td><td>封装对象的访问过程</td><td>里氏代换原则</td></tr><tr><td>8</td><td>命令模式（Command）</td><td>比较常用</td><td>应用级</td><td>设计时、编码时</td><td>比较简单</td><td>请求的变化</td><td>封装行为对对象</td><td>开闭原则</td></tr><tr><td>9</td><td>观察者模式（Observer）</td><td>比较常用</td><td>应用级、构架级</td><td>设计时、编码时</td><td>比较简单</td><td>通讯对象的变化</td><td>封装对象通知</td><td>开闭原则</td></tr><tr><td>10</td><td>策略模式（Strategy）</td><td>比较常用</td><td>应用级</td><td>设计时</td><td>一般</td><td>算法的变化</td><td>封装算法</td><td>里氏代换原则</td></tr><tr><td>11</td><td>建造者模式（Builder）</td><td>一般</td><td>代码级</td><td>编码时</td><td>一般</td><td>对象组建的变化</td><td>封装对象的组建过程</td><td>开闭原则</td></tr><tr><td>12</td><td>适配器模式（Adapter）</td><td>一般</td><td>代码级</td><td>重构时</td><td>一般</td><td>对象接口的变化</td><td>接口的转换</td><td></td></tr><tr><td>13</td><td>桥接模式（Bridge）</td><td>一般</td><td>代码级</td><td>设计时、编码时</td><td>一般</td><td>对象的多维度变化</td><td>分离接口以及实现</td><td>开闭原则</td></tr><tr><td>14</td><td>装饰器模式（Decorator）</td><td>一般</td><td>代码级</td><td>重构时</td><td>比较复杂</td><td>对象的组合职责</td><td>在稳定接口上扩展</td><td>开闭原则</td></tr><tr><td>15</td><td>迭代器模式（Iterator）</td><td>一般</td><td>代码级、应用级</td><td>编码时、重构时</td><td>比较简单</td><td>对象内部集合的变化</td><td>封装对象内部集合的使用</td><td>单一职责原则</td></tr><tr><td>16</td><td>中介者模式（Mediator）</td><td>一般</td><td>应用级、构架级</td><td>编码时、重构时</td><td>一般</td><td>对象交互的变化</td><td>封装对象间的交互</td><td>开闭原则</td></tr><tr><td>17</td><td>备忘录模式（Memento）</td><td>一般</td><td>代码级</td><td>编码时</td><td>比较简单</td><td>状态的辅助保存</td><td>封装对象状态的变化</td><td>接口隔离原则</td></tr><tr><td>18</td><td>状态模式（State）</td><td>一般</td><td>应用级</td><td>设计时、编码时</td><td>一般</td><td>对象状态的变化</td><td>封装与状态相关的行为</td><td>单一职责原则</td></tr><tr><td>19</td><td>访问者模式（Visitor）</td><td>一般</td><td>应用级</td><td>设计时</td><td>比较复杂</td><td>对象操作变化</td><td>封装对象操作变化</td><td>开闭原则</td></tr><tr><td>20</td><td>原型模式（Prototype）</td><td>不太常用</td><td>应用级</td><td>编码时、重构时</td><td>比较简单</td><td>实例化的类</td><td>封装对原型的拷贝</td><td>依赖倒置原则</td></tr><tr><td>21</td><td>享元模式（Flyweight）</td><td>不太常用</td><td>代码级、应用级</td><td>设计时</td><td>一般</td><td>系统开销的优化</td><td>封装对象的获取</td><td></td></tr><tr><td>22</td><td>责任链模式（Chain of Resp）</td><td>不太常用</td><td>应用级、构架级</td><td>设计时、编码时</td><td>比较复杂</td><td>对象的请求过程</td><td>封装对象的责任范围</td><td></td></tr><tr><td>23</td><td>解释器模式（Interpreter）</td><td>不太常用</td><td>应用级</td><td>设计时</td><td>比较复杂</td><td>领域问题的变化</td><td>封装特定领域的变化</td><td></td></tr></tbody></table><h1 id="各类之间的关系"><a href="#各类之间的关系" class="headerlink" title="各类之间的关系"></a>各类之间的关系</h1><p><img src="https://s2.ax1x.com/2020/02/29/3smUJI.jpg" alt="3smUJI.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h1&gt;&lt;p&gt;23种设计模式分为三类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/20
      
    
    </summary>
    
      <category term="设计模式" scheme="https://jelly54.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://jelly54.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>二分查找变形</title>
    <link href="https://jelly54.github.io/alg-BS-variant/"/>
    <id>https://jelly54.github.io/alg-BS-variant/</id>
    <published>2020-03-18T13:32:11.000Z</published>
    <updated>2020-08-28T06:34:07.409Z</updated>
    
    <content type="html"><![CDATA[<p>本文对二分查找以及其变形出的部分题目做了总结，增强对二分查找的理解和运用。</p><a id="more"></a><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a     有序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n     数组长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 给定的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h2><h3 id="循环退出条件"><a href="#循环退出条件" class="headerlink" title="循环退出条件"></a>循环退出条件</h3><p>注意是 <strong>low&lt;=high</strong>，而不是low&lt;high。</p><h3 id="mid的取值"><a href="#mid的取值" class="headerlink" title="mid的取值"></a>mid的取值</h3><p>实际上， mid=(low+high)/2这种写法是有问题的。因为如果low和high比较大的话，两者之和就有可能会溢出。改进的方法是将mid的计算方式写成 <strong>low+(high - low)/2</strong>。更进一步，如果要将性能优化到极致的话，我们可以将这里的除以2操作转化成位运算 <strong>low+((high-low)&gt;&gt;1)</strong>。因为相比除法运算来说，计算机处理位运算要<br>快得多。</p><h3 id="low和high的更新"><a href="#low和high的更新" class="headerlink" title="low和high的更新"></a>low和high的更新</h3><p><strong>low=mid+1，high=mid-1</strong>。注意这里的+1和-1，如果直接写成low=mid或者high=mid，就可能会发生死循环。比如，当high=3， low=3时，如果a[3]不等于value，就<br>会导致一直循环不退出</p><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><h3 id="依赖的是顺序表结构"><a href="#依赖的是顺序表结构" class="headerlink" title="依赖的是顺序表结构"></a>依赖的是顺序表结构</h3><p>简单点说就是数组。那二分查找能否依赖其他数据结构呢？比如链表。答案是不可以的，主要原因是二分查找算法需要按照下标随机访问元素。我们在数组和链表那两节讲过，数组按照下标随机访问数据的时间复杂度是O(1)，而链表随机访问的时间复杂度是O(n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。</p><p>二分查找<strong>只能用在数据是通过顺序表来存储的数据结构上</strong>。如果你的数据是通过其他数据结构存储的，则无法应用二分查找。</p><h3 id="针对的是有序数据"><a href="#针对的是有序数据" class="headerlink" title="针对的是有序数据"></a>针对的是有序数据</h3><p>二分查找对这一点的要求比较苛刻，数据必须是有序的。如果数据没有序，我们需要先排序。前面章节里我们讲到，排序的时间复杂度最低是O(nlogn)。所以，如<br>果我们针对的是一组静态的数据，没有频繁地插入、删除，我们可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较<br>低。</p><p>但是，如果我们的数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。</p><p>所以，<strong>二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中</strong>。针对动态变化的数据集合，二分查找将不再适用</p><h3 id="不适合数据量太小"><a href="#不适合数据量太小" class="headerlink" title="不适合数据量太小"></a>不适合数据量太小</h3><p>如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为10的数组中查找一个元素，不管用二分查找还是顺序遍历，查<br>找速度都差不多。<strong>只有数据量比较大的时候，二分查找的优势才会比较明显</strong>。</p><p>不过，这里有一个例外。<strong>如果数据之间的比较操作非常耗时，不管数据量大小，都推荐使用二分查找</strong>。比如，数组中存储的都是长度超过300的字符串，如此长<br>的两个字符串之间比对大小，就会非常耗时。我们需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。</p><h3 id="数据量太大也不适合"><a href="#数据量太大也不适合" class="headerlink" title="数据量太大也不适合"></a>数据量太大也不适合</h3><p>二分查找的<strong>底层需要依赖数组这种数据结构</strong>，而数组为了支持随机访问的特性，<strong>要求内存空间连续</strong>，对内存的要求比较苛刻。比如，我们有1GB大小的数据，如果希望用数组来存储，那就需要的连续内存空间。</p><p>注意这里的“连续”二字，也就是说，即便有2GB的内存空间剩余，但是如果这<strong>剩余的2GB内存空间都是零散的</strong>，没有连续的1GB大小的内存空间，那<strong>照样无法申请一个1GB大小的数组</strong>。</p><p>而我们的二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组存储就比较吃力了，也就不能用二分查找了。</p><hr><h1 id="查找第一个值等于给定值的元素"><a href="#查找第一个值等于给定值的元素" class="headerlink" title="查找第一个值等于给定值的元素"></a>查找第一个值等于给定值的元素</h1><p>有序数据集合中存在重复的数据，我们希望找到第一个值等于给定值的数据。</p><p>比如下面这样一个有序数组，其中， a[5]， a[6]， a[7]的值都等于8，是重复的数据。我们希望查找第一个等于8的数据，也就是下标是5的元素。</p><p><img src="https://s2.ax1x.com/2020/01/29/1M4wqI.png" alt="1M4wqI.png"></p><p>如果我们用普通二分查找的代码实现，首先拿8与区间的中间值a[4]比较， 8比6大，于是在下标5到9之间继续查找。下标5和9的中间位置是下标7， a[7]正好等于8，所以代码就返回了。<br>尽管a[7]也等于8，但它并不是我们想要找的第一个等于8的元素，因为第一个值等于8的元素是数组下标为5的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找第一个值等于给定值的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a     有序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n     数组长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 给定的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (a[mid - <span class="number">1</span>] != value)) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍微解释一下这段代码。 a[mid]跟要查找的value的大小关系有三种情况：大于、小于、等于。</p><p>对于a[mid]&gt;value的情况，我们需要更新high= mid-1；</p><p>对于a[mid] &lt; value的情况，我们需要更新low=mid+1。这两点都很<br>好理解。</p><p>当a[mid]=value的时候,<br>如果我们查找的是任意一个值等于给定值的元素，当a[mid]等于要查找的值时， a[mid]就是我们要找的元素。但是，如果我们求解的是第一个值等于给定值的元素，当a[mid]等于要查找的值时，我们就需要确认一下这<br>个a[mid]是不是第一个值等于给定值的元素。</p><p>我们重点看第11行代码。<strong>如果mid等于0</strong>，那这个元素已经是数组的第一个元素，那它肯定是我们要找的；如果<strong>mid不等于0，但a[mid]的前一个元素a[mid-1]不等于value</strong>,那也说明a[mid]就是我们要找的第一个值等于给定值的元素。</p><p>如果经过检查之后发现a[mid]前面的一个元素a[mid-1]也等于value，那说明此时的a[mid]肯定不是我们要查找的第一个值等于给定值的元素。那我们就更新high=mid-1，因为要找的元素肯定出现在[low, mid-1]之间。</p><hr><h1 id="查找最后一个值等于给定值的元素"><a href="#查找最后一个值等于给定值的元素" class="headerlink" title="查找最后一个值等于给定值的元素"></a>查找最后一个值等于给定值的元素</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找最后一个值等于给定值的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a     有序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n     数组长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 给定的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid == n - <span class="number">1</span>) || (a[mid + <span class="number">1</span>] != value)) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果a[mid]这个元素已经是数组中的最后一个元素了，那它肯定是我们要找的；如果a[mid]的后一个元素a[mid+1]不等于value，那也说明a[mid]就是我们要找的最后一个值等于给定值的元<br>素。</p><p>如果我们经过检查之后，发现a[mid]后面的一个元素a[mid+1]也等于value，那说明当前的这个a[mid]并不是最后一个值等于给定值的元素。我们就更新low=mid+1，因为要找的元素肯定出现在[mid+1, high]之间.</p><hr><h1 id="查找第一个大于等于给定值的元素"><a href="#查找第一个大于等于给定值的元素" class="headerlink" title="查找第一个大于等于给定值的元素"></a>查找第一个大于等于给定值的元素</h1><p>在有序数组中，查找第一个大于等于给定值的元素。比如，数组中存储的这样一个序列： 3， 4， 6， 7， 10。如果查找第一个大于等于5的元素，那就是6。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找第一个大于等于给定值的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a     有序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n     数组长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 给定的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt;= value) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (a[mid - <span class="number">1</span>] &lt; value)) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果a[mid]小于要查找的值value，那要查找的值肯定在[mid+1, high]之间，所以，我们更新low=mid+1。</p><p>对于a[mid]大于等于给定值value的情况，我们要先看下这个a[mid]是不是我们要找的第一个值大于等于给定值的元素。如果a[mid]前面已经没有元素，或者前面一个元素小于要查找的值value，那a[mid]就是我们要找的元素。这段逻辑对应的代码是第7行。</p><p>如果a[mid-1]也大于等于要查找的值value，那说明要查找的元素在[low, mid-1]之间，所以，我们将high更新为mid-1</p><hr><h1 id="查找最后一个小于等于给定值的元素"><a href="#查找最后一个小于等于给定值的元素" class="headerlink" title="查找最后一个小于等于给定值的元素"></a>查找最后一个小于等于给定值的元素</h1><p>比如，数组中存储了这样一组数据： 3， 5， 6， 8， 9， 10。最后一个小于等于7的元素就是6。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找最后一个小于等于给 定值的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a     有序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n     数组长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value  给定的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid == n - <span class="number">1</span>) || (a[mid + <span class="number">1</span>] &gt; value)) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对二分查找以及其变形出的部分题目做了总结，增强对二分查找的理解和运用。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://jelly54.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://jelly54.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://jelly54.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>动态规划算法题</title>
    <link href="https://jelly54.github.io/alg-dynamic-program/"/>
    <id>https://jelly54.github.io/alg-dynamic-program/</id>
    <published>2020-03-13T15:26:20.000Z</published>
    <updated>2020-08-28T06:28:53.792Z</updated>
    
    <content type="html"><![CDATA[<p>本文将常见的动态规划做了整合，根据不同的题目总结其特点，根据各自特点找出通用的解题思路。尚未完全总结完成。</p><a id="more"></a><h1 id="题目特点"><a href="#题目特点" class="headerlink" title="题目特点"></a>题目特点</h1><h2 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h2><ul><li>有多少种方式走到右下角</li><li>有多少种方法选出K个数使得和是Sum</li></ul><h2 id="求最大值最小值"><a href="#求最大值最小值" class="headerlink" title="求最大值最小值"></a>求最大值最小值</h2><ul><li>从左上角走到右下角路径的最大数字和</li><li>最长上升子序列</li></ul><h2 id="求存在性"><a href="#求存在性" class="headerlink" title="求存在性"></a>求存在性</h2><ul><li>取石子游戏，先手是否必胜</li><li>能不能选出K个数使得和是Sum</li></ul><hr><h1 id="归类"><a href="#归类" class="headerlink" title="归类"></a>归类</h1><h2 id="序列型动态规划"><a href="#序列型动态规划" class="headerlink" title="序列型动态规划"></a>序列型动态规划</h2><ul><li>关键字：前i个 / 最小 / 方式数 / 可行性</li><li>对于按序列且有状态的问题，采用 二维dp，存下序列+状态</li></ul><h2 id="坐标型动态规划"><a href="#坐标型动态规划" class="headerlink" title="坐标型动态规划"></a>坐标型动态规划</h2><ul><li>最简单的动态规划类型</li><li>给定一个序列或网络</li><li>需要找到序列中某个/些子序列或网络中的某条路径<ul><li>某种性质最大/最小</li><li>计数</li><li>存在性</li></ul></li><li>动态规划方程dp1]中的下标i表示以ai为结尾的满足条件的子序列的性质，dp[i][j]中的下标i, j表示以格子(i, j)为结尾的满足条件的路径的性质<ul><li>最大值/最小值</li><li>个数.</li><li>是否存在</li></ul></li><li>坐标型动态规划的初始条件dp[0]就是指以a0为结尾的子序列的性质</li></ul><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="确定状态"><a href="#确定状态" class="headerlink" title="确定状态"></a>确定状态</h2><ul><li>研究最优策略的最后一步</li><li>化为子问题</li></ul><p>简单的说，动态规划的时候需要开一个数组，数组的每个元素f[i]或者f[i][j]代表什么。</p><h2 id="转移方程"><a href="#转移方程" class="headerlink" title="转移方程"></a>转移方程</h2><p>根据子问题定义直接得到</p><p>依据这两个意识，定义转移方程</p><h2 id="初始条件和边界条件"><a href="#初始条件和边界条件" class="headerlink" title="初始条件和边界条件"></a>初始条件和边界条件</h2><p>在给定的状态中，最开始的值是可以确定的，先将Base值填入动态规划的数组中。</p><p>寻找边界值，如数组最后一个等。数组越界、边界值计算。</p><h2 id="调整计算顺序"><a href="#调整计算顺序" class="headerlink" title="调整计算顺序"></a>调整计算顺序</h2><p>检查是否存在重复计算，调整计算顺序或者建立缓存消除重复计算。</p><hr><h1 id="例题讲解"><a href="#例题讲解" class="headerlink" title="例题讲解"></a>例题讲解</h1><h2 id="零钱兑换-最值型"><a href="#零钱兑换-最值型" class="headerlink" title="零钱兑换(最值型)"></a>零钱兑换(最值型)</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>示例 1:</p><blockquote><p>输入: coins = [1, 2, 5], amount = 11<br>输出: 3 </p><p>解释: 11 = 5 + 5 + 1</p></blockquote><p>示例 2:</p><blockquote><p>输入: coins = [2], amount = 3<br>输出: -1</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>求最大最小值动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确定状态 dp[i] 为 能组合成面额为 i 的硬币最少数量</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始条件</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转移方程 f(n) = Math.min(f(n - f[1]) + 1,...,f(n - coins[n]) + 1)</span></span><br><span class="line">    <span class="comment">// f(n)等于所有coins中最小的和，即子问题最优时。最后应计算到amount这个值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        dp[i] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 边界条件，面额amount 应大于等于硬币coin大小</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= coin &amp;&amp; dp[i - coin] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i - coin] + <span class="number">1</span>, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (dp[amount] == Integer.MAX_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同路径-计数型"><a href="#不同路径-计数型" class="headerlink" title="不同路径(计数型)"></a>不同路径(计数型)</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p>示例 1:</p><blockquote><p>输入: m = 3, n = 2<br>输出: 3</p><p>解释:<br>从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右</li></ol></blockquote><p>示例 2:</p><blockquote><p>输入: m = 7, n = 3<br>输出: 28</p></blockquote><blockquote><p>提示：<br>1 &lt;= m, n &lt;= 100 题目数据保证答案小于等于 2 * 10 ^ 9</p></blockquote><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>计数型动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确定状态。dp[i][j] 为 在i行j列处到终点有多少路径</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 初始条件, 走在边上时</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 转移方程, 每个位置都依赖它上边的位置和左边的位置</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 边界处理</span></span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跳跃游戏-存在型"><a href="#跳跃游戏-存在型" class="headerlink" title="跳跃游戏(存在型)"></a>跳跃游戏(存在型)</h2><p>有n块石头分别在x轴的0，1，…，n-1 位置</p><p>一只青蛙在石头0，想跳到石头n-1</p><p>如果青蛙在第i块石头上，他最多可以向右跳跃距离ai</p><p>问青蛙能否跳到石头n-1</p><p>例子：</p><blockquote><p>输入：a=[2,3,1,1,4]<br>输出：true  </p><p>输入：a=[3,2,1,0,4]<br>输出：false</p></blockquote><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>存在性动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 最后一步：如果青蛙能跳到最后一块石头n-1 ，分析它最后一跳</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 最后一跳是从石头i跳过来的，i &lt; n-1</span></span><br><span class="line"><span class="comment">   * 满足：</span></span><br><span class="line"><span class="comment">   * 青蛙可以跳到石头 i （子问题只是数量级小了，方式通父问题）</span></span><br><span class="line"><span class="comment">   * 最后一步不超过跳跃的最大距离 n-1 - i &lt; ai</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> len = stones.length;</span><br><span class="line">      <span class="comment">// 确定状态：dp[i] 表示青蛙能不能跳过石头 i</span></span><br><span class="line">      <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始条件：刚开始就在石头上。</span></span><br><span class="line">      dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 转移方程：dp[i] = OR（0&lt;=j&lt;i）(dp[j] AND j + stones[j] &gt;= i)</span></span><br><span class="line">      <span class="comment">// 能否跳到石头i = 穷举青蛙能否跳到上一个跳到的石头j(即能否跳到石头j 并且 最后一步的距离符合规定)</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">          dp[i] = <span class="keyword">false</span>;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 上一跳的石头 j</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (dp[j] &amp;&amp; j + stones[j] &gt;= i) &#123;</span><br><span class="line">                  dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="最大相乘子序列-最值型"><a href="#最大相乘子序列-最值型" class="headerlink" title="最大相乘子序列(最值型)"></a>最大相乘子序列(最值型)</h2><p>给定a[0],…,a[n-1]，找到最长的连续子序列i，i+1，i+2，…，j，使得 a[i] * a[i+1] * … * a[j]最大</p><p>例子：</p><blockquote><p>输入：[2, 3, -2, 4]<br>输出：6(子序列 2，3:  2 * 3 = 6)</p></blockquote><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>最值型动态规划</p><ol><li>最后一步：对于最优的策略(乘积最大)，一定有最后一个元素a[j]</li><li>第一种情况：最优策略的序列就是{a[j]}，答案是a[j]</li><li>第二种情况：连续子序列长度大于1，那么最优策略中a[j]前一个元素肯定是a[j-1]</li><li>但是如果a[j]是正数，我们希望以a[j-1]结尾的连续子序列乘积最大；如果a[j]是负数，我们希望以a[j-1]结尾的连续子序列乘积最小。</li></ol><p><strong>子问题</strong></p><ol><li>可以同时求以a[j]结尾的连续子序列的最大乘积和以a[j]结尾的连续子序列的最小乘积</li><li>两种情况都需要求以a[j-1]结尾的乘积最大/小连续子序列。</li></ol><p><strong>转移方程</strong></p><ol><li>设f[j] 为以a[j]结尾的连续子序列的最大乘积，设g[j]为以a[j]结尾的连续子序列的最小乘积。</li><li>f[j] = max{a[j], max{a[j] * f[j-1], a[j] * g[j-1]} | j &gt; 0} 以a[j]结尾的连续子序列的最大乘积，包含两种情况，①子序列就a[j]本身 ②以a[j-1]结尾的子序列的最大/小乘积 再乘上a[j]。</li><li>g[j] = min{a[j], min{a[j] * f[j-1], a[j] * g[j-1]} | j &gt; 0} </li></ol><p><strong>初始条件</strong></p><ol><li>空</li></ol><p><strong>边界问题</strong></p><ol><li>情况②的时候需满足 a[j] 前边至少还有一个元素</li></ol><p><strong>计算顺序</strong></p><ol><li>计算f[0],g[0],f[1],g[1],….f[n-1],g[n-1]</li><li>最终答案是max{f[0],f[1],…,f[n-1]}</li><li>算法时间复杂度O(n)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp_max = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] dp_min = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="comment">// 由于存在负数，所以需要维护两个数组</span></span><br><span class="line">    <span class="comment">// dp_max[i] 指的是以第 i 个数结尾的 乘积最大 的连续子序列</span></span><br><span class="line">    <span class="comment">// dp_min[i] 指的是以第 i 个数结尾的 乘积最小 的连续子序列</span></span><br><span class="line">    dp_max[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp_min[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">// 如果数组的数是负数，那么会导致 max 变成 min，min 变成 max</span></span><br><span class="line">        <span class="comment">// 故需要交换dp </span></span><br><span class="line">        <span class="keyword">if</span>(nums[i-<span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = dp_min[i-<span class="number">1</span>];</span><br><span class="line">            dp_min[i-<span class="number">1</span>] = dp_max[i-<span class="number">1</span>];</span><br><span class="line">            dp_max[i-<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        dp_min[i] = Math.min(nums[i-<span class="number">1</span>],dp_min[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>]);</span><br><span class="line">        dp_max[i] = Math.max(nums[i-<span class="number">1</span>],dp_max[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>]);</span><br><span class="line">        max = Math.max(max,dp_max[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE, imax = <span class="number">1</span>, imin = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span>)&#123; </span><br><span class="line">          <span class="keyword">int</span> tmp = imax;</span><br><span class="line">          imax = imin;</span><br><span class="line">          imin = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        imax = Math.max(imax*nums[i], nums[i]);</span><br><span class="line">        imin = Math.min(imin*nums[i], nums[i]);</span><br><span class="line">        </span><br><span class="line">        max = Math.max(max, imax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同路径Ⅱ-坐标型"><a href="#不同路径Ⅱ-坐标型" class="headerlink" title="不同路径Ⅱ (坐标型)"></a>不同路径Ⅱ (坐标型)</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>说明：m 和 n 的值均不超过 100。</p><p>示例 1:</p><blockquote><p>输入:<br>[<br>[0,0,0],<br>[0,1,0],<br>[0,0,0]<br>]  </p></blockquote><blockquote><p>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：  </p><ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li></ol></blockquote><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>坐标型动态规划</p><p>此题和上边的不同路径很相似，只是网格中有障碍。</p><ul><li>最后一步一定是从左边(i, j-1)或上边 (i-1, j)过来。</li><li>状态dp[i][j]表示从左上角有多少种方式走到格子[i][j]</li><li>坐标型动态规划，数组下标[i][j]即坐标(i, j)</li></ul><p><strong>子问题</strong></p><p>子问题只是在数量级上减小了，计算步骤不变。</p><p><strong>转移方程</strong></p><p>dp[i][j] = dp[i-1][j] + dp[i][j-1]</p><p>机器人走到(i,j)有多少种方式 = 机器人走到(i-1, j)有多少种方式 + 机器人走到(i, j-1)有多少种方式</p><p><strong>初始条件</strong></p><ul><li>如果左上角(0,0)或右下角(m-1， n-1)有障碍，直接输出 0</li><li>如果(i,j)有障碍，dp[i][j]=0，表示机器人不能到达此格</li><li>dp[0][0] = 1</li></ul><p><strong>边界问题</strong></p><ul><li>dp[i][j] = 0 , 如果(i,j)有障碍</li><li>dp[i][j] = 1 , i=0 且 j=0</li><li>dp[i][j] = dp[i-1][j] , 如果j=1，即第一列</li><li>dp[i][j] = dp[i][j-1] , 如果i=1，即第一行</li><li>dp[i][j] = dp[i-1][j] + dp[i][j-1] , 其他</li></ul><p><strong>计算顺序</strong></p><p>dp[0][0]，dp[0][1]…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">int</span> r = obstacleGrid.length;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确定状态</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[r][c];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">            <span class="comment">//obstacle 遇到障碍</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//top-left (0,0)不是障碍 初始化为 1</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// left or up 非第一行 或 非第一列</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] += dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[r - <span class="number">1</span>][c - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="粉刷房子-序列型"><a href="#粉刷房子-序列型" class="headerlink" title="粉刷房子(序列型)"></a>粉刷房子(序列型)</h2><p>题意:<br>有一排N栋房子，每栋房子要漆成3种颜色中的一种:红、蓝、绿</p><ul><li>任何两栋相邻的房子不能漆成同样的颜色</li><li>第i栋房子染成红色、蓝色、绿色的花费分别是cost[i][0], cost[][1], cost[i][2]</li><li>问最少需要花多少钱油漆这些房子</li></ul><p>例子:</p><blockquote><p>输入:<br>N=3<br>Cost = [[14,2,11],[11,14,5],[14,3,10]]</p></blockquote><blockquote><p>输出:<br>10<br>(第0栋房子蓝色，第1栋房子绿色，第2栋房子蓝色，2+5+3=10) </p></blockquote><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>序列型动态规划</p><ul><li>最优策略是花费最小的策略</li><li>最后一步:最优策略中房子N-1-定染成了红、蓝、绿中的一-种。</li><li>但是相邻两栋房子不能漆成一种颜色好复杂。</li><li>所以如果最优策略中房子N-1是红色，房子N-2只能是蓝色或绿色</li><li>所以如果最优策略中房子N-1是蓝色，房子N-2只能是红色或绿色</li><li>所以如果最优策略中房子N-1是绿色，房子N-2只能是红色或蓝色</li></ul><p><strong>子问题</strong></p><ul><li>根据套路，也需要记录油漆前N-1栋房子的最小花费</li><li>但是，前N-1 栋房子的最小花费的最优策略中，不知道房子N-2是什么颜色，所以有可能和房子N-1撞色</li></ul><p><strong>不知道房子N-2是什么颜色，就把它记录下来</strong>。</p><ul><li>求油漆前N栋房子并且房子N-1是红色、蓝色、绿色的最小花费</li><li>需要知道油漆前N-1栋房子并且房子N-2是红色、蓝色、绿色的最小花费</li></ul><p>状态:</p><p>设油漆前栋房子并且房子i-1是红色、蓝色、绿色的最小花费分别dp[i][0], dp[i][1], dp[i][2]</p><p><strong>转移方程</strong></p><ol><li>房子i是红色，房子i-1为蓝色、绿色</li></ol><p>dp[i][0] = min{[i-1][1] + cost[i-1][0], f[-1][2] + cost[i-1][0]}</p><ol start="2"><li>房子i是蓝色，房子i-1为红色、绿色</li></ol><p>dp[i][1] = min{[i-1][0] + cost[i-1][1], f[-1][2] + cost[i-1][1]}</p><ol start="3"><li>房子i是绿色，房子i-1为红色、蓝色</li></ol><p>dp[i][2] = min{[i-1][0] + cost[i-1][2], f[-1][1] + cost[i-1][2]}</p><p><strong>初始条件</strong></p><ol><li>不油漆任何房子的花费</li></ol><p>dp[0][0] = dp[0][1] = dp[0][2] = 0</p><p><strong>边界条件</strong></p><ol><li>无</li></ol><p><strong>计算顺序</strong></p><ol><li>初始化 dp[0][0], dp[0][1], dp[0][2]</li><li>计算 dp[1][0], dp[1][1], dp[1][2]</li><li>…</li><li>dp[n][0], dp[n][1], dp[n][2]</li><li>答案是 min{dp[n][0], dp[n][1], dp[n][2]}。时间复杂度O(N)，空间复杂度O(N)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[][] houses)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = houses.length;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//序列型 DP</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每一个房子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="comment">// 房子颜色</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++)&#123;</span><br><span class="line">            dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">3</span>; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (j != k)&#123;</span><br><span class="line">                    <span class="comment">// 当前房子花费最小的配色方案</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i-<span class="number">1</span>][k] + houses[i-<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(dp[n][<span class="number">0</span>], Math.min(dp[n][<span class="number">1</span>], dp[n][<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解码方法-划分型"><a href="#解码方法-划分型" class="headerlink" title="解码方法(划分型)"></a>解码方法(划分型)</h2><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p><p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>给定一个只包含数字的非空字符串，请计算解码方法的总数。</p><p>示例 1:</p><blockquote><p>输入: “12”<br>输出: 2<br>解释: 它可以解码为 “AB”（1 2）或者 “L”（12）。  </p></blockquote><p>示例 2:</p><blockquote><p>输入: “226”<br>输出: 3<br>解释: 它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。</p></blockquote><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><ul><li>解密数字串即划分成若干段数字，每段数字对应- 一个字母.</li><li>最后一步(最后一段) : 对应一个字母 A, B, …或Z</li><li>这个字母加密时变成1, 2, …或26</li></ul><p>最后一个字母加密成一个数字或两个数字</p><p>设数字串s前i个数字解密成字母串有dp[i]种方式</p><p><strong>子问题</strong></p><ul><li>设数字串长度为N</li><li>求数字串前N个字符的解密方式数</li><li>需要知道数字串前N-1和N-2个字符的解密方式数</li></ul><p><strong>转移方程</strong></p><p>dp[j] = dp[i-1]| S[i-1]对应-一个字母+ dp[i-2]| S[i-2]S[i-1]对应一个字母</p><p>数字串S前i个数字解密成字母串的方式数 = 数字串S前i-1个数字解密成字母串的方式数 + 数字串S前i-2个数字解密成字母串的方式数</p><p><strong>初始条件</strong></p><p>dp[0] = 1, 即空串有一种方式解密</p><p><strong>边界问题</strong></p><p>如果i=1，只看最后一个数字</p><p><strong>计算顺序</strong></p><ul><li>dp[0],dp[1],…dp[n]</li><li>答案是 dp[n]</li><li>时间复杂度O(N), 空间复杂度O(N)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String ss)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] s = ss.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> n = s.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定状态，dp[i] 为前i个数字解密成字母有多少种方式</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始条件</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 字符串至少有一个数字</span></span><br><span class="line">        <span class="keyword">int</span> t = s[i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i] += dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 字符串中有两个数字时</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            t = (s[i - <span class="number">2</span>] - <span class="string">'0'</span>) * <span class="number">10</span> + (s[i - <span class="number">1</span>] - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span> (t &gt;= <span class="number">10</span> &amp;&amp; t &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">                <span class="comment">// s[i-2] 和 s[i-1] 共同解码成一个字母，只需要加dp[i-2]即可</span></span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长连续单调子序列-坐标型"><a href="#最长连续单调子序列-坐标型" class="headerlink" title="最长连续单调子序列(坐标型)"></a>最长连续单调子序列(坐标型)</h2><p>给定a[0], …. a[n-1] 找到最长的连续子序列i, i+1, i+2, …使得a[i] &lt; a[i+1]… &lt; a[j],或者<br>a[i] &gt; a[i+1] &gt; .. &gt;[j]，输出长度 j - i + 1 </p><p>例子:</p><blockquote><p>输入: [5,1,2,3, 4]<br>输出: 4 (子序列1,2, 3, 4)</p></blockquote><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><ul><li>首先，对于a[i]&gt;a[+1&gt;]…&gt;a[j]，可以将整个a序列倒过来，就变成求最长连续_上升子序列了</li><li>所以，只需要考虑找到最长的a[i]&lt;a[i+1]&lt;… &lt;a[j]</li><li>可以从每个a[j开始，一直向后延伸找到最长的连续上升序列</li><li>最差情况下，对于长度为N的序列，需要计算O(N2)步:0,1,2….,N-1 .</li></ul><hr><ul><li>最后一步：对于最优的策略，一定有最后一个元素a[j]</li><li>第一种情况：最优策略中<strong>最长连续上升子序列</strong>就是{a[j]}，答案是1</li><li>第二种情况：子序列长度大于1，那么最优策略中a[j]前一个元素肯定是a[j-1]，这种情况一定是a[j-1] &lt; a[j]</li><li>因为是最优策略，那么它选中的以a[j-1]结尾的连续上升子序列一定是最长的</li></ul><p><strong>子问题</strong></p><ul><li>要求以aj-1]结尾的最长连续上升子序列</li><li>本来是求以a[j]结尾的最长连续上升子序列</li></ul><p>状态:设dp[j] =以a[j]结尾的最长连续上升子序列的长度</p><p><strong>转移方程</strong></p><p>dp[j] = max{ 1，<br>dp[j-1]+1 | j&gt;0 and a[j-1] &lt; a[j]}</p><p>以a[j]结尾的最长连续上升子序列的长度 = 情况1 :子序列就是a[j]本身 + 情况2 :以a[j-1]结 尾的最长连续上升子序列的长度，加上a[j]</p><p><strong>初始条件</strong></p><ol><li>空</li></ol><p><strong>边界条件</strong></p><ol><li>情况2中 j &gt; 0 即 a[j]前至少还有一个元素</li><li>a[j] &gt; a[j-1]，满足单调性</li></ol><p><strong>计算顺序</strong></p><ul><li>计算dp[0], dp[1], dp[2], … dp[n-1]</li><li>因为我们不知道最优策略中最后一个元素是哪个a[j]，所以答案是<br>max{dp[0], dp[1], dp[2], … dp[n-1]}</li><li>算法时间复杂度O(n)，空间复杂度O(n)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestIncreasingContinuousSubsequence</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r1 = LIS(arr, n);</span><br><span class="line">    <span class="comment">// reverse</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>, t;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">        ++i;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r2 = LIS(arr, n);</span><br><span class="line">    <span class="keyword">return</span> Math.max(r1, r2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//case 1</span></span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//case 2</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; arr[i] &gt; arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长单调子序列"><a href="#最长单调子序列" class="headerlink" title="最长单调子序列"></a>最长单调子序列</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:</p><blockquote><p>输入: [10,9,2,5,3,7,101,18]<br>输出: 4   </p><p>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</p></blockquote><blockquote><p>说明:<br>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。<br>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?  </p></blockquote><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> // 上升子序列(不连续也可) O(n^2)</span><br><span class="line">public int lengthOfLIS1(int[] nums) &#123;</span><br><span class="line">    int n = nums.length;</span><br><span class="line">    // 确定状态, dp[i] 为nums[i]结尾的 最长子序列长度</span><br><span class="line">    int[] dp = new int[n];</span><br><span class="line">    // 子问题。1. 只有一个元素。2. 有多个且 nums[n-1] &lt; nums[n]</span><br><span class="line">    // 转移方程 dp[i] = max&#123;dp[1],dp[2],...,dp[n]&#125;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        // 初始条件</span><br><span class="line">        dp[i] = 1;</span><br><span class="line"></span><br><span class="line">        for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            if (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态规划+二分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上升子序列(不连续也可) O(n * ln(n))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tail[i] 表示长度为 i + 1 的所有上升子序列的结尾的最小值。</span></span><br><span class="line">    <span class="keyword">int</span>[] tails = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = res;</span><br><span class="line">        <span class="comment">// 在tails中，通过 二分查找 确定num应该放在tails中的i位置 在哪里(追加/替换)</span></span><br><span class="line">        <span class="comment">// 情况①：如果大于则添加到最后，情况②：在tails中找到第一个大于num的，替换</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (tails[m] &lt; num) &#123;</span><br><span class="line">                i = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tails[i] = num;</span><br><span class="line">        <span class="comment">// 如果发生情况①，res=j，如果发生情况②，res!=j，会比j小</span></span><br><span class="line">        <span class="comment">// res为当前产生的最长的增序的长度</span></span><br><span class="line">        <span class="keyword">if</span> (res == j) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h2><p>给定m行n列的网格，每个格子(i,j) 里边都有一个非负数A[i][j]</p><p>求一个从左上角(0,0) 到右下角的路径，每一步只能向下或者向右走一步，使得路径上的格子里的数字之和最小。</p><p>输出最小数字和</p><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><p>最值型动态规划</p><p>和Unique Path一样，无论用何种方式走到右下角，总有最后一步：向右，向下</p><p>右下角坐标设为(m-1, n-1)</p><p>前一步一定是在 (m-2, n-2)或者(m-1, n-2)</p><p><strong>确定状态</strong></p><p>最优策略的路径总和数字最小</p><ul><li>若倒数第二步在(m-2, n-1)，则前面一定是从(0, 0)到达(m-2, n-1)总和最小的路径</li><li>若倒数第二步在(m-1, n-2)，则前面一定是从(0, 0)到达(m-1, n-2)总和最小的路径</li></ul><p><strong>子问题</strong></p><ul><li>要求从左上角走到(m-1， n-2)的路径的最小数字总和以及走到(m-2，n-1)的路径的最小数字总和</li><li>原题要求有从左上角走到(m-1, n-1)的路径的最小数字的总和</li></ul><p><strong>转移方程</strong></p><p>设 从(0, 0)走到(i, j)的路径最小数字总和dp[i][j]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = min&#123;dp[i-1][j], dp[i][j-1]&#125; + A[i][j]</span><br><span class="line"></span><br><span class="line">从(0,0)走到格子(i,j)的最小路径数字总和 = min&#123; 从(0,0)走到格子(i-1,j)的最小路径数字总和, 从(0,0)走到格子(i, j-1)的最小路径数字总和&#125; + 格子(i,j)的数字</span><br></pre></td></tr></table></figure><p><strong>初始条件和边界情况</strong></p><ul><li>初始条件：dp[0][0] = A[0][0]</li><li>i=0 或 j=0，则前一步只能从一个方向过来</li></ul><p><strong>计算顺序</strong></p><ul><li>dp[0][0] = A[0][0]</li><li>计算第0行：dp[0][0], dp[0][1], ……,dp[0][n-1] </li><li>计算第1行：dp[1][0], dp[1][1], ……,dp[1][n-1] </li><li>····</li><li>计算第m-1行：dp[m-1][0], dp[m-1][1], ……,dp[m-1][n-1] </li><li>dp[i][j] = dp[i-1][j] + dp[i][j-1]</li><li>时间复杂度(计算步数)：O(MN)，空间复杂度(数组大小)：O(MN)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = A.length;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = A[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="comment">// dp[i][j] = min&#123;dp[i-1][j], dp[i][j-1]&#125; + A[i][j]</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// dp[0][0] = A[0][0]</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j] = A[i][j];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> t = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">if</span>( i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                t = Math.min(t, dp[i-<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                t = Math.min(t, dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            dp[i][j] = t + A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用滚动数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = A.length;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = A[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 开两行数组</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][n];</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 开两个指针</span></span><br><span class="line">    <span class="keyword">int</span> old, now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="comment">// 3. 滚动 swap old and now</span></span><br><span class="line">        old = now;</span><br><span class="line">        now = <span class="number">1</span> - now;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="comment">// dp[i][j] = min&#123;dp[i-1][j], dp[i][j-1]&#125; + A[i][j]</span></span><br><span class="line">            <span class="comment">// dp[0][0] = A[0][0]</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)&#123;</span><br><span class="line">                dp[now][j] = A[i][j];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> t = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">if</span>( i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                t = Math.min(t, dp[old][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                t = Math.min(t, dp[now][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            dp[now][j] = t + A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[now][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="xxxx"><a href="#xxxx" class="headerlink" title="xxxx"></a>xxxx</h2><h3 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将常见的动态规划做了整合，根据不同的题目总结其特点，根据各自特点找出通用的解题思路。尚未完全总结完成。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://jelly54.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://jelly54.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://jelly54.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>高频算法题-zs</title>
    <link href="https://jelly54.github.io/alg-frequenceCode/"/>
    <id>https://jelly54.github.io/alg-frequenceCode/</id>
    <published>2020-03-01T02:53:54.000Z</published>
    <updated>2020-08-28T06:29:24.747Z</updated>
    
    <content type="html"><![CDATA[<p>来源《程序员代码面试指南》左程云著</p><ul><li><a href="#%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98">排序问题</a><ul><li><a href="#%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98">小和问题</a></li><li><a href="#%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98">逆序对问题</a></li><li><a href="#%E7%9B%B8%E9%82%BB%E4%B8%A4%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC">相邻两数的最大差值</a></li></ul></li><li><a href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97">栈和队列</a><ul><li><a href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%9A%84%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88">数组实现固定大小的队列和栈</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E8%BF%94%E5%9B%9E%E6%A0%88%E4%B8%AD%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0">实现返回栈中最小元素</a><ul><li><a href="#%E8%A6%81%E6%B1%82">要求</a></li></ul></li><li><a href="#%E5%A6%82%E4%BD%95%E4%BB%85%E7%94%A8%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E6%A0%88%E7%BB%93%E6%9E%84">如何仅用队列结构实现栈结构？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E4%BB%85%E7%94%A8%E6%A0%88%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84">如何仅用栈结构实现队列结构？</a></li><li><a href="#%E7%8C%AB%E7%8B%97%E9%98%9F%E5%88%97">猫狗队列</a><ul><li><a href="#%E8%A6%81%E6%B1%82-1">要求</a> <a id="more"></a></li></ul></li></ul></li><li><a href="#%E7%9F%A9%E9%98%B5">矩阵</a><ul><li><a href="#%E8%BD%AC%E5%9C%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5">转圈打印矩阵</a><ul><li><a href="#%E8%A6%81%E6%B1%82-2">要求</a></li></ul></li><li><a href="#%E6%97%8B%E8%BD%AC%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9F%A9%E9%98%B5">旋转正方形矩阵</a><ul><li><a href="#%E8%A6%81%E6%B1%82-3">要求</a></li></ul></li><li><a href="#%E5%8F%8D%E8%BD%AC%E5%8D%95%E5%90%91%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">反转单向和双向链表</a><ul><li><a href="#%E8%A6%81%E6%B1%82-4">要求</a></li></ul></li><li><a href="#%E4%B9%8B-%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5">“之” 字形打印矩阵</a><ul><li><a href="#%E8%A6%81%E6%B1%82-5">要求</a></li></ul></li><li><a href="#%E5%9C%A8%E8%A1%8C%E5%88%97%E9%83%BD%E6%8E%92%E5%A5%BD%E5%BA%8F%E7%9A%84%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%89%BE%E6%95%B0">在行列都排好序的矩阵中找数</a><ul><li><a href="#%E8%A6%81%E6%B1%82-6">要求</a></li></ul></li></ul></li><li><a href="#%E9%93%BE%E8%A1%A8">链表</a><ul><li><a href="#%E6%89%93%E5%8D%B0%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9">打印两个有序链表的公共节点</a></li><li><a href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84">判断一个链表是否为回文结构</a></li><li><a href="#%E5%B0%86%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E6%8C%89%E6%9F%90%E5%80%BC%E5%88%92%E5%88%86%E6%88%90%E5%B7%A6%E8%BE%B9%E5%B0%8F-%E4%B8%AD%E9%97%B4%E7%9B%B8%E7%AD%89-%E5%8F%B3%E8%BE%B9%E5%A4%A7%E7%9A%84%E5%BD%A2%E5%BC%8F">将单向链表按某值划分成左边小、 中间相等、 右边大的形式</a></li><li><a href="#%E5%A4%8D%E5%88%B6%E5%90%AB%E6%9C%89%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E8%8A%82%E7%82%B9%E7%9A%84%E9%93%BE%E8%A1%A8">复制含有随机指针节点的链表</a></li><li><a href="#%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98">两个单链表相交的一系列问题</a><ul><li><a href="#%E5%8F%AF%E8%83%BD%E6%83%85%E5%86%B5">可能情况</a></li></ul></li></ul></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a><ul><li><a href="#%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9">在二叉树中找到一个节点的后继节点</a></li><li><a href="#%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">判断一棵二叉树是否是平衡二叉树</a></li><li><a href="#%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91">判断一棵树是否是搜索二叉树、</a></li><li><a href="#%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">判断一棵树是否是完全二叉树</a></li><li><a href="#%E5%B7%B2%E7%9F%A5%E4%B8%80%E6%A3%B5%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91-%E6%B1%82%E5%85%B6%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0">已知一棵完全二叉树， 求其节点的个数</a></li><li><a href="#%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98">折纸问题</a></li></ul></li><li><a href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8">布隆过滤器</a><ul><li><a href="#url%E7%AD%9B%E9%80%89">URL筛选</a><ul><li><a href="#%E8%A6%81%E6%B1%82-7">要求</a></li></ul></li></ul></li><li><a href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C">一致性哈希</a><ul><li><a href="#%E9%97%AE%E9%A2%98">问题</a></li><li><a href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">解决办法</a></li></ul></li><li><a href="#%E5%B2%9B%E9%97%AE%E9%A2%98">岛问题</a></li><li><a href="#%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集</a></li><li><a href="#%E5%89%8D%E7%BC%80%E6%A0%91">前缀树</a></li><li><a href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">贪心算法</a><ul><li><a href="#%E5%88%87%E9%87%91%E6%9D%A1">切金条</a></li><li><a href="#%E5%81%9A%E9%A1%B9%E7%9B%AEipo">做项目(IPO)</a></li><li><a href="#%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E9%9A%8F%E6%97%B6%E5%8F%AF%E4%BB%A5%E5%8F%96%E5%BE%97%E4%B8%AD%E4%BD%8D%E6%95%B0">一个数据流中，随时可以取得中位数</a></li><li><a href="#%E6%9C%80%E4%BD%8E%E5%AD%97%E5%85%B8%E5%BA%8F">最低字典序</a></li><li><a href="#%E5%AE%A3%E8%AE%B2%E4%BC%9A">宣讲会</a></li></ul></li><li><a href="#%E9%80%92%E5%BD%92%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">递归&amp;动态规划</a><ul><li><a href="#%E6%B1%82n%E7%9A%84%E7%BB%93%E6%9E%9C">求n!的结果</a></li><li><a href="#%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98">汉诺塔问题</a></li><li><a href="#%E6%89%93%E5%8D%B0%E5%85%A8%E9%83%A8%E5%AD%90%E5%BA%8F%E5%88%97">打印全部子序列</a></li><li><a href="#%E6%89%93%E5%8D%B0%E5%85%A8%E6%8E%92%E5%88%97">打印全排列</a></li><li><a href="#%E7%94%9F%E7%89%9B%E9%97%AE%E9%A2%98">生牛问题</a></li><li><a href="#%E7%94%9F%E7%89%9B%E9%97%AE%E9%A2%98%E6%AF%8D%E7%89%9B%E5%8F%AA%E8%83%BD%E6%B4%BB10%E5%B9%B4">生牛问题(母牛只能活10年)</a></li><li><a href="#%E9%80%92%E5%BD%92%E9%80%86%E5%BA%8F%E6%A0%88">递归逆序栈</a></li><li><a href="#%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84">最小路径</a><ul><li><a href="#%E6%97%A0%E5%90%8E%E6%95%88%E6%80%A7%E9%97%AE%E9%A2%98%E9%83%BD%E5%8F%AF%E4%BB%A5%E6%94%B9%E6%88%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">无后效性问题都可以改成动态规划</a></li></ul></li><li><a href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">背包问题</a><ul><li><a href="#%E5%88%86%E6%9E%90">分析</a></li></ul></li><li><a href="#%E5%95%86%E5%93%81%E4%BB%B7%E5%80%BC">商品价值</a></li></ul></li></ul><h1 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h1><h2 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h2><p>在一个数组中， 每一个数左边比当前数小的数累加起来， 叫做这个数组的小和。 求一个数组<br>的小和。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">[1,3,4,2,5]</span><br><span class="line">1左边比1小的数， 没有；</span><br><span class="line">3左边比3小的数， 1；</span><br><span class="line">4左边比4小的数， 1、 3；</span><br><span class="line">2左边比2小的数， 1；</span><br><span class="line">5左边比5小的数， 1、 3、 4、 2；</span><br><span class="line">所以小和为1+1+3+1+1+3+4+2=16</span><br></pre></td></tr></table></figure><p><strong>题解：</strong></p><p>利用归并排序，在merge的时候计算有几个数比它小。因为分区两边都将是有序的，当左边分组元素小于右边分组元素，将会有  (r - p2 + 1) * arr[p1] 个小数。r为最右边边界，p2为右边分组元素下标，arr[p1] 为左边分组元素，相加则为产生的小和。</p><p>因为整体将趋于有序，而且每次merge之后元素都将归入左边，所有之后不会重复计算小和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">smallSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> mergeSort(arr, l, mid) + mergeSort(arr, mid + <span class="number">1</span>, r) + merge(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> p1 = l;</span><br><span class="line"><span class="keyword">int</span> p2 = m + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;</span><br><span class="line">    <span class="comment">//计算小和</span></span><br><span class="line">res += arr[p1] &lt; arr[p2] ? (r - p2 + <span class="number">1</span>) * arr[p1] : <span class="number">0</span>;</span><br><span class="line">help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (p1 &lt;= m) &#123;</span><br><span class="line">help[i++] = arr[p1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (p2 &lt;= r) &#123;</span><br><span class="line">help[i++] = arr[p2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">arr[l + i] = help[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h2><p>在一个数组中， 左边的数如果比右边的数大， 则折两个数构成一个逆序对， 请打印所有逆序<br>对。</p><p><strong>题解：</strong></p><p>与上题解题思路一致。将计算小和改为判断 arr[p1] &gt; arr[p2] 如果是，则打印 arr[p1], arr[p2]即可。</p><h2 id="相邻两数的最大差值"><a href="#相邻两数的最大差值" class="headerlink" title="相邻两数的最大差值"></a>相邻两数的最大差值</h2><p>给定一个数组， 求如果排序之后， 相邻两数的最大差值。</p><p>要求时间复杂度O(N),且要求不能用非基于比较的排序。</p><p><strong>题解：</strong></p><p>使用桶排序的概念，在此基础上进行优化。</p><ol><li>遍历给定的数组，找到数组中的最大值、最小值(最大值等于最小值时说明，数组中数据都一样，返回 0 ),用于计算桶id。</li><li>准备n+1 个桶，对于每个桶中的元素设定三个标志位。是否有数据 hasNum、最大值 maxs、最小值 mins。</li><li>再次遍历标志位。第0 个桶一定非空，且为最小值。从第一个桶开始遍历，找到每个非空桶(hasNum[i] 为 true)，非空桶的最小值与它前边最近的非空桶的最大值 作差，与全局变量res作比较。遍历结束之后将得到最大的差值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxGap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len = nums.length;</span><br><span class="line"><span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">min = Math.min(min, nums[i]);</span><br><span class="line">max = Math.max(max, nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果最小值等于最大值，则数组中只有相同的数，最大差值为 0.</span></span><br><span class="line"><span class="keyword">if</span> (min == max) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算每个桶中的三个标志位。</span></span><br><span class="line"><span class="keyword">boolean</span>[] hasNum = <span class="keyword">new</span> <span class="keyword">boolean</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span>[] maxs = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span>[] mins = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> bid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">bid = bucket(nums[i], len, min, max);</span><br><span class="line">mins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums</span><br><span class="line">maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums</span><br><span class="line">hasNum[bid] = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从第一个桶开始。寻找不为空的桶，它的最小值和它之前最近的桶的最大值的差值，</span></span><br><span class="line"><span class="comment">// 与全局变量res进行比较，遍历完则找到最大差值。</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> lastMax = maxs[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt;= len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (hasNum[i]) &#123;</span><br><span class="line">res = Math.max(res, mins[i] - lastMax);</span><br><span class="line">lastMax = maxs[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小值将存在0号桶，最大值将存在length号桶。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bucket</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">long</span> len, <span class="keyword">long</span> min, <span class="keyword">long</span> max)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) ((num - min) * len / (max - min));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="数组实现固定大小的队列和栈"><a href="#数组实现固定大小的队列和栈" class="headerlink" title="数组实现固定大小的队列和栈"></a>数组实现固定大小的队列和栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jelly.algorithm.array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array2QueueStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数组实现队列 测试</span></span><br><span class="line">        AQueue aQueue = <span class="keyword">new</span> AQueue(<span class="number">3</span>);</span><br><span class="line">        aQueue.offer(<span class="number">1</span>);</span><br><span class="line">        aQueue.offer(<span class="number">2</span>);</span><br><span class="line">        aQueue.offer(<span class="number">3</span>);</span><br><span class="line">        aQueue.offer(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(aQueue.poll());</span><br><span class="line"></span><br><span class="line">        aQueue.offer(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(aQueue.peek());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组实现栈 测试</span></span><br><span class="line">        AStack aStack = <span class="keyword">new</span> AStack(<span class="number">3</span>);</span><br><span class="line">        aStack.push(<span class="number">1</span>);</span><br><span class="line">        aStack.push(<span class="number">2</span>);</span><br><span class="line">        aStack.push(<span class="number">3</span>);</span><br><span class="line">        aStack.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(aStack.pop());</span><br><span class="line"></span><br><span class="line">        aStack.push(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(aStack.peek());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组实现大小固定的队列。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * arr：存储队列中的数据。</span></span><br><span class="line"><span class="comment"> * size：记录队列中有多少数据了。</span></span><br><span class="line"><span class="comment"> * start：记录出队列的位置。每次出start位置上的数据。</span></span><br><span class="line"><span class="comment"> * end：记录入队列的位置。每次入队列存入end的位置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AQueue</span><span class="params">(<span class="keyword">int</span> initSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = <span class="keyword">new</span> <span class="keyword">int</span>[initSize];</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.end = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Integer n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == arr.length) &#123;</span><br><span class="line">            System.out.println(<span class="string">"queue is full!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size++;</span><br><span class="line">        arr[end] = n;</span><br><span class="line">        end = end == arr.length - <span class="number">1</span> ? <span class="number">0</span> : end + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"queue is empty!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[start];</span><br><span class="line">        start = start == arr.length - <span class="number">1</span> ? <span class="number">0</span> : start + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"queue is empty!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组实现大小固定的栈。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * arr：存储栈中的数据。</span></span><br><span class="line"><span class="comment"> * size：栈中存储多少数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AStack</span><span class="params">(<span class="keyword">int</span> initSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = <span class="keyword">new</span> <span class="keyword">int</span>[initSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(Integer n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == arr.length) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack is full!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[size++] = n;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack is empty!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack is empty!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="实现返回栈中最小元素"><a href="#实现返回栈中最小元素" class="headerlink" title="实现返回栈中最小元素"></a>实现返回栈中最小元素</h2><p>实现一个特殊的栈， 在实现栈的基本功能的基础上， 再实现返<br>回栈中最小元素的操作。</p><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ol><li>pop、 push、 getMin操作的时间复杂度都是O(1)。</li><li>设计的栈类型可以使用现成的栈结构。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jelly.algorithm.array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetMinStack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyStack myStack = <span class="keyword">new</span> MyStack();</span><br><span class="line">        myStack.push(<span class="number">5</span>);</span><br><span class="line">        myStack.push(<span class="number">1</span>);</span><br><span class="line">        System.out.println(myStack.getMin());</span><br><span class="line">        System.out.println(myStack.pop());</span><br><span class="line">        myStack.push(<span class="number">3</span>);</span><br><span class="line">        myStack.push(<span class="number">8</span>);</span><br><span class="line">        System.out.println(myStack.getMin());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以返回栈中最小元素的栈。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * pop、 push、 getMin操作的时间复杂度都是O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackData;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackMin;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stackData = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.stackMin = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Integer n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最小值栈中没有数据直接进栈。</span></span><br><span class="line">        <span class="comment">// 栈中有数据判断插入数据n 是否小于当前栈中最小值，小则插入n，否则再次插入栈中最小值 </span></span><br><span class="line">        <span class="keyword">if</span> (stackMin.isEmpty()) &#123;</span><br><span class="line">            stackMin.push(n);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= getMin()) &#123;</span><br><span class="line">            stackMin.push(n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stackMin.push(getMin());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stackData.push(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackData.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack is empty!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 弹栈时，数据栈和最小值栈同时弹出。</span></span><br><span class="line">        stackMin.pop();</span><br><span class="line">        <span class="keyword">return</span> stackData.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackMin.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack is empty!!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="如何仅用队列结构实现栈结构？"><a href="#如何仅用队列结构实现栈结构？" class="headerlink" title="如何仅用队列结构实现栈结构？"></a>如何仅用队列结构实现栈结构？</h2><p>见下题</p><h2 id="如何仅用栈结构实现队列结构？"><a href="#如何仅用栈结构实现队列结构？" class="headerlink" title="如何仅用栈结构实现队列结构？"></a>如何仅用栈结构实现队列结构？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jelly.algorithm.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackAndQueueConvert</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 栈实现队列，应打印 1,2</span></span><br><span class="line">        Stack2Queue stack2Queue = <span class="keyword">new</span> Stack2Queue();</span><br><span class="line">        stack2Queue.offer(<span class="number">1</span>);</span><br><span class="line">        stack2Queue.offer(<span class="number">2</span>);</span><br><span class="line">        stack2Queue.offer(<span class="number">3</span>);</span><br><span class="line">        System.out.println(stack2Queue.poll());</span><br><span class="line">        stack2Queue.offer(<span class="number">4</span>);</span><br><span class="line">        stack2Queue.offer(<span class="number">5</span>);</span><br><span class="line">        System.out.println(stack2Queue.peek());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"----------------------"</span>);</span><br><span class="line">        <span class="comment">// 队列实现栈，应打印 3,5</span></span><br><span class="line">        Queue2Stack queue2Stack = <span class="keyword">new</span> Queue2Stack();</span><br><span class="line">        queue2Stack.push(<span class="number">1</span>);</span><br><span class="line">        queue2Stack.push(<span class="number">2</span>);</span><br><span class="line">        queue2Stack.push(<span class="number">3</span>);</span><br><span class="line">        System.out.println(queue2Stack.pop());</span><br><span class="line">        queue2Stack.push(<span class="number">4</span>);</span><br><span class="line">        queue2Stack.push(<span class="number">5</span>);</span><br><span class="line">        System.out.println(queue2Stack.peek());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两个栈实现队列</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 入队列栈中数据倒入出队列栈中的数据时，要保证出队列栈中无数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack2Queue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; in;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; out;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack2Queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.out = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Integer n)</span> </span>&#123;</span><br><span class="line">        in.push(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (out.empty() &amp;&amp; in.empty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"queue is empty!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (out.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!in.empty()) &#123;</span><br><span class="line">                out.push(in.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (out.empty() &amp;&amp; in.empty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"queue is empty!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (out.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!in.empty()) &#123;</span><br><span class="line">                out.push(in.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两个队列实现栈</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 入栈直接放入stack这个队列中。</span></span><br><span class="line"><span class="comment"> * 每次出栈，将n-1个数据通过help队列保存，返回第n个数据，然后改变help、stack指针 即可。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue2Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; help;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue2Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.help = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Integer n)</span> </span>&#123;</span><br><span class="line">        stack.offer(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack is empty!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (stack.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            help.offer(stack.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = stack.poll();</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; tmp = help;</span><br><span class="line">        help = stack;</span><br><span class="line">        stack = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack is empty!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (stack.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            help.offer(stack.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = stack.poll();</span><br><span class="line">        <span class="comment">// peek 不删除，需加上res</span></span><br><span class="line">        help.offer(res);</span><br><span class="line"></span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="猫狗队列"><a href="#猫狗队列" class="headerlink" title="猫狗队列"></a>猫狗队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pet</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPetType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"dog"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"cat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现一种狗猫队列的结构， </p><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><ul><li>用户可以调用add方法将cat类或dog类的实例放入队列中；</li><li>用户可以调用pollAll方法，将队列中所有的实例按照进队列的先后顺序依次弹出；</li><li>用户可以调用pollDog方法，将队列中dog类的实例按照进队列的先后顺序依次弹出；</li><li>用户可以调用pollCat方法，将队列中cat类的实例按照进队列的先后顺序依次弹出；</li><li>用户可以调用isEmpty方法， 检查队列中是<br>否还有dog或cat的实例；</li><li>用户可以调用isDogEmpty方法，检查队列中是否有dog类的实例； </li><li>用户可以调用isCatEmpty方法， 检查队列中是否有cat类的实例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jelly.algorithm.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatDogQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;PetEntity&gt; catQ;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;PetEntity&gt; dogQ;</span><br><span class="line">    <span class="keyword">private</span> Long count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CatDogQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.catQ = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.dogQ = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Pet pet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pet.getPetType().equals(<span class="string">"cat"</span>)) &#123;</span><br><span class="line">            catQ.add(<span class="keyword">new</span> PetEntity(pet, <span class="keyword">this</span>.count++));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pet.getPetType().equals(<span class="string">"dog"</span>)) &#123;</span><br><span class="line">            dogQ.add(<span class="keyword">new</span> PetEntity(pet, <span class="keyword">this</span>.count++));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"NOT cat or dog!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">pollAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!catQ.isEmpty() &amp;&amp; !dogQ.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (catQ.peek().getCount() &lt; dogQ.peek().getCount()) &#123;</span><br><span class="line">                <span class="keyword">return</span> catQ.poll().getPet();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> dogQ.poll().getPet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!catQ.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> catQ.poll().getPet();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dogQ.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> dogQ.poll().getPet();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cat <span class="title">pollCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (catQ.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (Cat) catQ.poll().getPet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">pollDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dogQ.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Dog) dogQ.poll().getPet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> catQ.isEmpty() &amp;&amp; dogQ.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCatQueueEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> catQ.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDogQueueEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dogQ.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CatDogQueue test = <span class="keyword">new</span> CatDogQueue();</span><br><span class="line"></span><br><span class="line">        Pet dog1 = <span class="keyword">new</span> Dog();</span><br><span class="line">        Pet cat1 = <span class="keyword">new</span> Cat();</span><br><span class="line">        Pet dog2 = <span class="keyword">new</span> Dog();</span><br><span class="line">        Pet cat2 = <span class="keyword">new</span> Cat();</span><br><span class="line">        Pet dog3 = <span class="keyword">new</span> Dog();</span><br><span class="line">        Pet cat3 = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line">        test.add(dog1);</span><br><span class="line">        test.add(cat1);</span><br><span class="line">        test.add(dog2);</span><br><span class="line">        test.add(cat2);</span><br><span class="line">        test.add(dog3);</span><br><span class="line">        test.add(cat3);</span><br><span class="line"></span><br><span class="line">        test.add(dog1);</span><br><span class="line">        test.add(cat1);</span><br><span class="line">        test.add(dog2);</span><br><span class="line">        test.add(cat2);</span><br><span class="line">        test.add(dog3);</span><br><span class="line">        test.add(cat3);</span><br><span class="line"></span><br><span class="line">        test.add(dog1);</span><br><span class="line">        test.add(cat1);</span><br><span class="line">        test.add(dog2);</span><br><span class="line">        test.add(cat2);</span><br><span class="line">        test.add(dog3);</span><br><span class="line">        test.add(cat3);</span><br><span class="line">        <span class="keyword">while</span> (!test.isDogQueueEmpty()) &#123;</span><br><span class="line">            System.out.println(test.pollDog().getPetType());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!test.isEmpty()) &#123;</span><br><span class="line">            System.out.println(test.pollAll().getPetType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pet</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPetType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"dog"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"cat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PetEntity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">    <span class="keyword">private</span> Long count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PetEntity</span><span class="params">(Pet pet, Long count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pet = pet;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">getPet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="转圈打印矩阵"><a href="#转圈打印矩阵" class="headerlink" title="转圈打印矩阵"></a>转圈打印矩阵</h2><p>给定一个整型矩阵matrix， 请按照转圈的方式打印它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">1   2   3   4</span><br><span class="line">5   6   7   8</span><br><span class="line">9  10  11  12</span><br><span class="line">13 14  15  16 </span><br><span class="line"></span><br><span class="line">打印结果为： </span><br><span class="line">1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10</span><br></pre></td></tr></table></figure><h3 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h3><p>额外空间复杂度为O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jelly.algorithm.matrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateMatrix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;, &#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix1 = &#123;&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        rotate(matrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 旋转打印</span></span><br><span class="line"><span class="comment">     * 每次层数减一，像剥洋葱一样，一次一层。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">spiralOrderPrint</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ar = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ac = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> br = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> bc = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ar &lt;= br &amp;&amp; ac &lt;= bc) &#123;</span><br><span class="line">            printEdge(matrix, ar++, ac++, br--, bc--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顺时针打印矩阵的环</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 待打印的矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ar     左上角行数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ac     左上角列数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> br     右下角行数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bc     右下角列数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> ar, <span class="keyword">int</span> ac, <span class="keyword">int</span> br, <span class="keyword">int</span> bc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ar == br) &#123;</span><br><span class="line">            <span class="comment">// 只有一行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ac; i &lt;= bc; i++) &#123;</span><br><span class="line">                System.out.print(matrix[ar][i] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ac == bc) &#123;</span><br><span class="line">            <span class="comment">// 只有一列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ar; i &lt;= br; i++) &#123;</span><br><span class="line">                System.out.print(matrix[i][ac] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> curR = ar;</span><br><span class="line">            <span class="keyword">int</span> curC = ac;</span><br><span class="line">            <span class="keyword">while</span> (curC &lt; bc) &#123;</span><br><span class="line">                System.out.print(matrix[curR][curC++] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curR &lt; br) &#123;</span><br><span class="line">                System.out.print(matrix[curR++][curC] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curC &gt; ac) &#123;</span><br><span class="line">                System.out.print(matrix[curR][curC--] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curR &gt; ar) &#123;</span><br><span class="line">                System.out.print(matrix[curR--][curC] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="旋转正方形矩阵"><a href="#旋转正方形矩阵" class="headerlink" title="旋转正方形矩阵"></a>旋转正方形矩阵</h2><p>给定一个整型正方形矩阵matrix，请把该矩阵调整成<br>顺时针旋转90度的样子。</p><h3 id="要求-3"><a href="#要求-3" class="headerlink" title="要求"></a>要求</h3><p>额外空间复杂度为O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jelly.algorithm.matrix;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 旋转正方形矩阵</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateMatrix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;, &#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>&#125;&#125;;</span><br><span class="line">        printMatrix(matrix);</span><br><span class="line">        rotate(matrix);</span><br><span class="line">        System.out.println(<span class="string">"======================="</span>);</span><br><span class="line">        printMatrix(matrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顺时针旋转矩阵</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ar = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ac = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> br = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> bc = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ar &lt; br) &#123;</span><br><span class="line">            rotateEdge(matrix, ar++, ac++, br--, bc--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转动矩阵边缘</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 待转动的矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ar     矩阵左上角行。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ac     矩阵左上角列。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> br     矩阵右下角行。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bc     矩阵右下角列。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotateEdge</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> ar, <span class="keyword">int</span> ac, <span class="keyword">int</span> br, <span class="keyword">int</span> bc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> times = bc - ac;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            tmp = matrix[ar][ac + i];</span><br><span class="line">            matrix[ar][ac + i] = matrix[br - i][ac];</span><br><span class="line">            matrix[br - i][ac] = matrix[br][bc - i];</span><br><span class="line">            matrix[br][bc - i] = matrix[ar + i][bc];</span><br><span class="line">            matrix[ar + i][bc] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印矩阵当前状态</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">                System.out.print(matrix[i][j] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="反转单向和双向链表"><a href="#反转单向和双向链表" class="headerlink" title="反转单向和双向链表"></a>反转单向和双向链表</h2><p>分别实现反转单向链表和反转双向链表的函数。</p><h3 id="要求-4"><a href="#要求-4" class="headerlink" title="要求"></a>要求</h3><p>如果链表长度为N， 时间复杂度要求为O(N)， 额外空间复杂度要求为O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;                 </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;                      </span><br><span class="line">    <span class="keyword">public</span> Node next;                      </span><br><span class="line">                                           </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;                </span><br><span class="line">        <span class="keyword">this</span>.value = data;                 </span><br><span class="line">    &#125;                                      </span><br><span class="line">&#125;                                          </span><br><span class="line">                                           </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Node pre = <span class="keyword">null</span>;                       </span><br><span class="line">    Node next = <span class="keyword">null</span>;                      </span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;                 </span><br><span class="line">        next = head.next;                  </span><br><span class="line">        head.next = pre;                   </span><br><span class="line">        pre = head;                        </span><br><span class="line">        head = next;                       </span><br><span class="line">    &#125;                                      </span><br><span class="line">    <span class="keyword">return</span> pre;                            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="“之”-字形打印矩阵"><a href="#“之”-字形打印矩阵" class="headerlink" title="“之” 字形打印矩阵"></a>“之” 字形打印矩阵</h2><p>给定一个矩阵matrix， 按照“之” 字形的方式打印这<br>个矩阵， </p><p>例如： 1 2 3 4 5 6 7 8 9 10 11 12</p><p>“之” 字形打印的结果为： 1， 2， 5， 9， 6， 3， 4， 7， 10， 11，8， 12</p><h3 id="要求-5"><a href="#要求-5" class="headerlink" title="要求"></a>要求</h3><p>额外空间复杂度为O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jelly.algorithm.matrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintMatrixZig</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrixZigZag</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ar = <span class="number">0</span>, ac = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> br = <span class="number">0</span>, bc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> endR = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> endC = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> fromUp = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (br &lt;= endR) &#123;</span><br><span class="line">            printSlash(matrix, ar, ac, br, bc, fromUp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面四个顺序很重要，修改判断条件的操作放在后边</span></span><br><span class="line">            ac = ar == endR ? ac + <span class="number">1</span> : ac;</span><br><span class="line">            ar = ar == endR ? ar : ar + <span class="number">1</span>;</span><br><span class="line">            br = bc == endC ? br + <span class="number">1</span> : br;</span><br><span class="line">            bc = bc == endC ? bc : bc + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            fromUp = !fromUp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印斜线</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 二维数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ar     a点横坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ac     a点纵坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> br     b点横坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bc     b点纵坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> f      是否为从上到下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSlash</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> ar, <span class="keyword">int</span> ac, <span class="keyword">int</span> br, <span class="keyword">int</span> bc, <span class="keyword">boolean</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (f) &#123;</span><br><span class="line">            <span class="keyword">while</span> (ar &gt;= br) &#123;</span><br><span class="line">                System.out.print(matrix[br++][bc--] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (ar &gt;= br) &#123;</span><br><span class="line">                System.out.print(matrix[ar--][ac++] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;, &#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>&#125;&#125;;</span><br><span class="line">        printMatrixZigZag(matrix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="在行列都排好序的矩阵中找数"><a href="#在行列都排好序的矩阵中找数" class="headerlink" title="在行列都排好序的矩阵中找数"></a>在行列都排好序的矩阵中找数</h2><p>给定一个有N*M的整型矩阵matrix和一个整数K，<br>matrix的每一行和每一 列都是排好序的。 实现一个函数， 判断K<br>是否在matrix中。 </p><p>例如： 0 1 2 5 2 3 4 7 4<br>4 4 8 5 7 7 9 如果K为7， 返回true； 如果K为6， 返回false。</p><h3 id="要求-6"><a href="#要求-6" class="headerlink" title="要求"></a>要求</h3><p>时间复杂度为O(N+M)， 额外空间复杂度为O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jelly.algorithm.matrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindNumInSortedMatrix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,<span class="comment">// 0</span></span><br><span class="line">                &#123;<span class="number">10</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>&#125;,<span class="comment">// 1</span></span><br><span class="line">                &#123;<span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>&#125;,<span class="comment">// 2</span></span><br><span class="line">                &#123;<span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>&#125;,<span class="comment">// 3</span></span><br><span class="line">                &#123;<span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">71</span>&#125;,<span class="comment">// 4</span></span><br><span class="line">                &#123;<span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">111</span>, <span class="number">122</span>&#125;,<span class="comment">// 5</span></span><br><span class="line">                &#123;<span class="number">166</span>, <span class="number">176</span>, <span class="number">186</span>, <span class="number">187</span>, <span class="number">190</span>, <span class="number">195</span>, <span class="number">200</span>&#125;,<span class="comment">// 6</span></span><br><span class="line">                &#123;<span class="number">233</span>, <span class="number">243</span>, <span class="number">321</span>, <span class="number">341</span>, <span class="number">356</span>, <span class="number">370</span>, <span class="number">380</span>&#125; <span class="comment">// 7</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> K = <span class="number">233</span>;</span><br><span class="line">        System.out.println(isContains(matrix, K));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找思路，从右上角进行查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k      查找的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isContains</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> c = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 行要小于矩阵的行数。列要大于-1.</span></span><br><span class="line">        <span class="keyword">while</span> (r &lt; matrix.length &amp;&amp; c &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[r][c] == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[r][c] &gt; k) &#123;</span><br><span class="line">                c--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="打印两个有序链表的公共节点"><a href="#打印两个有序链表的公共节点" class="headerlink" title="打印两个有序链表的公共节点"></a>打印两个有序链表的公共节点</h2><p>给定两个有序链表的头指针head1和head2， 打印两<br>链表的公共节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jelly.algorithm.list.s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.jelly.algorithm.list.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印两个有序链表的公共节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintCommonPart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCommonPart</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head1.val &lt; head2.val) &#123;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head1.val &gt; head2.val) &#123;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(head1.val + <span class="string">" "</span>);</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"node: "</span>);</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode node1 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        node1.next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        node1.next.next = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        node1.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        ListNode node2 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        node2.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        node2.next.next = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        node2.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">7</span>);</span><br><span class="line">        node2.next.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        printLinkedList(node1);</span><br><span class="line">        printLinkedList(node2);</span><br><span class="line">        printCommonPart(node1, node2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="判断一个链表是否为回文结构"><a href="#判断一个链表是否为回文结构" class="headerlink" title="判断一个链表是否为回文结构"></a>判断一个链表是否为回文结构</h2><p>给定一个链表的头节点head，请判断该链表是否为回文结构。 </p><p>例如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1-&gt;2-&gt;1， 返回true。 </span><br><span class="line">1-&gt;2-&gt;2-&gt;1，返回true。</span><br><span class="line">15-&gt;6-&gt;15， 返回true。 </span><br><span class="line">1-&gt;2-&gt;3， 返回false。</span><br></pre></td></tr></table></figure><p>进阶： 如果链表长度为N， 时间复杂度达到O(N)， 额外空间复杂度达到O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jelly.algorithm.list.s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.jelly.algorithm.list.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: study-leetcode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 判断链表是否为回文链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-10-27 14:35</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsPalindrome</span> </span>&#123;</span><br><span class="line">    <span class="comment">// need n extra space</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val != stack.pop().val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// need n/2 extra space</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode right = head.next;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            right = right.next;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(right);</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val != stack.pop().val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// need O(1) extra space</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find mid. n1 point mid after loop</span></span><br><span class="line">        ListNode n1 = head;</span><br><span class="line">        ListNode n2 = head;</span><br><span class="line">        <span class="keyword">while</span> (n2.next != <span class="keyword">null</span> &amp;&amp; n2.next.next != <span class="keyword">null</span>) &#123; <span class="comment">// find mid ListNode</span></span><br><span class="line">            n1 = n1.next;</span><br><span class="line">            n2 = n2.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        n2 = n1.next; <span class="comment">// n2 -&gt; right part first ListNode</span></span><br><span class="line">        n1.next = <span class="keyword">null</span>; <span class="comment">// mid.next -&gt; null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// reverse second half</span></span><br><span class="line">        ListNode n3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (n2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            n3 = n2.next;</span><br><span class="line">            n2.next = n1;</span><br><span class="line">            n1 = n2;</span><br><span class="line">            n2 = n3;</span><br><span class="line">        &#125;</span><br><span class="line">        n3 = n1; <span class="comment">// n3 -&gt; save last ListNode</span></span><br><span class="line">        n2 = head;<span class="comment">// n2 -&gt; left first ListNode</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// check palindrome</span></span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (n1 != <span class="keyword">null</span> &amp;&amp; n2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n1.val != n2.val) &#123;</span><br><span class="line">                res = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n1 = n1.next; <span class="comment">// left to mid</span></span><br><span class="line">            n2 = n2.next; <span class="comment">// right to mid</span></span><br><span class="line">        &#125;</span><br><span class="line">        n1 = n3.next;</span><br><span class="line">        n3.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// recover list</span></span><br><span class="line">        <span class="keyword">while</span> (n1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            n2 = n1.next;</span><br><span class="line">            n1.next = n3;</span><br><span class="line">            n3 = n1;</span><br><span class="line">            n1 = n2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode node2 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        ListNode node3 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        ListNode node4 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        ListNode node5 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        ListNode node6 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        ListNode node7 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        head.next = node2;</span><br><span class="line">        node2.next = node3;</span><br><span class="line">        node3.next = node4;</span><br><span class="line">        node4.next = node5;</span><br><span class="line">        node5.next = node6;</span><br><span class="line">        node6.next = node7;</span><br><span class="line">        System.out.println(isPalindrome(head));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="将单向链表按某值划分成左边小、-中间相等、-右边大的形式"><a href="#将单向链表按某值划分成左边小、-中间相等、-右边大的形式" class="headerlink" title="将单向链表按某值划分成左边小、 中间相等、 右边大的形式"></a>将单向链表按某值划分成左边小、 中间相等、 右边大的形式</h2><p>给定一个单向链表的头节点head，节点的值类型是整型，再给定一个整 数pivot。 </p><p>实现一个调整链表的函数，将链表调整为左部分都是值小于 pivot的节点，中间部分都是值等于pivot的节点， 右部分都是值大于 pivot的节点。<br>除这个要求外，对调整后的节点顺序没有更多的要求。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如： </span><br><span class="line">链表 9-&gt;0-&gt;4-&gt;5-&gt;1， pivot=3。 </span><br><span class="line"></span><br><span class="line">调整后链表可以是 1-&gt;0-&gt;4-&gt;9-&gt;5，</span><br><span class="line">也可以是0-&gt;1-&gt;9-&gt;5-&gt;4。</span><br></pre></td></tr></table></figure><p>总之， 满 足左部分都是小于3的节点， 中间部分都是等于3的节点（本例中这个部<br>分为空） ， 右部分都是大于3的节点即可。 对某部分内部的节点顺序不做要求。</p><p>进阶： 在原问题的要求之上再增加如下两个要求。<br>在左、 中、 右三个部分的内部也做顺序要求， 要求每部分里的节点从左 到右的<br>顺序与原链表中节点的先后次序一致。 例如： 链表9-&gt;0-&gt;4-&gt;5-&gt;1， pivot=3。<br>调整后的链表是0-&gt;1-&gt;9-&gt;4-&gt;5。 在满足原问题要求的同时， 左部分节点从左到<br>右为0、 1。 在原链表中也 是先出现0， 后出现1； 中间部分在本例中为空， 不再<br>讨论； 右部分节点 从左到右为9、 4、 5。 在原链表中也是先出现9， 然后出现4，<br>最后出现5。<br>如果链表长度为N， 时间复杂度请达到O(N)， 额外空间复杂度请达到O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">listPartition2</span><span class="params">(ListNode head, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    ListNode sH = <span class="keyword">null</span>; <span class="comment">// small head                            </span></span><br><span class="line">    ListNode sT = <span class="keyword">null</span>; <span class="comment">// small tail                            </span></span><br><span class="line">    ListNode eH = <span class="keyword">null</span>; <span class="comment">// equal head                            </span></span><br><span class="line">    ListNode eT = <span class="keyword">null</span>; <span class="comment">// equal tail                            </span></span><br><span class="line">    ListNode bH = <span class="keyword">null</span>; <span class="comment">// big head                              </span></span><br><span class="line">    ListNode bT = <span class="keyword">null</span>; <span class="comment">// big tail                              </span></span><br><span class="line">    ListNode next; <span class="comment">// save next node                             </span></span><br><span class="line">                                                                 </span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;                                       </span><br><span class="line">        next = head.next;                                        </span><br><span class="line">        <span class="comment">//释放                                                     </span></span><br><span class="line">        head.next = <span class="keyword">null</span>;                                        </span><br><span class="line">        <span class="keyword">if</span> (head.val &lt; pivot) &#123;                                  </span><br><span class="line">            <span class="keyword">if</span> (sH == <span class="keyword">null</span>) &#123;                                    </span><br><span class="line">                sH = head;                                       </span><br><span class="line">                sT = head;                                       </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                                             </span><br><span class="line">                sT.next = head;                                  </span><br><span class="line">                sT = head;                                       </span><br><span class="line">            &#125;                                                    </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.val &gt; pivot) &#123;                           </span><br><span class="line">            <span class="keyword">if</span> (eH == <span class="keyword">null</span>) &#123;                                    </span><br><span class="line">                eH = head;                                       </span><br><span class="line">                eT = head;                                       </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                                             </span><br><span class="line">                eT.next = head;                                  </span><br><span class="line">                eT = head;                                       </span><br><span class="line">            &#125;                                                    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                                 </span><br><span class="line">            <span class="keyword">if</span> (bH == <span class="keyword">null</span>) &#123;                                    </span><br><span class="line">                bH = head;                                       </span><br><span class="line">                bT = head;                                       </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                                             </span><br><span class="line">                bT.next = head;                                  </span><br><span class="line">                bT = head;                                       </span><br><span class="line">            &#125;                                                    </span><br><span class="line">        &#125;                                                        </span><br><span class="line">        head = next;                                             </span><br><span class="line">    &#125;                                                            </span><br><span class="line">    <span class="comment">// small and equal reconnect                                 </span></span><br><span class="line">    <span class="keyword">if</span> (sT != <span class="keyword">null</span>) &#123;                                            </span><br><span class="line">        sT.next = eH;                                            </span><br><span class="line">        eT = eT == <span class="keyword">null</span> ? sT : eT;                               </span><br><span class="line">    &#125;                                                            </span><br><span class="line">    <span class="comment">// all reconnect                                             </span></span><br><span class="line">    <span class="keyword">if</span> (eT != <span class="keyword">null</span>) &#123;                                            </span><br><span class="line">        eT.next = bH;                                            </span><br><span class="line">    &#125;                                                            </span><br><span class="line">    <span class="keyword">return</span> sH != <span class="keyword">null</span> ? sH : eH != <span class="keyword">null</span> ? eH : bH;               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="复制含有随机指针节点的链表"><a href="#复制含有随机指针节点的链表" class="headerlink" title="复制含有随机指针节点的链表"></a>复制含有随机指针节点的链表</h2><p>一种特殊的链表节点类描述如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value; </span><br><span class="line">    <span class="keyword">public</span> Node next; </span><br><span class="line">    <span class="keyword">public</span> Node rand;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.value = data; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node类中的value是节点值,next指针和正常单链表中next指针的意义一样，都指向下一个节点，rand指针是Node类中新增的指针,这个指针可能指向链表中的任意一个节点， 也可能指向null。</p><p>给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表中所有结构的复制， 并返回复制的新链表的头节点。 </p><p>进阶：不使用额外的数据结构，只用有限几个变量， 且在时间复杂度为O(N)内完成原问题要实现的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jelly.algorithm.list.m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyListWithRandom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="keyword">public</span> Node rand;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将节点拷贝到map中，利用map获取源节点的next、rand指针。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyListWithRand1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(cur, <span class="keyword">new</span> Node(cur.value));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).rand = map.get(cur.rand);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点的下一个为其next，让后将所有的拷贝节点提取出来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 头指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyListWithRand2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="comment">// copy next</span></span><br><span class="line">        Node next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = <span class="keyword">new</span> Node(cur.value);</span><br><span class="line">            cur.next.next = next;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// copy rand</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = cur.next.next;</span><br><span class="line">            cur.next.rand = cur.rand == <span class="keyword">null</span> ? <span class="keyword">null</span> : cur.rand.next;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// split</span></span><br><span class="line">        Node res = head.next;</span><br><span class="line">        Node curCopy;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = cur.next.next;</span><br><span class="line">            curCopy = cur.next;</span><br><span class="line"></span><br><span class="line">            cur.next = next;</span><br><span class="line">            curCopy.next = next != <span class="keyword">null</span> ? next.next : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printRandLinkedList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        System.out.print(<span class="string">"order: "</span>);</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(cur.value + <span class="string">" "</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        cur = head;</span><br><span class="line">        System.out.print(<span class="string">"rand:  "</span>);</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(cur.rand == <span class="keyword">null</span> ? <span class="string">"- "</span> : cur.rand.value + <span class="string">" "</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node head = <span class="keyword">null</span>;</span><br><span class="line">        Node res1 = <span class="keyword">null</span>;</span><br><span class="line">        Node res2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        head.next.next.next = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        head.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        head.next.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        head.rand = head.next.next.next.next.next; <span class="comment">// 1 -&gt; 6</span></span><br><span class="line">        head.next.rand = head.next.next.next.next.next; <span class="comment">// 2 -&gt; 6</span></span><br><span class="line">        head.next.next.rand = head.next.next.next.next; <span class="comment">// 3 -&gt; 5</span></span><br><span class="line">        head.next.next.next.rand = head.next.next; <span class="comment">// 4 -&gt; 3</span></span><br><span class="line">        head.next.next.next.next.rand = <span class="keyword">null</span>; <span class="comment">// 5 -&gt; null</span></span><br><span class="line">        head.next.next.next.next.next.rand = head.next.next.next; <span class="comment">// 6 -&gt; 4</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"head"</span>);</span><br><span class="line">        printRandLinkedList(head);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Rand1"</span>);</span><br><span class="line">        res1 = copyListWithRand1(head);</span><br><span class="line">        printRandLinkedList(res1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Rand2"</span>);</span><br><span class="line">        res2 = copyListWithRand2(head);</span><br><span class="line">        printRandLinkedList(res2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"head"</span>);</span><br><span class="line">        printRandLinkedList(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="两个单链表相交的一系列问题"><a href="#两个单链表相交的一系列问题" class="headerlink" title="两个单链表相交的一系列问题"></a>两个单链表相交的一系列问题</h2><p>单链表可能有环，也可能无环。给定两个单链表的头节点 head1和head2，这两个链表可能相交，也可能不相交。</p><p>请实现一个函数， </p><ul><li>如果两个链表相交， 请返回相交的第一个节点；</li><li>如果不相交， 返回null 即可。 </li></ul><p>要求： 如果链表1 的长度为N， 链表2的长度为M， 时间复杂度请达到 O(N+M)， 额外空间复杂度请达到O(1)</p><h3 id="可能情况"><a href="#可能情况" class="headerlink" title="可能情况"></a>可能情况</h3><p><img src="https://s2.ax1x.com/2020/02/11/1oDNut.png" alt="1oDNut.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jelly.algorithm.list.m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.jelly.algorithm.list.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找两个链表交点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindFirstIntersectNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">getIntersectNode</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode loop1 = getLoopNode(head1);</span><br><span class="line">        ListNode loop2 = getLoopNode(head2);</span><br><span class="line">        <span class="comment">//both no loop</span></span><br><span class="line">        <span class="keyword">if</span> (loop1 == <span class="keyword">null</span> &amp;&amp; loop2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> noLoop(head1, head2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//both has loop</span></span><br><span class="line">        <span class="keyword">if</span> (loop1 != <span class="keyword">null</span> &amp;&amp; loop2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bothLoop(head1, loop1, head2, loop2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//one has loop the other has no loop. don't intersect.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the entry node of the ring</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">getLoopNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode n1 = head.next; <span class="comment">// n1 -&gt; slow</span></span><br><span class="line">        ListNode n2 = head.next.next; <span class="comment">// n2 -&gt; fast</span></span><br><span class="line">        <span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n2.next == <span class="keyword">null</span> || n2.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n2 = n2.next.next;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        n2 = head; <span class="comment">// n2 -&gt; walk again from head</span></span><br><span class="line">        <span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">            n2 = n2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * two no loop list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">noLoop</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur1 = head1;</span><br><span class="line">        ListNode cur2 = head2;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// end different</span></span><br><span class="line">        <span class="keyword">if</span> (cur1 != cur2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cur1 is longer. </span></span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * both has loop</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">bothLoop</span><span class="params">(ListNode head1, ListNode loop1, ListNode head2, ListNode loop2)</span> </span>&#123;</span><br><span class="line">        ListNode cur1 = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 入口节点相同</span></span><br><span class="line">        <span class="keyword">if</span> (loop1 == loop2) &#123;</span><br><span class="line">            cur1 = head1;</span><br><span class="line">            cur2 = head2;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">                n++;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cur2 != loop2) &#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cur1 is longer</span></span><br><span class="line">            cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">            cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">            n = Math.abs(n);</span><br><span class="line">            <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//入口节点不同</span></span><br><span class="line">            cur1 = loop1.next;</span><br><span class="line">            <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur1 == loop2) &#123;</span><br><span class="line">                    <span class="keyword">return</span> loop1;</span><br><span class="line">                &#125;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;null</span></span><br><span class="line">        ListNode head1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        head1.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        head1.next.next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        head1.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        head1.next.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        head1.next.next.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">6</span>);</span><br><span class="line">        head1.next.next.next.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0-&gt;9-&gt;8-&gt;6-&gt;7-&gt;null</span></span><br><span class="line">        ListNode head2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        head2.next = <span class="keyword">new</span> ListNode(<span class="number">9</span>);</span><br><span class="line">        head2.next.next = <span class="keyword">new</span> ListNode(<span class="number">8</span>);</span><br><span class="line">        head2.next.next.next = head1.next.next.next.next.next; <span class="comment">// 8-&gt;6</span></span><br><span class="line">        System.out.println(getIntersectNode(head1, head2).val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;4...</span></span><br><span class="line">        head1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        head1.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        head1.next.next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        head1.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        head1.next.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        head1.next.next.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">6</span>);</span><br><span class="line">        head1.next.next.next.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">7</span>);</span><br><span class="line">        head1.next.next.next.next.next.next = head1.next.next.next; <span class="comment">// 7-&gt;4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0-&gt;9-&gt;8-&gt;2...</span></span><br><span class="line">        head2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        head2.next = <span class="keyword">new</span> ListNode(<span class="number">9</span>);</span><br><span class="line">        head2.next.next = <span class="keyword">new</span> ListNode(<span class="number">8</span>);</span><br><span class="line">        head2.next.next.next = head1.next; <span class="comment">// 8-&gt;2</span></span><br><span class="line">        System.out.println(getIntersectNode(head1, head2).val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0-&gt;9-&gt;8-&gt;6-&gt;4-&gt;5-&gt;6..</span></span><br><span class="line">        head2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        head2.next = <span class="keyword">new</span> ListNode(<span class="number">9</span>);</span><br><span class="line">        head2.next.next = <span class="keyword">new</span> ListNode(<span class="number">8</span>);</span><br><span class="line">        head2.next.next.next = head1.next.next.next.next.next; <span class="comment">// 8-&gt;6</span></span><br><span class="line">        System.out.println(getIntersectNode(head1, head2).val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="在二叉树中找到一个节点的后继节点"><a href="#在二叉树中找到一个节点的后继节点" class="headerlink" title="在二叉树中找到一个节点的后继节点"></a>在二叉树中找到一个节点的后继节点</h2><p>现在有一种新的二叉树节点类型如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value; </span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right; </span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.value = data; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该结构比普通二叉树节点结构多了一个指向父节点的parent指针。</p><p>假设有一棵Node类型的节点组成的二叉树， 树中每个节点的parent指针都正确地指向 自己的父节点， 头节点的parent指向null。 只给一个在二叉树中的某个节点 node， 请实现返回node的后继节点的函数。 在二<br>叉树的中序遍历的序列中，node的下一个节点叫作node的后继节点.</p><p>中序遍历 左、根、右</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getSuccessorNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右节点不为空时，下一个节点为右节点的最左节点</span></span><br><span class="line"><span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getLeftMost(node.right);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//右节点为空，当前是左子节点，返回其父节点，否则找到祖父节点返回</span></span><br><span class="line">Node parent = node.parent;</span><br><span class="line"><span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; parent.left != node) &#123;</span><br><span class="line">node = parent;</span><br><span class="line">parent = node.parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLeftMost</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">node = node.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="判断一棵二叉树是否是平衡二叉树"><a href="#判断一棵二叉树是否是平衡二叉树" class="headerlink" title="判断一棵二叉树是否是平衡二叉树"></a>判断一棵二叉树是否是平衡二叉树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检验是否是平衡树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> process(root) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = process(root.left);</span><br><span class="line">    <span class="keyword">if</span> (left == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> right = process(root.right);</span><br><span class="line">    <span class="keyword">if</span> (right == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(left - right) &gt; <span class="number">1</span> ? -<span class="number">1</span> : Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="判断一棵树是否是搜索二叉树、"><a href="#判断一棵树是否是搜索二叉树、" class="headerlink" title="判断一棵树是否是搜索二叉树、"></a>判断一棵树是否是搜索二叉树、</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 校验是否是平衡二叉搜索树.中序遍历，递增</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    middleOrder(root, res);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; res.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.get(i - <span class="number">1</span>) &gt; res.get(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">middleOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    middleOrder(root.left, res);</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    middleOrder(root.right, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="判断一棵树是否是完全二叉树"><a href="#判断一棵树是否是完全二叉树" class="headerlink" title="判断一棵树是否是完全二叉树"></a>判断一棵树是否是完全二叉树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCBT</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line"><span class="keyword">boolean</span> leaf = <span class="keyword">false</span>;</span><br><span class="line">Node l = <span class="keyword">null</span>;</span><br><span class="line">Node r = <span class="keyword">null</span>;</span><br><span class="line">queue.offer(head);</span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">head = queue.poll();</span><br><span class="line">l = head.left;</span><br><span class="line">r = head.right;</span><br><span class="line"><span class="comment">// leaf为true后，左右节点均为空</span></span><br><span class="line"><span class="comment">// 左节点为空，右节点必须为空</span></span><br><span class="line"><span class="keyword">if</span> ((leaf &amp;&amp; (l != <span class="keyword">null</span> || r != <span class="keyword">null</span>)) || (l == <span class="keyword">null</span> &amp;&amp; r != <span class="keyword">null</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">queue.offer(l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右节点为空，leaf标记为true</span></span><br><span class="line"><span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">queue.offer(r);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">leaf = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="已知一棵完全二叉树，-求其节点的个数"><a href="#已知一棵完全二叉树，-求其节点的个数" class="headerlink" title="已知一棵完全二叉树， 求其节点的个数"></a>已知一棵完全二叉树， 求其节点的个数</h2><p>要求： 时间复杂度低于O(N)， N为这棵树的节点个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nodeNum</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bs(head, <span class="number">1</span>, mostLeftLevel(head, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bs</span><span class="params">(Node node, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// leval 和 height相同时，返回1</span></span><br><span class="line"><span class="keyword">if</span> (l == h) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右子树高度和完全二叉树高度相等，说明，左树为满树</span></span><br><span class="line"><span class="comment">// 2^(h-l) 个 + 右子树节点个数</span></span><br><span class="line"><span class="keyword">if</span> (mostLeftLevel(node.right, l + <span class="number">1</span>) == h) &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; (h - l)) + bs(node.right, l + <span class="number">1</span>, h);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 右树层数小1，+ 加上左子树节点个数 </span></span><br><span class="line"><span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; (h - l - <span class="number">1</span>)) + bs(node.left, l + <span class="number">1</span>, h);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mostLeftLevel</span><span class="params">(Node node, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">level++;</span><br><span class="line">node = node.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> level - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="折纸问题"><a href="#折纸问题" class="headerlink" title="折纸问题"></a>折纸问题</h2><p>请把一段纸条竖着放在桌子上， 然后从纸条的下边向<br>上方对折1次， 压出折痕后展开。 此时 折痕是凹下去的， 即折痕<br>突起的方向指向纸条的背面。 如果从纸条的下边向上方连续对折<br>2 次， 压出折痕后展开， 此时有三条折痕， 从上到下依次是下折<br>痕、 下折痕和上折痕。<br>给定一 个输入参数N， 代表纸条都从下边向上方连续对折N次，<br>请从上到下打印所有折痕的方向。 例如： N=1时， 打印： down<br>N=2时， 打印： down down up</p><p>类似二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">右、中、左的遍历顺序。</span><br><span class="line">            下</span><br><span class="line">        上      下</span><br><span class="line">      上  下  上  下</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllFolds</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">printProcess(<span class="number">1</span>, N, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> N, <span class="keyword">boolean</span> down)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; N) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">printProcess(i + <span class="number">1</span>, N, <span class="keyword">true</span>);</span><br><span class="line">System.out.println(down ? <span class="string">"down "</span> : <span class="string">"up "</span>);</span><br><span class="line">printProcess(i + <span class="number">1</span>, N, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><ul><li>bit数组大小：m= - n * ln(p) / (ln2)^2</li><li>n: 样本量</li><li>p: 0.0001 预期失误率</li><li>哈希函数个数：k = ln2 * m / n = 0.7 * m/n</li><li>真实失误率：（1-e^(-n*k/m) )^k</li></ul><h2 id="URL筛选"><a href="#URL筛选" class="headerlink" title="URL筛选"></a>URL筛选</h2><p>不安全网页的黑名单包含100亿个黑名单网页，每个网页的URL最多占用64B，现在要实现一个网页过滤系统，根据网页的URL判断该网页是否在黑名单上。</p><h3 id="要求-7"><a href="#要求-7" class="headerlink" title="要求"></a>要求</h3><ol><li>允许一定的判断失误率</li><li>空间内存限制在30GB以内</li></ol><p>如果是直接用哈希函数处理，肯定会长处空间限制，所以这里要用到的是布隆过滤器。</p><p>布隆过滤器实际上是一个位图bitMap，我们现在假设有一个<strong>长度为m的bit类型的数组</strong>，以及 <strong>k 个互相独立的优秀的哈希函数</strong>，且这<strong>k个哈希函数的输出域都大于或等于m</strong>。</p><p>我们将网页的URL作为k个哈希函数的输入对象进行哈希处理，分别得到 k 个值，<strong>这k个值中可能有相同的，但是值之间互相独立不关联的</strong>。我们将这k个值<strong>对m模运算</strong>，得到的 k 个值都在 0~m之间。最后将这 k 个值对应的bitMap的值<strong>置为1</strong>，当我们将所有的URL都处理完毕后，bitMap上的很多位都被置为了1。</p><p>当我们要查询一个URL是否在黑名单内时，我们<strong>先将这个URL进行哈希处理</strong> ，因为有K个函数所以得到 k 个值。接着<strong>检查这 k 个值对应的bitMap 位是否为1，如果有一个不为 1，那么说明这个URL不在这个这里面，是安全的网站</strong>，如果对应的 bitMap 位的值都是 1 那么说明这个URL可能在这里面。说明可能是因为当URL的数量很多时，可能会出现不同URL哈希处理后得到相同的值，所以说是<strong>有可能在这里面</strong>。</p><hr><h1 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h1><p>所有机器经过hash后，按照顺序排序。分担所有hash的数据。</p><p>新机器加入：新机器按照其hash分布到所有的hash环上，该点到下一点的数据拷贝到新机器上即可。</p><p>旧机器删除：删除该机器，该点管控数据，拷贝给他相邻节点。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>机器必须达到一定数量，否则数据可能分布严重不均。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>每个物理机增加一定数量的虚拟节点，均分整个hash环，根据虚拟节点的数量将数据划分给特定的宿主机存储。</p><hr><h1 id="岛问题"><a href="#岛问题" class="headerlink" title="岛问题"></a>岛问题</h1><p>一个矩阵中只有0和1两种值，每个位置都可以和自己的上、下、左、右 四个位置相连，如果有一片1连在一起，这个部分叫做一个岛，求一个 矩阵中有多少个岛？<br>举例：<br>0 0 1 0 1 0 1 1 1 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0<br>这个矩阵中有三个岛</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countIslands</span><span class="params">(<span class="keyword">int</span>[][] m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="keyword">null</span> || m[<span class="number">0</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N = m.length;</span><br><span class="line"><span class="keyword">int</span> M = m[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (m[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">res++;</span><br><span class="line">infect(m, i, j, N, M);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">infect</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> N, <span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= N || j &lt; <span class="number">0</span> || j &gt;= M || m[i][j] != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">m[i][j] = <span class="number">2</span>;</span><br><span class="line">infect(m, i + <span class="number">1</span>, j, N, M);</span><br><span class="line">infect(m, i - <span class="number">1</span>, j, N, M);</span><br><span class="line">infect(m, i, j + <span class="number">1</span>, N, M);</span><br><span class="line">infect(m, i, j - <span class="number">1</span>, N, M);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[][] m1 = &#123;  &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, </span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;, </span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, </span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, </span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, &#125;;</span><br><span class="line">System.out.println(countIslands(m1));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] m2 = &#123;  &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, </span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;, </span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;, </span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, </span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, &#125;;</span><br><span class="line">System.out.println(countIslands(m2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>一种结构，主要提供两种功能</p><ul><li>两个集合是否属于一个集合</li><li>合并两个集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</span><br><span class="line"><span class="comment">// k：当前节点，v：父节点</span></span><br><span class="line"><span class="keyword">public</span> HashMap&lt;Node, Node&gt; fatherMap;</span><br><span class="line"><span class="comment">// k：当前节点，v：当前节点所代表的集合中有多少其他节点</span></span><br><span class="line"><span class="keyword">public</span> HashMap&lt;Node, Integer&gt; sizeMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，必须一次给定所有的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span><span class="params">(List&lt;Node&gt; nodes)</span> </span>&#123;</span><br><span class="line">makeSets(nodes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有节点，初始化时所有节点指向自己，size为 1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeSets</span><span class="params">(List&lt;Node&gt; nodes)</span> </span>&#123;</span><br><span class="line">fatherMap = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line">sizeMap = <span class="keyword">new</span> HashMap&lt;Node, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">fatherMap.put(node, node);</span><br><span class="line">sizeMap.put(node, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归找到node的父节点</span></span><br><span class="line">    <span class="comment">// 然后并将查找路径上的节点，挂在代表节点下</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">findHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">Node father = fatherMap.get(node);</span><br><span class="line"><span class="keyword">if</span> (father != node) &#123;</span><br><span class="line">father = findHead(father);</span><br><span class="line">&#125;</span><br><span class="line">fatherMap.put(node, father);</span><br><span class="line"><span class="keyword">return</span> father;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外提供的方法，两个节点是否属于同一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> findHead(a) == findHead(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个集合，参数为两个集合的代表节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Node aHead = findHead(a);</span><br><span class="line">Node bHead = findHead(b);</span><br><span class="line"><span class="keyword">if</span> (aHead != bHead) &#123;</span><br><span class="line"><span class="keyword">int</span> aSetSize= sizeMap.get(aHead);</span><br><span class="line"><span class="keyword">int</span> bSetSize = sizeMap.get(bHead);</span><br><span class="line"><span class="keyword">if</span> (aSetSize &lt;= bSetSize) &#123;</span><br><span class="line">fatherMap.put(aHead, bHead);</span><br><span class="line">sizeMap.put(bHead, aSetSize + bSetSize);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fatherMap.put(bHead, aHead);</span><br><span class="line">sizeMap.put(aHead, aSetSize + bSetSize);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h1><p>arr2中有哪些字符，是arr1中出现的？请打印</p><p>arr2中有哪些字符，是作为arr1中某个字符串前缀出现的？请 打印</p><p>arr2中有哪些字符，是作为arr1中某个字符串前缀出现的？请打印 arr2中出现次数最大的前缀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> path;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line"><span class="keyword">public</span> TrieNode[] nexts;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">path = <span class="number">0</span>;</span><br><span class="line">end = <span class="number">0</span>;</span><br><span class="line">nexts = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> TrieNode root;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (word == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">TrieNode node = root;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">index = chs[i] - <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span> (node.nexts[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">node.nexts[index] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">&#125;</span><br><span class="line">node = node.nexts[index];</span><br><span class="line">node.path++;</span><br><span class="line">&#125;</span><br><span class="line">node.end++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (search(word) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">TrieNode node = root;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">index = chs[i] - <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span> (--node.nexts[index].path == <span class="number">0</span>) &#123;</span><br><span class="line">node.nexts[index] = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">node = node.nexts[index];</span><br><span class="line">&#125;</span><br><span class="line">node.end--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (word == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">TrieNode node = root;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">index = chs[i] - <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span> (node.nexts[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">node = node.nexts[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node.end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixNumber</span><span class="params">(String pre)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pre == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] chs = pre.toCharArray();</span><br><span class="line">TrieNode node = root;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">index = chs[i] - <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span> (node.nexts[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">node = node.nexts[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node.path;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line">System.out.println(trie.search(<span class="string">"zuo"</span>));</span><br><span class="line">trie.insert(<span class="string">"zuo"</span>);</span><br><span class="line">System.out.println(trie.search(<span class="string">"zuo"</span>));</span><br><span class="line">trie.delete(<span class="string">"zuo"</span>);</span><br><span class="line">System.out.println(trie.search(<span class="string">"zuo"</span>));</span><br><span class="line">trie.insert(<span class="string">"zuo"</span>);</span><br><span class="line">trie.insert(<span class="string">"zuo"</span>);</span><br><span class="line">trie.delete(<span class="string">"zuo"</span>);</span><br><span class="line">System.out.println(trie.search(<span class="string">"zuo"</span>));</span><br><span class="line">trie.delete(<span class="string">"zuo"</span>);</span><br><span class="line">System.out.println(trie.search(<span class="string">"zuo"</span>));</span><br><span class="line">trie.insert(<span class="string">"zuoa"</span>);</span><br><span class="line">trie.insert(<span class="string">"zuoac"</span>);</span><br><span class="line">trie.insert(<span class="string">"zuoab"</span>);</span><br><span class="line">trie.insert(<span class="string">"zuoad"</span>);</span><br><span class="line">trie.delete(<span class="string">"zuoa"</span>);</span><br><span class="line">System.out.println(trie.search(<span class="string">"zuoa"</span>));</span><br><span class="line">System.out.println(trie.prefixNumber(<span class="string">"zuo"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="切金条"><a href="#切金条" class="headerlink" title="切金条"></a>切金条</h2><p>一块金条切成两半，是需要花费和长度数值一样的铜板的。比如 长度为20的 金条，不管切成长度多大的两半，都要花费20个铜 板。一群人想整分整块金 条，怎么分最省铜板？ 例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为 10+20+30=60. 金条要分成10,20,30三个部分。 如果， 先把长 度60的金条分成10和50，花费60 再把长度50的金条分成20和30， 花费50 一共花费110铜板。 但是如果， 先把长度60的金条分成30和30，花费60 再把长度30 金条分成10和20，花费30 一共花费90铜板。 输入一个数组，返回分割的最小代价。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lessMoney</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">PriorityQueue&lt;Integer&gt; pQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">pQ.add(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (pQ.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">cur = pQ.poll() + pQ.poll();</span><br><span class="line">sum += cur;</span><br><span class="line">pQ.add(cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="做项目-IPO"><a href="#做项目-IPO" class="headerlink" title="做项目(IPO)"></a>做项目(IPO)</h2><p>输入： </p><ul><li>参数1，正数数组costs </li><li>参数2，正数数组profits </li><li>参数3， 正数k </li><li>参数4，正数m </li></ul><p>costs[i]表示i号项目的花费 profits[i]表示i号项目在扣除花 费之后还能挣到的钱(利润) k表示你不能并行、只能串行的最多 做k个项目 m表示你初始的资金 说明：你每做完一个项目，马上获得的收益，可以支持你去做下 一个 项目。 输出： 你最后获得的最大钱数。</p><p>构建两个堆：</p><p>按照花费构建小根堆，当花费小于当前所有资金时，进入按照收益构建的大根堆，每次大根堆中给的第一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> p;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.p = p;</span><br><span class="line"><span class="keyword">this</span>.c = c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MinCostComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o1.c - o2.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxProfitComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o2.p - o1.p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMaximizedCapital</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> W, <span class="keyword">int</span>[] Profits, <span class="keyword">int</span>[] Capital)</span> </span>&#123;</span><br><span class="line">Node[] nodes = <span class="keyword">new</span> Node[Profits.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Profits.length; i++) &#123;</span><br><span class="line">nodes[i] = <span class="keyword">new</span> Node(Profits[i], Capital[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityQueue&lt;Node&gt; minCostQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> MinCostComparator());</span><br><span class="line">PriorityQueue&lt;Node&gt; maxProfitQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> MaxProfitComparator());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">minCostQ.add(nodes[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (!minCostQ.isEmpty() &amp;&amp; minCostQ.peek().c &lt;= W) &#123;</span><br><span class="line">maxProfitQ.add(minCostQ.poll());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (maxProfitQ.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> W;</span><br><span class="line">&#125;</span><br><span class="line">W += maxProfitQ.poll().p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> W;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个数据流中，随时可以取得中位数"><a href="#一个数据流中，随时可以取得中位数" class="headerlink" title="一个数据流中，随时可以取得中位数"></a>一个数据流中，随时可以取得中位数</h2><h2 id="最低字典序"><a href="#最低字典序" class="headerlink" title="最低字典序"></a>最低字典序</h2><p>给定一个字符串类型的数组strs，找到一种拼接方式，使得把所有字符串拼起来之后形成的字符串具有最低的字典序。</p><p>注意：</p><p>不能直接按照字典序比较，如 ba、b 直接按照字典序比较 ba &gt; b 拼接字符串 bba，但是bab更小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接按照字典序比较是错误的</span></span><br><span class="line"><span class="keyword">return</span> (a + b).compareTo(b + a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">lowestString</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(strs, <span class="keyword">new</span> MyComparator());</span><br><span class="line">String res = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">res += strs[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String[] strs1 = &#123; <span class="string">"jibw"</span>, <span class="string">"ji"</span>, <span class="string">"jp"</span>, <span class="string">"bw"</span>, <span class="string">"jibw"</span> &#125;;</span><br><span class="line">System.out.println(lowestString(strs1));</span><br><span class="line"></span><br><span class="line">String[] strs2 = &#123; <span class="string">"ba"</span>, <span class="string">"b"</span> &#125;;</span><br><span class="line">System.out.println(lowestString(strs2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="宣讲会"><a href="#宣讲会" class="headerlink" title="宣讲会"></a>宣讲会</h2><p>一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目 的宣讲。 给你每一个项目开始的时间和结束的时间(给你一个数 组，里面 是一个个具体的项目)，你来安排宣讲的日程，要求会 议室进行 的宣讲的场次最多。返回这个最多的宣讲场次。</p><p>按照结束时间排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> start;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Program</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.start = start;</span><br><span class="line"><span class="keyword">this</span>.end = end;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgramComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Program</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Program o1, Program o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o1.end - o2.end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bestArrange</span><span class="params">(Program[] programs, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">Arrays.sort(programs, <span class="keyword">new</span> ProgramComparator());</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; programs.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (start &lt;= programs[i].start) &#123;</span><br><span class="line">result++;</span><br><span class="line">start = programs[i].end;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>–</p><h1 id="递归-amp-动态规划"><a href="#递归-amp-动态规划" class="headerlink" title="递归&amp;动态规划"></a>递归&amp;动态规划</h1><p>暴力递归： </p><ol><li>把问题转化为规模缩小了的同类问题的子问题</li><li>有明确的不需要继续进行递归的条件(base case)</li><li>有当得到了子问题的结果之后的决策过程</li><li>不记录每一个 子问题的解</li></ol><p>动态规划 </p><ol><li>从暴力递归中来</li><li>将每一个子问题的解记录下来，避免重复计算</li><li>把暴力递归的过程，抽象成了状态表达</li><li>并且存在化简状态表达，使其更加简洁的可能</li></ol><h2 id="求n-的结果"><a href="#求n-的结果" class="headerlink" title="求n!的结果"></a>求n!的结果</h2><p>n的阶乘依赖于 n-1 的阶乘， n-1 的阶乘依赖于 n-2 的阶乘……依赖 1 的阶乘。</p><p>于是，反过来，可以从 1 的阶乘计算到 n的阶乘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getFactorial1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">long</span>) n * getFactorial1(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getFactorial2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> result = <span class="number">1L</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">result *= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    System.out.println(getFactorial1(n));</span><br><span class="line">System.out.println(getFactorial2(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><p>三个柱子。from、to、help </p><p>抽象问题：</p><ol><li>将from 上的 n 个盘子中的 n-1 个移动到 help上</li><li>将from 剩余的第 n 个盘子移动到to上</li><li>将help 上的n-1 个盘子移动到to上</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">func(n, n, <span class="string">"left"</span>, <span class="string">"mid"</span>, <span class="string">"right"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> rest, <span class="keyword">int</span> down, String from, String help, String to)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rest == <span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"move "</span> + down + <span class="string">" from "</span> + from + <span class="string">" to "</span> + to);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">func(rest - <span class="number">1</span>, down - <span class="number">1</span>, from, to, help);</span><br><span class="line">func(<span class="number">1</span>, down, from, help, to);</span><br><span class="line">func(rest - <span class="number">1</span>, down - <span class="number">1</span>, help, from, to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印全部子序列"><a href="#打印全部子序列" class="headerlink" title="打印全部子序列"></a>打印全部子序列</h2><p>打印一个字符串的全部子序列，包括空字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllSubsquence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(str == <span class="keyword">null</span>|| <span class="string">""</span>.equal(str))&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">process(str.toCharArray(), <span class="number">0</span> ,<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> i, String res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == str.length)&#123;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 决策：不加当前字符</span></span><br><span class="line">    process(str, i+<span class="number">1</span>, res);</span><br><span class="line">    <span class="comment">// 决策：加当前字符</span></span><br><span class="line">    process(str, i+<span class="number">1</span>, res+String.valueOf(str[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印全排列"><a href="#打印全排列" class="headerlink" title="打印全排列"></a>打印全排列</h2><p>打印一个字符串的全部排列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jelly.algorithm.string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串的全排列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllPermutations</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllPermutations</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || <span class="string">""</span>.equals(str)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        process(str.toCharArray(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] chs, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == chs.length) &#123;</span><br><span class="line">            System.out.println(String.valueOf(chs));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; chs.length; j++) &#123;</span><br><span class="line">            process(deepCopyAndSwap(chs, i, j), i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[] deepCopyAndSwap(<span class="keyword">char</span>[] chs, <span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] res = Arrays.copyOf(chs, chs.length);</span><br><span class="line">        <span class="keyword">char</span> tmp = res[i];</span><br><span class="line">        res[i] = res[j];</span><br><span class="line">        res[j] = tmp;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printAllPermutations(<span class="string">"abc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生牛问题"><a href="#生牛问题" class="headerlink" title="生牛问题"></a>生牛问题</h2><p>母牛每年生一只母牛，新出生的母牛成长三年后也能每年生一只母牛，假设不会死。求N年后，母牛的数量。</p><p>因为题中牛不会死，三年后可以生母牛。那么可以得到递推公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-3)</span><br><span class="line">今年牛数量  = 去年牛数量 + 三年前牛数量(它们将会生小牛)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cowNumber1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span> || n == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cowNumber1(n - <span class="number">1</span>) + cowNumber1(n - <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cowNumber2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span> || n == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> prepre = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> tmp1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tmp2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">tmp1 = res;</span><br><span class="line">tmp2 = pre;</span><br><span class="line"></span><br><span class="line">res = res + prepre;</span><br><span class="line"></span><br><span class="line">pre = tmp1;</span><br><span class="line">prepre = tmp2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">20</span>;</span><br><span class="line">System.out.println(cowNumber1(n));</span><br><span class="line">System.out.println(cowNumber2(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生牛问题-母牛只能活10年"><a href="#生牛问题-母牛只能活10年" class="headerlink" title="生牛问题(母牛只能活10年)"></a>生牛问题(母牛只能活10年)</h2><p>如果每只母牛只能活10年（先生后死），求N年后，母牛的数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-3) - (f(n-10) - f(n-11))</span><br><span class="line">今年牛数量  = 去年牛数量 + 三年前牛数量(它们将会生小牛) - 十年前出生的小牛(如果是第十年没生小牛就死亡，应减2倍 十年前出生小牛的量)</span><br></pre></td></tr></table></figure><h2 id="递归逆序栈"><a href="#递归逆序栈" class="headerlink" title="递归逆序栈"></a>递归逆序栈</h2><p>给你一个栈，请你逆序这个栈，不能申请额外的数据结构，只能 使用递归函数。如何实现？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jelly.algorithm.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归查找栈底元素弹出，然后入栈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseStackUsingRecursive</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(Stack&lt;Integer&gt; stack)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack == <span class="keyword">null</span> || stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> last = getAndRemoveLast(stack);</span><br><span class="line">        reverse(stack);</span><br><span class="line">        stack.push(last);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAndRemoveLast</span><span class="params">(Stack&lt;Integer&gt; stack)</span> </span>&#123;</span><br><span class="line">        Integer pop = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> pop;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 弹出的pop不是栈底元素，递归查找，并将pop重新入栈</span></span><br><span class="line">            <span class="keyword">int</span> last = getAndRemoveLast(stack);</span><br><span class="line">            stack.push(pop);</span><br><span class="line">            <span class="keyword">return</span> last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = initStack();</span><br><span class="line">        reverse(stack);</span><br><span class="line">        printStack(stack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 初始化栈</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Stack&lt;Integer&gt; <span class="title">initStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> stack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 打印栈</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printStack</span><span class="params">(Stack&lt;Integer&gt; stack)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            System.out.print(stack.pop() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小路径"><a href="#最小路径" class="headerlink" title="最小路径"></a>最小路径</h2><h3 id="无后效性问题都可以改成动态规划"><a href="#无后效性问题都可以改成动态规划" class="headerlink" title="无后效性问题都可以改成动态规划"></a>无后效性问题都可以改成动态规划</h3><blockquote><p>无后效性，当前选择对后边选择决策无关。当前可变参数确定，最后返回值是确定的。</p></blockquote><p>给你一个二维数组，二维数组中的每个数都是正数，要求从左上角走到右下角，每一步只能向右或者向下。沿途经过的数字要累加起来。返回最小的路径和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minPath1</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> process1(matrix, matrix.length - <span class="number">1</span>, matrix[<span class="number">0</span>].length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归版</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process1</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = matrix[i][j];</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> res + process1(matrix, i, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> res + process1(matrix, i - <span class="number">1</span>, j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res + Math.min(process1(matrix, i, j - <span class="number">1</span>), process1(matrix, i - <span class="number">1</span>, j));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划版</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minPath2</span><span class="params">(<span class="keyword">int</span>[][] m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="keyword">null</span> || m.length == <span class="number">0</span> || m[<span class="number">0</span>] == <span class="keyword">null</span> || m[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> row = m.length;</span><br><span class="line"><span class="keyword">int</span> col = m[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + m[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + m[<span class="number">0</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + m[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] generateRandomMatrix(<span class="keyword">int</span> rowSize, <span class="keyword">int</span> colSize) &#123;</span><br><span class="line"><span class="keyword">if</span> (rowSize &lt; <span class="number">0</span> || colSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[rowSize][colSize];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != result.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != result[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">result[i][j] = (<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[][] m = &#123; &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span> &#125;, &#123; <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span> &#125;, &#123; <span class="number">8</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">0</span> &#125; &#125;;</span><br><span class="line">System.out.println(minPath1(m));</span><br><span class="line">System.out.println(minPath2(m));</span><br><span class="line"></span><br><span class="line">m = generateRandomMatrix(<span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">System.out.println(minPath1(m));</span><br><span class="line">System.out.println(minPath2(m));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>给你一个数组arr，和一个整数aim。如果可以任意选择arr中的数字，能不能累加得到aim，返回true或者false</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>每个位置 i 有 要和不要 两种选择；叶节点会看自己这里的结果是不是 aim，从而向父结点返回 true 或 false，父结点比较子节点的结果，有一个为 true 就一直返回 true，否则返回 false。</p><p><img src="https://s2.ax1x.com/2020/02/16/39kjYj.png" alt="39kjYj.png"></p><p>如上图所示：数组 arr = {3, 2, 5} ，aim = 7：</p><p>f(0, 0)：代表0位置处状态值为0的点；</p><p>f(2, 5)：代表2位置处状态值为5的点。</p><p>只要有叶节点的值等于 aim 的值，则会返回 true。</p><p>动态规划版图解：<br><img src="https://s2.ax1x.com/2020/02/16/39kgeO.png" alt="39kgeO.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">money1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> process(arr, <span class="number">0</span>, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> sum, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sum == aim) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sum != aim</span></span><br><span class="line"><span class="keyword">if</span> (i == arr.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> process(arr, i + <span class="number">1</span>, sum, aim) || process(arr, i + <span class="number">1</span>, sum + arr[i], aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划版</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">money2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[arr.length + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">dp[i][aim] = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = aim - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">dp[i][j] = dp[i + <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">if</span> (j + arr[i] &lt;= aim) &#123;</span><br><span class="line">dp[i][j] = dp[i][j] || dp[i + <span class="number">1</span>][j + arr[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> aim = <span class="number">12</span>;</span><br><span class="line">System.out.println(money1(arr, aim));</span><br><span class="line">System.out.println(money2(arr, aim));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="商品价值"><a href="#商品价值" class="headerlink" title="商品价值"></a>商品价值</h2><p>给定两个数组w和v，两个数组长度相等，w[i]表示第i件商品的 重量，v[i]表示第i件商品的价值。 再给定一个整数bag，要求 你挑选商品的重量加起来一定不能超 过bag，返回满足这个条件 下，你能获得的最大价值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxValue1</span><span class="params">(<span class="keyword">int</span>[] c, <span class="keyword">int</span>[] p, <span class="keyword">int</span> bag)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> process1(c, p, <span class="number">0</span>, <span class="number">0</span>, bag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process1</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span>[] values, <span class="keyword">int</span> i, <span class="keyword">int</span> alreadyweight, <span class="keyword">int</span> bag)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (alreadyweight &gt; bag) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == weights.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.max(</span><br><span class="line">process1(weights, values, i + <span class="number">1</span>, alreadyweight, bag),</span><br><span class="line"></span><br><span class="line">values[i] + process1(weights, values, i + <span class="number">1</span>, alreadyweight + weights[i], bag)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxValue2</span><span class="params">(<span class="keyword">int</span>[] c, <span class="keyword">int</span>[] p, <span class="keyword">int</span> bag)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[c.length + <span class="number">1</span>][bag + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = c.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = bag; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">dp[i][j] = dp[i + <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">if</span> (j + c[i] &lt;= bag) &#123;</span><br><span class="line">dp[i][j] = Math.max(dp[i][j], p[i] + dp[i + <span class="number">1</span>][j + c[i]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] c = &#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] p = &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">19</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> bag = <span class="number">11</span>;</span><br><span class="line">System.out.println(maxValue1(c, p, bag));</span><br><span class="line">System.out.println(maxValue2(c, p, bag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源《程序员代码面试指南》左程云著&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98&quot;&gt;排序问题&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98&quot;&gt;小和问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98&quot;&gt;逆序对问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%9B%B8%E9%82%BB%E4%B8%A4%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC&quot;&gt;相邻两数的最大差值&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97&quot;&gt;栈和队列&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%9A%84%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88&quot;&gt;数组实现固定大小的队列和栈&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%9E%E7%8E%B0%E8%BF%94%E5%9B%9E%E6%A0%88%E4%B8%AD%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0&quot;&gt;实现返回栈中最小元素&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%A6%81%E6%B1%82&quot;&gt;要求&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%A6%82%E4%BD%95%E4%BB%85%E7%94%A8%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E6%A0%88%E7%BB%93%E6%9E%84&quot;&gt;如何仅用队列结构实现栈结构？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%A6%82%E4%BD%95%E4%BB%85%E7%94%A8%E6%A0%88%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84&quot;&gt;如何仅用栈结构实现队列结构？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%8C%AB%E7%8B%97%E9%98%9F%E5%88%97&quot;&gt;猫狗队列&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%A6%81%E6%B1%82-1&quot;&gt;要求&lt;/a&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://jelly54.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://jelly54.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>一致性哈希算法</title>
    <link href="https://jelly54.github.io/alg-consistent-hash/"/>
    <id>https://jelly54.github.io/alg-consistent-hash/</id>
    <published>2020-02-20T07:16:59.000Z</published>
    <updated>2020-08-28T06:22:45.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。 </p><pre><code>一致性hash算法提出了在动态变化的Cache环境中，</code></pre><a id="more"></a><h1 id="判定哈希算法好坏的四个定义"><a href="#判定哈希算法好坏的四个定义" class="headerlink" title="判定哈希算法好坏的四个定义"></a>判定哈希算法好坏的四个定义</h1><h2 id="平衡性-Balance"><a href="#平衡性-Balance" class="headerlink" title="平衡性(Balance)"></a>平衡性(Balance)</h2><p>平衡性是指<strong>哈希的结果能够尽可能分布到所有的缓冲中去</strong>，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</p><h2 id="单调性-Monotonicity"><a href="#单调性-Monotonicity" class="headerlink" title="单调性(Monotonicity)"></a>单调性(Monotonicity)</h2><p>单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。<strong>哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去</strong>，而不会被映射到旧的缓冲集合中的其他缓冲区。 </p><h2 id="分散性-Spread"><a href="#分散性-Spread" class="headerlink" title="分散性(Spread)"></a>分散性(Spread)</h2><p>在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而<strong>导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中</strong>。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应<strong>能够尽量避免不一致的情况发生</strong>，也就是尽量降低分散性。 </p><h2 id="负载-Load"><a href="#负载-Load" class="headerlink" title="负载(Load)"></a>负载(Load)</h2><p>负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么<strong>对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容</strong>。与分散性一样，<strong>这种情况也是应当避免的</strong>，因此好的哈希算法应能够尽量降低缓冲的负荷。</p><p>在分布式集群中，对机器的添加删除，或者机器故障后自动脱离集群这些操作是分布式集群管理最基本的功能。如果采用常用的hash(object)%N算法，那么在有机器添加或者删除后，很多原有的数据就无法找到了，这样严重的违反了单调性原则。接下来主要讲解一下一致性哈希算法是如何设计的：</p><h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><h2 id="环形Hash空间"><a href="#环形Hash空间" class="headerlink" title="环形Hash空间"></a>环形Hash空间</h2><p>按照常用的hash算法来将对应的key哈希到一个具有2^32次方个桶的空间中，即0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如下图<br><img src="https://s1.ax1x.com/2020/05/14/YByLAx.png" alt="YByLAx.png"></p><h2 id="把数据通过一定hash算法处理后映射到环上"><a href="#把数据通过一定hash算法处理后映射到环上" class="headerlink" title="把数据通过一定hash算法处理后映射到环上"></a>把数据通过一定hash算法处理后映射到环上</h2><p>现在我们将object1、object2、object3、object4四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上。如下图：</p><pre><code>Hash(object1) = key1；Hash(object2) = key2；Hash(object3) = key3；Hash(object4) = key4；</code></pre><p><img src="https://s1.ax1x.com/2020/05/14/YByojJ.png" alt="YByojJ.png"></p><h2 id="将机器通过hash算法映射到环上"><a href="#将机器通过hash算法映射到环上" class="headerlink" title="将机器通过hash算法映射到环上"></a>将机器通过hash算法映射到环上</h2><p>在采用一致性哈希算法的分布式集群中将新的机器加入，其原理是通过使用与对象存储一样的Hash算法将机器也映射到环中（一般情况下对机器的hash计算是采用机器的IP或者机器唯一的别名作为输入值），然后以顺时针的方向计算，将所有对象存储到离自己最近的机器中。<br>假设现在有NODE1，NODE2，NODE3三台机器，通过Hash算法得到对应的KEY值，映射到环中，其示意图如下：</p><p>Hash(NODE1) = KEY1;<br>Hash(NODE2) = KEY2;<br>Hash(NODE3) = KEY3;</p><p><img src="https://s1.ax1x.com/2020/05/14/YByHBR.png" alt="YByHBR.png"></p><p>通过上图可以看出对象与机器处于同一哈希空间中，这样按顺时针转动object1存储到了NODE1中，object3存储到了NODE2中，object2、object4存储到了NODE3中。在这样的部署环境中，hash环是不会变更的，因此，通过算出对象的hash值就能快速的定位到对应的机器中，这样就能找到对象真正的存储位置了。</p><h2 id="机器的删除与添加"><a href="#机器的删除与添加" class="headerlink" title="机器的删除与添加"></a>机器的删除与添加</h2><p>普通hash求余算法最为不妥的地方就是在有机器的添加或者删除之后会照成大量的对象存储位置失效，这样就大大的不满足单调性了。下面来分析一下一致性哈希算法是如何处理的。</p><h3 id="节点（机器）的删除"><a href="#节点（机器）的删除" class="headerlink" title="节点（机器）的删除"></a>节点（机器）的删除</h3><p>以上面的分布为例，如果NODE2出现故障被删除了，那么按照顺时针迁移的方法，object3将会被迁移到NODE3中，这样仅仅是object3的映射位置发生了变化，其它的对象没有任何的改动。如下图：<br><img src="https://s1.ax1x.com/2020/05/14/YBy7u9.png" alt="YBy7u9.png"></p><h3 id="节点（机器）的添加"><a href="#节点（机器）的添加" class="headerlink" title="节点（机器）的添加"></a>节点（机器）的添加</h3><p>如果往集群中添加一个新的节点NODE4，通过对应的哈希算法得到KEY4，并映射到环中，如下图：<br><img src="https://s1.ax1x.com/2020/05/14/YBybH1.png" alt="YBybH1.png"></p><p>通过按顺时针迁移的规则，那么object2被迁移到了NODE4中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。</p><h2 id="平衡性"><a href="#平衡性" class="headerlink" title="平衡性"></a>平衡性</h2><p>根据上面的图解分析，一致性哈希算法满足了单调性和负载均衡的特性以及一般hash算法的分散性，但这还并不能当做其被广泛应用的原由，因为还缺少了平衡性。下面将分析一致性哈希算法是如何满足平衡性的。hash算法是不保证平衡的，如上面只部署了NODE1和NODE3的情况（NODE2被删除的图），object1存储到了NODE1中，而object2、object3、object4都存储到了NODE3中，这样就照成了非常不平衡的状态。在一致性哈希算法中，为了尽可能的满足平衡性，其引入了虚拟节点。</p><blockquote><p>“虚拟节点”（ virtual node ）是实际节点（机器）在 hash 空间的复制品（ replica ），一实际个节点（机器）对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以hash值排列。</p></blockquote><p>以上面只部署了NODE1和NODE3的情况（NODE2被删除的图）为例，之前的对象在机器上的分布很不均衡，现在我们以2个副本（复制个数）为例，这样整个hash环中就存在了4个虚拟节点，最后对象映射的关系图如下：</p><p><img src="https://s1.ax1x.com/2020/05/14/YByON6.png" alt="YByON6.png"></p><p>根据上图可知对象的映射关系：object1-&gt;NODE1-1，object2-&gt;NODE1-2，object3-&gt;NODE3-2，object4-&gt;NODE3-1。通过虚拟节点的引入，对象的分布就比较均衡了。那么在实际操作中，正真的对象查询是如何工作的呢？对象从hash到虚拟节点到实际节点的转换如下图：</p><p><img src="https://s1.ax1x.com/2020/05/14/YByX4K.png" alt="YByX4K.png"></p><p>“虚拟节点”的hash计算可以采用对应节点的IP地址加数字后缀的方式。例如假设NODE1的IP地址为192.168.1.100。引入“虚拟节点”前，计算 cache A 的 hash 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hash(“192.168.1.100”);</span><br></pre></td></tr></table></figure><p>引入“虚拟节点”后，计算“虚拟节”点NODE1-1和NODE1-2的hash值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hash(“192.168.1.100#1”); // NODE1-1</span><br><span class="line">Hash(“192.168.1.100#2”); // NODE1-2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;一致性hash算法提出了在动态变化的Cache环境中，&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://jelly54.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://jelly54.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="一致性问题" scheme="https://jelly54.github.io/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>手写LRU缓存算法</title>
    <link href="https://jelly54.github.io/alg-lru-coding/"/>
    <id>https://jelly54.github.io/alg-lru-coding/</id>
    <published>2020-02-18T06:20:42.000Z</published>
    <updated>2020-08-28T06:41:31.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。</p><p>该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t，当须淘汰一个页面时，选择现有页面中其t 值最大的，即最近最少使用的页面予以淘汰。</p><a id="more"></a><h1 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> cacheSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置一个HashMap的初始大小，加载因子，按照访问顺序排序</span></span><br><span class="line">        <span class="comment">// 最近访问放在头部，最老访问放在尾</span></span><br><span class="line">        <span class="keyword">super</span>((<span class="keyword">int</span>) (Math.ceil(cacheSize / <span class="number">0.75</span>) + <span class="number">1</span>), <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        CACHE_SIZE = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// map中的数量大于指定的缓存个数时，自动删除最老的数据</span></span><br><span class="line">        <span class="keyword">return</span> size() &gt; CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。&lt;/p&gt;
&lt;p&gt;该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t，当须淘汰一个页面时，选择现有页面中其t 值最大的，即最近最少使用的页面予以淘汰。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://jelly54.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://jelly54.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LRU缓存" scheme="https://jelly54.github.io/tags/LRU%E7%BC%93%E5%AD%98/"/>
    
      <category term="手撕算法" scheme="https://jelly54.github.io/tags/%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>缓存数据库双写不一致问题</title>
    <link href="https://jelly54.github.io/cache-database-cons/"/>
    <id>https://jelly54.github.io/cache-database-cons/</id>
    <published>2020-02-01T12:13:54.000Z</published>
    <updated>2020-08-28T05:58:47.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h1><ol><li>读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应。</li><li>更新的时候先删除缓存，然后再更新数据库</li></ol><a id="more"></a><h2 id="为什么删除而不是更新缓存"><a href="#为什么删除而不是更新缓存" class="headerlink" title="为什么删除而不是更新缓存"></a>为什么删除而不是更新缓存</h2><p>原因很简单，很多时候，复杂点的缓存的场景，因为缓存有的时候，不简单是数据库中直接取出来的值。</p><p>如：商品详情页的系统，修改库存，只是修改了某个表的某些字段，但是要得到最终的库存，可能还需要从其他表查询一些数据，然后进行一些复杂的运算，才能最终计算出现在最新的库存是多少，然后才能将库存更新到缓存中去。</p><p>有很多数据并不是热数据，可能更新之后很久不会被访问，修改时更新缓存，反而增加了系统负荷。修改数据的时候，只删除缓存，不用每次都重新做复杂的计算，再下次使用它的时候再进行计算并缓存。</p><hr><h1 id="缓存数据库双写不一致？"><a href="#缓存数据库双写不一致？" class="headerlink" title="缓存数据库双写不一致？"></a>缓存数据库双写不一致？</h1><h2 id="初级的缓存不一致问题"><a href="#初级的缓存不一致问题" class="headerlink" title="初级的缓存不一致问题"></a>初级的缓存不一致问题</h2><p>先修改数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据出现不一致。</p><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p><strong>先删除缓存，再修改数据库</strong>。如果删除缓存成功了，如果修改数据库失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。</p><p>因为读的时候缓存没有，则读数据库中旧数据，然后更新到缓存中。</p><h2 id="较复杂的数据不一致问题"><a href="#较复杂的数据不一致问题" class="headerlink" title="较复杂的数据不一致问题"></a>较复杂的数据不一致问题</h2><p>数据发生变更，先删除了缓存，然后要去修改数据库，此时还没修改。</p><p>一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中，</p><p>数据变更的程序完成了数据库的修改</p><p>完了，数据库和缓存中的数据不一样了。。。。</p><h3 id="数据库与缓存更新与读取操作进行异步串行化"><a href="#数据库与缓存更新与读取操作进行异步串行化" class="headerlink" title="数据库与缓存更新与读取操作进行异步串行化"></a>数据库与缓存更新与读取操作进行异步串行化</h3><ul><li><p><strong>更新数据的时候</strong>，根据数据的唯一标识，将操作路由之后，<strong>发送到一个jvm内部的队列中</strong>。</p></li><li><p><strong>读取数据的时候</strong>，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，<strong>也发送同一个jvm内部的队列中</strong>。</p></li></ul><p><strong>一个队列对应一个工作线程</strong>，每个工作线程<strong>串行</strong>拿到对应的操作，然后一条一条的执行。</p><p>一个数据变更的操作，先执行，删除缓存，然后再去更新数据库，但是还没完成更新，此时如果一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。</p><p><strong>优化点</strong>：一个队列中，其实多个更新缓存请求串在一起是没意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。</p><p>待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。</p><p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回; <strong>如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值</strong>。</p><hr><h1 id="高并发的场景下，该解决方案要注意的问题"><a href="#高并发的场景下，该解决方案要注意的问题" class="headerlink" title="高并发的场景下，该解决方案要注意的问题"></a>高并发的场景下，该解决方案要注意的问题</h1><h2 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h2><p>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况</p><p>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p><h2 id="读请求长时阻塞"><a href="#读请求长时阻塞" class="headerlink" title="读请求长时阻塞"></a>读请求长时阻塞</h2><p>由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回</p><p>该解决方案，最大的风险点在于说，可能数据更新很频繁，导致队列中积压了大量更新操作在里面，然后读请求会发生大量的超时，最后导致大量的请求直接走数据库</p><p><strong>务必通过一些模拟真实的测试，看看更新数据的频繁是怎样的</strong></p><p>另外一点，因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，可能需要部署多个服务，每个服务分摊一些数据的更新操作</p><p>如果一个内存队列里居然会挤压100个商品的库存修改操作，每隔库存修改操作要耗费10ms区完成，那么最后一个商品的读请求，可能等待10 * 100 = 1000ms = 1s后，才能得到数据，这个时候就导致读请求的长时阻塞</p><p><strong>一定要做根据实际业务系统的运行情况，去进行一些压力测试，和模拟线上环境</strong>，去看看最繁忙的时候，内存队列可能会挤压多少更新操作，可能会导致最后一个更新操作对应的读请求，会hang多少时间，如果读请求在200ms返回，如果你计算过后，哪怕是最繁忙的时候，积压10个更新操作，最多等待200ms，那还可以的</p><p>如果一个内存队列可能积压的更新操作特别多，那么你就要加机器，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少</p><p>其实根据之前的项目经验，一般来说数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的</p><p>针对读高并发，读缓存架构的项目，一般写请求相对读来说，是非常非常少的，每秒的QPS能到几百就不错了</p><p>一秒，500的写操作，5份，每200ms，就有100个写操作</p><p>单机器，20个内存队列，每个内存队列，可能就积压5个写操作，每个写操作性能测试后，一般在20ms左右就完成</p><p>那么针对每个内存队列中的数据的读请求，也就最多hang一会儿，200ms以内肯定能返回了</p><p>写QPS扩大10倍，但是经过刚才的测算，就知道，单机支撑写QPS几百没问题，那么就扩容机器，扩容10倍的机器，10台机器，每个机器20个队列，200个队列</p><p>大部分的情况下，应该是这样的，大量的读请求过来，都是直接走缓存取到数据的</p><p>少量情况下，可能遇到读跟数据更新冲突的情况，如上所述，那么此时更新操作如果先入队列，之后可能会瞬间来了对这个数据大量的读请求，但是因为做了去重的优化，所以也就一个更新缓存的操作跟在它后面</p><p>等数据更新完了，读请求触发的缓存更新操作也完成，然后临时等待的读请求全部可以读到缓存中的数据</p><h2 id="读请求并发量过高"><a href="#读请求并发量过高" class="headerlink" title="读请求并发量过高"></a>读请求并发量过高</h2><p>这里还必须做好压力测试，确保恰巧碰上上述情况的时候，还有一个风险，就是突然间大量读请求会在几十毫秒的延时hang在服务上，看服务能不能抗的住，需要多少机器才能抗住最大的极限情况的峰值</p><p>但是因为并不是所有的数据都在同一时间更新，缓存也不会同一时间失效，所以每次可能也就是少数数据的缓存失效了，然后那些数据对应的读请求过来，并发量应该也不会特别大</p><p>按1:99的比例计算读和写的请求，每秒5万的读QPS，可能只有500次更新操作</p><p>如果一秒有500的写QPS，那么要测算好，可能写操作影响的数据有500条，这500条<strong>数据在缓存中失效后，可能导致多少读请求，发送读请求到库存服务来，要求更新缓存</strong></p><p>一般来说，1:1，1:2，1:3，每秒钟有1000个读请求，会hang在库存服务上，每个读请求最多hang多少时间，200ms就会返回</p><p>在同一时间最多hang住的可能也就是单机200个读请求，同时hang住</p><p>单机hang200个读请求，还是ok的</p><p>1:20，每秒更新500条数据，这500秒数据对应的读请求，会有20 * 500 = 1万</p><p>1万个读请求全部hang在库存服务上，就死定了</p><h2 id="多服务实例部署的请求路由"><a href="#多服务实例部署的请求路由" class="headerlink" title="多服务实例部署的请求路由"></a>多服务实例部署的请求路由</h2><p>可能这个服务部署了多个实例，那么必须保证说，执行数据更新操作，以及执行缓存更新操作的请求，<strong>都通过nginx服务器路由到相同的服务实例上</strong>(服务间按照某个请求参数的hash路由)</p><h2 id="热点商品的路由问题，导致请求的倾斜"><a href="#热点商品的路由问题，导致请求的倾斜" class="headerlink" title="热点商品的路由问题，导致请求的倾斜"></a>热点商品的路由问题，导致请求的倾斜</h2><p>万一某个商品的读写请求特别高，全部打到相同的机器的相同的队列里面去了，可能造成某台机器的压力过大</p><p>就是说，因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以更新频率不是太高的话，这个问题的影响并不是特别大</p><p>但是的确可能某些机器的负载会高一些</p><hr><h1 id="缓存雪崩发生的现象"><a href="#缓存雪崩发生的现象" class="headerlink" title="缓存雪崩发生的现象"></a>缓存雪崩发生的现象</h1><p><img src="https://s2.ax1x.com/2020/01/04/lwrA29.png" alt="lwrA29.png"></p><h2 id="缓存雪崩的事前事中事后的解决方案"><a href="#缓存雪崩的事前事中事后的解决方案" class="headerlink" title="缓存雪崩的事前事中事后的解决方案"></a>缓存雪崩的事前事中事后的解决方案</h2><ul><li>事前：redis高可用，主从+哨兵，redis cluster，避免全盘崩溃</li><li>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL被打死</li><li>事后：redis持久化，快速恢复缓存数据</li></ul><p><img src="https://s2.ax1x.com/2020/01/04/lwrEvR.png" alt="lwrEvR.png"></p><hr><h1 id="缓存穿透的现象"><a href="#缓存穿透的现象" class="headerlink" title="缓存穿透的现象"></a>缓存穿透的现象</h1><p><img src="https://s2.ax1x.com/2020/01/04/lwrmb6.png" alt="lwrmb6.png"></p><h2 id="缓存穿透的解决方法"><a href="#缓存穿透的解决方法" class="headerlink" title="缓存穿透的解决方法"></a>缓存穿透的解决方法</h2><p>每次系统a从数据库没有查到信息，就在缓存中存一个空值，这样下次就会走缓存而不是穿透到数据库。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Cache-Aside-Pattern&quot;&gt;&lt;a href=&quot;#Cache-Aside-Pattern&quot; class=&quot;headerlink&quot; title=&quot;Cache Aside Pattern&quot;&gt;&lt;/a&gt;Cache Aside Pattern&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应。&lt;/li&gt;
&lt;li&gt;更新的时候先删除缓存，然后再更新数据库&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Cache" scheme="https://jelly54.github.io/categories/Cache/"/>
    
    
      <category term="一致性问题" scheme="https://jelly54.github.io/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    
      <category term="缓存" scheme="https://jelly54.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="缓存穿透" scheme="https://jelly54.github.io/tags/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/"/>
    
      <category term="缓存雪崩" scheme="https://jelly54.github.io/tags/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/"/>
    
  </entry>
  
  <entry>
    <title>为什么要使用缓存</title>
    <link href="https://jelly54.github.io/cache-why-use/"/>
    <id>https://jelly54.github.io/cache-why-use/</id>
    <published>2020-02-01T10:13:17.000Z</published>
    <updated>2020-08-28T02:38:29.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要用缓存"><a href="#为什么要用缓存" class="headerlink" title="为什么要用缓存"></a>为什么要用缓存</h1><p>结合以下两点说自己的项目。</p><a id="more"></a><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><p><img src="https://s2.ax1x.com/2019/12/28/lmpSAS.png" alt="lmpSAS.png"></p><p>假设这么个场景，你有个操作，一个请求过来，吭哧吭哧你各种乱七八糟操作mysql，半天查出来一个结果，耗时600ms。但是这个结果可能接下来几个小时都不会变了，或者变了也可以不用立即反馈给用户。那么此时咋办？</p><p>缓存啊，折腾600ms查出来的结果，扔缓存里，一个key对应一个value，下次再有人查，别走mysql折腾600ms了。直接从缓存里，通过一个key查出来一个value，2ms搞定。性能提升300倍。</p><p>这就是所谓的高性能。</p><p>就是把你一些复杂操作耗时查出来的结果，如果确定后面不咋变了，然后但是马上还有很多读请求，那么直接结果放缓存，后面直接读缓存就好了。</p><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p><img src="https://s2.ax1x.com/2019/12/28/lmSx78.png" alt="lmSx78.png"></p><p>mysql这么重的数据库，压根儿设计不是让你玩儿高并发的，虽然也可以玩儿，但是天然支持不好。mysql单机支撑到2000qps也开始容易报警了。</p><p>所以要是你有个系统，高峰期一秒钟过来的请求有1万，那一个mysql单机绝对会死掉。你这个时候就只能上缓存，把很多数据放缓存，别放mysql。缓存功能简单，说白了就是key-value式操作，单机支撑的并发量轻松一秒几万十几万，支撑高并发so easy。单机承载并发量是mysql单机的几十倍。</p><hr><h1 id="缓存常见问题"><a href="#缓存常见问题" class="headerlink" title="缓存常见问题"></a>缓存常见问题</h1><p>1）缓存与数据库双写不一致<br>2）缓存雪崩<br>3）缓存穿透<br>4）缓存并发竞争</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么要用缓存&quot;&gt;&lt;a href=&quot;#为什么要用缓存&quot; class=&quot;headerlink&quot; title=&quot;为什么要用缓存&quot;&gt;&lt;/a&gt;为什么要用缓存&lt;/h1&gt;&lt;p&gt;结合以下两点说自己的项目。&lt;/p&gt;
    
    </summary>
    
      <category term="Cache" scheme="https://jelly54.github.io/categories/Cache/"/>
    
    
      <category term="缓存" scheme="https://jelly54.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>mysql主从复制</title>
    <link href="https://jelly54.github.io/mysql-master-slave/"/>
    <id>https://jelly54.github.io/mysql-master-slave/</id>
    <published>2020-01-29T07:16:21.000Z</published>
    <updated>2020-08-27T11:05:52.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>slave会从master读取binlog来进行数据同步</p><h2 id="三步骤"><a href="#三步骤" class="headerlink" title="三步骤"></a>三步骤</h2><p><img src="https://s2.ax1x.com/2019/12/22/QxgIlq.png" alt="QxgIlq.png"></p><ol><li>master将改变记录到二进制日志(binary log)。这些记录过程叫做二进制日志事件，binary log events;</li><li>slave将master的binary log events拷贝到它的中继日志(relay log);</li><li>slave重做中继日志中的事件，将改变应用到自己的数据库中。Mysql复制是异步的且串行化的</li></ol><a id="more"></a><h1 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h1><ol><li>每个slave只有一个master</li><li>每个slave只能有唯一的服务器ID</li><li>每个master可以有多个salve</li></ol><h1 id="最大问题"><a href="#最大问题" class="headerlink" title="最大问题"></a>最大问题</h1><p>延时</p><h1 id="一主已从常见配置"><a href="#一主已从常见配置" class="headerlink" title="一主已从常见配置"></a>一主已从常见配置</h1><p>mysql版本一致且后台以服务运行；<br>主从都配置在[mysqld]节点下，都是小写。</p><h2 id="主机配置文件"><a href="#主机配置文件" class="headerlink" title="主机配置文件"></a>主机配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 必须 服务器唯一ID</span><br><span class="line">server-id=1</span><br><span class="line"></span><br><span class="line"># 必须 启用二进制日志</span><br><span class="line"># 如：log-bin=D:/Mysql5.5/data/mysqlbin</span><br><span class="line">log-bin=自己的本地路径/mysqlbin</span><br><span class="line"></span><br><span class="line"># 可选 启用错误日志</span><br><span class="line"># 如：log-bin=D:/Mysql5.5/data/mysqlerr</span><br><span class="line">log-err=自己的本地路径/mysqlerr</span><br><span class="line"></span><br><span class="line"># 可选 根目录</span><br><span class="line">basedir=&quot;D:/Mysql5.5/&quot;</span><br><span class="line"></span><br><span class="line"># 可选 临时目录</span><br><span class="line">tmpdir=&quot;D:/Mysql5.5/&quot;</span><br><span class="line"></span><br><span class="line"># 可选 数据目录</span><br><span class="line">datadir=&quot;D:/Mysql5.5/data/&quot;</span><br><span class="line"></span><br><span class="line"># 设置读写权限(主机应是读写都可)</span><br><span class="line">read-only=0</span><br><span class="line"></span><br><span class="line"># 可选 设置不要复制的数据库</span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line"></span><br><span class="line"># 可选 设置需要复制的数据库</span><br><span class="line">binlog-do-db=需要复制的主数据库名字</span><br></pre></td></tr></table></figure><h2 id="从机配置文件"><a href="#从机配置文件" class="headerlink" title="从机配置文件"></a>从机配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 必须 从服务器唯一ID</span><br><span class="line"></span><br><span class="line"># 可选 启用二进制日志</span><br></pre></td></tr></table></figure><h2 id="主机授权从机访问"><a href="#主机授权从机访问" class="headerlink" title="主机授权从机访问"></a>主机授权从机访问</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 授权</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span> <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">TO</span> <span class="string">'username'</span>@<span class="string">'从库IP'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'password'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新权限</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询主机状态, 记录下File和Position的值</span></span><br><span class="line"><span class="comment"># 每次配置都需要记录新的File和Position的值。</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure><h2 id="从机设置访问账户"><a href="#从机设置访问账户" class="headerlink" title="从机设置访问账户"></a>从机设置访问账户</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置访问主机的账户、数据起始位置等</span></span><br><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> MASTER_HOST=<span class="string">'主机IP'</span>, MASTER_USER=<span class="string">'username'</span>, MASTER_PASSWORD=<span class="string">'password'</span>, MASTER_LOG_FILE=<span class="string">'mysqlbin.具体数字'</span>, MASTER_LOG_POS=具体数值;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启服务器复制功能</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询从机状态。以下两个参数都是Yes说明配置成功</span></span><br><span class="line"><span class="comment"># Slave_IO_Running:Yes</span></span><br><span class="line"><span class="comment"># Slave_SQL_Running:Yes</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span>\G</span><br></pre></td></tr></table></figure><h2 id="停止从机复制服务"><a href="#停止从机复制服务" class="headerlink" title="停止从机复制服务"></a>停止从机复制服务</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h1&gt;&lt;p&gt;slave会从master读取binlog来进行数据同步&lt;/p&gt;
&lt;h2 id=&quot;三步骤&quot;&gt;&lt;a href=&quot;#三步骤&quot; class=&quot;headerlink&quot; title=&quot;三步骤&quot;&gt;&lt;/a&gt;三步骤&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/12/22/QxgIlq.png&quot; alt=&quot;QxgIlq.png&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;master将改变记录到二进制日志(binary log)。这些记录过程叫做二进制日志事件，binary log events;&lt;/li&gt;
&lt;li&gt;slave将master的binary log events拷贝到它的中继日志(relay log);&lt;/li&gt;
&lt;li&gt;slave重做中继日志中的事件，将改变应用到自己的数据库中。Mysql复制是异步的且串行化的&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://jelly54.github.io/categories/Mysql/"/>
    
    
      <category term="mysql" scheme="https://jelly54.github.io/tags/mysql/"/>
    
      <category term="主从架构" scheme="https://jelly54.github.io/tags/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>mysql锁</title>
    <link href="https://jelly54.github.io/mysql-lock/"/>
    <id>https://jelly54.github.io/mysql-lock/</id>
    <published>2020-01-29T02:25:52.000Z</published>
    <updated>2020-08-27T11:05:52.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>锁是计算机协调多个进程或县城并发访问某一资源的机制。</p><p>在数据库中，除传统的计算资源(如CPU、RAM、I/O等)的争用之外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据并发访问性能的一个重要因素。从这个角度来说，锁对数据库显得尤为重要，也更复杂。</p><a id="more"></a><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="从数据的操作的类型-读-写-分"><a href="#从数据的操作的类型-读-写-分" class="headerlink" title="从数据的操作的类型(读/写)分"></a>从数据的操作的类型(读/写)分</h3><p>读锁(共享锁)：<br>针对同一份数据，多个读操作是可以同时进行而互相不影响。</p><p>写锁(排它锁)：<br>当前写操作没有完成前，它会阻断其他写锁和读锁。</p><h3 id="从数据的操作粒度分"><a href="#从数据的操作粒度分" class="headerlink" title="从数据的操作粒度分"></a>从数据的操作粒度分</h3><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁力度大，发生锁冲突的概率最高，并发度最低。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动加锁  </span></span><br><span class="line"><span class="keyword">lock</span> <span class="keyword">table</span> 表名字 <span class="keyword">read</span>(write), 表名字<span class="number">2</span>; read(write)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看表上加过的锁</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> <span class="keyword">tables</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放表锁</span></span><br><span class="line"><span class="keyword">unlock</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><p>session1 对A表加读锁。</p><p>session1 可以读A表，<strong>不能读别的表，不能写当前表。</strong></p><p>session2 可以读A表，可以读或写别的表。但是对A进行写时会一直阻塞，等待获取锁。</p><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。</p><p>InnoDB与MyISAM最大的不同点：  </p><ol><li>支持事务(TRANSACTION)  </li><li>采用了行级锁</li></ol><hr><h1 id="事务及其ACID属性"><a href="#事务及其ACID属性" class="headerlink" title="事务及其ACID属性"></a>事务及其ACID属性</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是由一组SQL语句组成的逻辑处理单元，事务具有以下四个属性，通常简称为事务的ACID属性。</p><p><strong>Atomicity(原子性)：</strong> 事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</p><p><strong>Consistent(一致性)：</strong> 在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完善性；事务结束时所有的内部数据结构(如B数索引或双向链表)也都必须是正确得。</p><p><strong>Isolation(隔离性)：</strong> 数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部都是不可见的，反之亦然。</p><p><strong>Durable(持久性)：</strong> 事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</p><h2 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h2><p><strong>更新丢失(Lost Update)</strong><br>当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会出现丢失问题–最后的更新覆盖了由其他事务所做的更新。</p><p><strong>脏读(Dirty Reads)</strong><br>一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取这条记录，如果不加控制，第二个事务读取了这些“脏数据”，并据此做进一步的处理，就会产生未提交的数据依赖关系。</p><p>事务A读取到事务B<strong>已经修改但尚未提交的数据</strong>，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。</p><p><strong>不可重复读(Non-Repeatable Reads)</strong><br>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变，或某些记录已经被删除。</p><p>事务A读取到了事务B已经提交的修改数据，不符合隔离性。</p><p><strong>幻读(Phantom Reads)</strong><br>一个事务按照相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据。</p><p>事务A读取到了事务B提交的新增的数据，不符合隔离性。</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><table><thead><tr><th>读数据一致性及允许的并发副作用隔离级别</th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读(Read uncommitted)</td><td>最低级别，只能保证不读取物理上被损坏的数据</td><td>是</td><td>是</td><td>是</td></tr><tr><td>已提交读(Read committed)</td><td>语句级</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读(Repeatable read)</td><td>事务级</td><td>否</td><td>否</td><td>是</td></tr><tr><td>可序列化(Serializable)</td><td>最高级别，事务级</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前数据库的事务隔离级别</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'tx_isolation;'</span></span><br></pre></td></tr></table></figure><p><strong>数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大</strong>。因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然于“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的。比如，许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。</p><hr><h1 id="索引失效行锁变表锁"><a href="#索引失效行锁变表锁" class="headerlink" title="索引失效行锁变表锁"></a>索引失效行锁变表锁</h1><h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但不存在的记录，叫做“间隙(GAP)”, InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁(Next-Key锁)。</p><p><strong>危害：</strong><br>因为Query执行过程中通过范围查找的话，他会索订整个范围内所有的索引键值，即使这个键值并不存在。间隙锁有一个比较致命的弱点，就是 <strong>当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入索订键值范围内的任何数据。</strong></p><h2 id="如何锁定一行"><a href="#如何锁定一行" class="headerlink" title="如何锁定一行"></a>如何锁定一行</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line"></span><br><span class="line"><span class="comment"># for update 锁定某一行之后，其他操作会被阻塞，直到锁定行的会话提交commit</span></span><br><span class="line">mysql&gt; select * from xx_table where a=8 for update;</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br></pre></td></tr></table></figure><h2 id="锁状态量分析"><a href="#锁状态量分析" class="headerlink" title="锁状态量分析"></a>锁状态量分析</h2><p>可通过检查INNODB_ROW+LOCK状态量来分析系统上的行锁的情况。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; show status like 'innodb_row_lock%;'</span><br><span class="line"></span><br><span class="line"><span class="comment"># 状态量说明</span></span><br><span class="line">innodb_row_lock_current_waits: 当前正在等待锁的数量</span><br><span class="line"></span><br><span class="line">innodb_row_lock_time:从系统启动到现在锁定 总时间长度。</span><br><span class="line"></span><br><span class="line">innodb_row_lock_time_avg: 每次等待所花平均时间，</span><br><span class="line"></span><br><span class="line">innodb_row_lock_time_max:从系统启动到现在等待这段时间</span><br><span class="line"></span><br><span class="line">innodb_row_lock_waits:系统启动后到现在总共等待的次数。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尤其是当等待次数很高，而且每次等待时间也不小的时候</span></span><br><span class="line"><span class="comment"># 我们就需要 **分析系统之中为什么会有如此多的等待，然后根据分析结果着手指定优化计划**。</span></span><br></pre></td></tr></table></figure><h2 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h2><ol><li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。</li><li>合理设计索引，尽量缩小锁的范围</li><li>尽可能较少检索条件，避免间隙锁。</li><li>尽量控制事务大小，减少锁定资源量和时间长度。</li><li>尽可能低级别事务隔离。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;锁是计算机协调多个进程或县城并发访问某一资源的机制。&lt;/p&gt;
&lt;p&gt;在数据库中，除传统的计算资源(如CPU、RAM、I/O等)的争用之外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据并发访问性能的一个重要因素。从这个角度来说，锁对数据库显得尤为重要，也更复杂。&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://jelly54.github.io/categories/Mysql/"/>
    
    
      <category term="锁" scheme="https://jelly54.github.io/tags/%E9%94%81/"/>
    
      <category term="mysql" scheme="https://jelly54.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql全局日志</title>
    <link href="https://jelly54.github.io/mysql-global-log/"/>
    <id>https://jelly54.github.io/mysql-global-log/</id>
    <published>2020-01-18T09:24:05.000Z</published>
    <updated>2020-08-27T11:05:52.288Z</updated>
    
    <content type="html"><![CDATA[<p><strong>永远不要再生产环境开启这个功能</strong></p><a id="more"></a><p>配置启用 my.cnf</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启</span></span><br><span class="line">general_log=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录日志文件的路径</span></span><br><span class="line">general_log_file=/path/logfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出格式</span></span><br><span class="line">log_output=FILE</span><br></pre></td></tr></table></figure><p>编码启用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启</span></span><br><span class="line">mysql&gt; set global general_log=1</span><br><span class="line"></span><br><span class="line">mysql&gt; set global log_output='TABLE';</span><br><span class="line"></span><br><span class="line"><span class="comment"># 之后所编写的sql语句，将会记录到mysql库里的general_log表，可以用以下命令查看</span></span><br><span class="line">mysql&gt; select * from mysql.general_log;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;永远不要再生产环境开启这个功能&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://jelly54.github.io/categories/Mysql/"/>
    
    
      <category term="mysql" scheme="https://jelly54.github.io/tags/mysql/"/>
    
      <category term="日志" scheme="https://jelly54.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>mysql show profile用法</title>
    <link href="https://jelly54.github.io/mysql-show-profile/"/>
    <id>https://jelly54.github.io/mysql-show-profile/</id>
    <published>2020-01-18T09:04:35.000Z</published>
    <updated>2020-08-28T02:43:07.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>show profile是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于sql调优的测量。</p><p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p><a id="more"></a><h1 id="分析步骤"><a href="#分析步骤" class="headerlink" title="分析步骤"></a>分析步骤</h1><h2 id="是否支持"><a href="#是否支持" class="headerlink" title="是否支持"></a>是否支持</h2><p>查看当前mysql版本是否支持</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'profiling'</span>;</span><br></pre></td></tr></table></figure><h2 id="开启功能"><a href="#开启功能" class="headerlink" title="开启功能"></a>开启功能</h2><p>默认是关闭的，使用前需要开启</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling = <span class="keyword">on</span>;</span><br></pre></td></tr></table></figure><h2 id="运行sql"><a href="#运行sql" class="headerlink" title="运行sql"></a>运行sql</h2><p>指生产环境或者测试的sql查询、更新等</p><h2 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;</span><br></pre></td></tr></table></figure><h2 id="诊断sql"><a href="#诊断sql" class="headerlink" title="诊断sql"></a>诊断sql</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x 为上一步中查询的id。</span></span><br><span class="line"><span class="keyword">show</span> profile cpu, <span class="keyword">block</span> io <span class="keyword">for</span> <span class="keyword">query</span> x; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选参数：</span></span><br><span class="line">all     <span class="comment">-- 显示所有的开销</span></span><br><span class="line">block io <span class="comment">-- 显示块IO相关开销</span></span><br><span class="line">context switches  <span class="comment">-- 上下文切换相关开销</span></span><br><span class="line">cpu     <span class="comment">-- 显示cpu相关开销信息</span></span><br><span class="line">ipc     <span class="comment">-- 显示发送和接受相关开销信息</span></span><br><span class="line">memory  <span class="comment">-- 显示内存相关开销信息</span></span><br><span class="line">page faults  <span class="comment">-- 显示页面错误相关开销信息</span></span><br><span class="line">source  <span class="comment">-- 显示和source_function, source_file, source_line相关的开销信息</span></span><br><span class="line">swaps   <span class="comment">-- 显示交换次数相关开销信息</span></span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查询结果太大，内存都不够用了，转向磁盘</span><br><span class="line">converting HEAP to MyISAM </span><br><span class="line"># 创建临时表(拷贝数据到临时表，用完再删除)</span><br><span class="line">creating tmp table </span><br><span class="line"></span><br><span class="line"># 把内存中临时表复制到磁盘，危险！</span><br><span class="line">copying to tmp table on disk</span><br><span class="line"></span><br><span class="line"># </span><br><span class="line">lock</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h1&gt;&lt;p&gt;show profile是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于sql调优的测量。&lt;/p&gt;
&lt;p&gt;默认情况下，参数处于关闭状态，并保存最近15次的运行结果&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://jelly54.github.io/categories/Mysql/"/>
    
    
      <category term="mysql" scheme="https://jelly54.github.io/tags/mysql/"/>
    
      <category term="mysql profile" scheme="https://jelly54.github.io/tags/mysql-profile/"/>
    
  </entry>
  
</feed>
